; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\ethercatcoe.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\ethercatcoe.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\FWLIB\STM32F4xx_StdPeriph_Driver\inc -I..\USER -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\ETHERNET -I..\HARDWARE\TIMER -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\RTC -I..\HARDWARE\ADC -I..\HARDWARE\SRAM -I..\HARDWARE\InterTemperate -I..\FWLIB\STM32F4x7_ETH_Driver\inc -I..\MALLOC -I..\USMART -I..\HARDWARE -I..\ETHERCAT -I.\RTE\_LWIP -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS --omf_browse=..\obj\ethercatcoe.crf ..\ETHERCAT\ethercatcoe.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ecx_SDOerror PROC
;;;79      */
;;;80     void ecx_SDOerror(ecx_contextt *context, uint16 Slave, uint16 Index, uint8 SubIdx, int32 AbortCode)
000000  b57f              PUSH     {r0-r6,lr}
;;;81     {
;;;82        ec_errort Ec;
;;;83     
;;;84        memset(&Ec, 0, sizeof(Ec));
000002  2400              MOVS     r4,#0
000004  9401              STR      r4,[sp,#4]
000006  9d08              LDR      r5,[sp,#0x20]
000008  9400              STR      r4,[sp,#0]
;;;85        Ec.Slave = Slave;
;;;86        Ec.Index = Index;
00000a  f8ad2004          STRH     r2,[sp,#4]
00000e  9402              STR      r4,[sp,#8]            ;84
000010  9403              STR      r4,[sp,#0xc]          ;85
000012  f8ad1002          STRH     r1,[sp,#2]            ;85
;;;87        Ec.SubIdx = SubIdx;
000016  f88d3006          STRB     r3,[sp,#6]
;;;88        *(context->ecaterror) = TRUE;
00001a  6ac2              LDR      r2,[r0,#0x2c]
00001c  2101              MOVS     r1,#1
00001e  7011              STRB     r1,[r2,#0]
;;;89        Ec.Etype = EC_ERR_TYPE_SDO_ERROR;
000020  f88d4007          STRB     r4,[sp,#7]
;;;90        Ec.AbortCode = AbortCode;
;;;91        ecx_pusherror(context, &Ec);
000024  4669              MOV      r1,sp
000026  9502              STR      r5,[sp,#8]
000028  f7fffffe          BL       ecx_pusherror
;;;92     }
00002c  bd7f              POP      {r0-r6,pc}
;;;93     
                          ENDP

                  ecx_SDOread PROC
;;;111     */
;;;112    int ecx_SDOread(ecx_contextt *context, uint16 slave, uint16 index, uint8 subindex,
00002e  e92d4fff          PUSH     {r0-r11,lr}
;;;113                   boolean CA, int *psize, void *p, int timeout)
;;;114    {
000032  f6ad3dac          SUB      sp,sp,#0xbac
000036  4682              MOV      r10,r0
;;;115       ec_SDOt *SDOp, *aSDOp;
;;;116       uint16 bytesize, Framedatasize;
;;;117       int wkc;
;;;118       int32 SDOlen;
;;;119       uint8 *bp;
;;;120       uint8 *hp;
;;;121       ec_mbxbuft MbxIn, MbxOut;
;;;122       uint8 cnt, toggle;
;;;123       boolean NotLast;
;;;124    
;;;125       ec_clearmbx(&MbxIn);
000038  a802              ADD      r0,sp,#8
00003a  f8dd9be8          LDR      r9,[sp,#0xbe8]
00003e  f8dd8be0          LDR      r8,[sp,#0xbe0]
000042  f8dd6be4          LDR      r6,[sp,#0xbe4]
000046  f7fffffe          BL       ec_clearmbx
;;;126       /* Empty slave out mailbox if something is in. Timout set to 0 */
;;;127       wkc = ecx_mbxreceive(context, slave, (ec_mbxbuft *)&MbxIn, 0);
00004a  2300              MOVS     r3,#0
00004c  aa02              ADD      r2,sp,#8
00004e  4650              MOV      r0,r10
000050  f8dd1bb0          LDR      r1,[sp,#0xbb0]
000054  f7fffffe          BL       ecx_mbxreceive
;;;128       ec_clearmbx(&MbxOut);
000058  f50d60bb          ADD      r0,sp,#0x5d8
00005c  f7fffffe          BL       ec_clearmbx
;;;129       aSDOp = (ec_SDOt *)&MbxIn;
;;;130       SDOp = (ec_SDOt *)&MbxOut;
;;;131       SDOp->MbxHeader.length = htoes(0x000a);
000060  200a              MOVS     r0,#0xa
000062  f8ad05d8          STRH     r0,[sp,#0x5d8]
;;;132       SDOp->MbxHeader.address = htoes(0x0000);
;;;133       SDOp->MbxHeader.priority = 0x00;
;;;134       /* get new mailbox count value, used as session handle */
;;;135       cnt = ec_nextmbxcnt(context->slavelist[slave].mbx_cnt);
000066  f8dd0bb0          LDR      r0,[sp,#0xbb0]
00006a  2500              MOVS     r5,#0                 ;132
00006c  eb0001c0          ADD      r1,r0,r0,LSL #3
000070  f8ad55da          STRH     r5,[sp,#0x5da]        ;132
000074  f88d55dc          STRB     r5,[sp,#0x5dc]        ;133
000078  eb011180          ADD      r1,r1,r0,LSL #6
00007c  f8da2004          LDR      r2,[r10,#4]
000080  20ca              MOVS     r0,#0xca
000082  eb000b81          ADD      r11,r0,r1,LSL #2
000086  ac02              ADD      r4,sp,#8              ;129
000088  f812000b          LDRB     r0,[r2,r11]
00008c  f7fffffe          BL       ec_nextmbxcnt
;;;136       context->slavelist[slave].mbx_cnt = cnt;
000090  f8da2004          LDR      r2,[r10,#4]
;;;137       SDOp->MbxHeader.mbxtype = ECT_MBXT_COE + (cnt << 4); /* CoE */
000094  2703              MOVS     r7,#3
;;;138       SDOp->CANOpen = htoes(0x000 + (ECT_COES_SDOREQ << 12)); /* number 9bits service upper 4 bits (SDO request) */
;;;139       if (CA)
000096  f1b80f00          CMP      r8,#0
00009a  f802000b          STRB     r0,[r2,r11]           ;136
00009e  eb071000          ADD      r0,r7,r0,LSL #4       ;137
0000a2  f88d05dd          STRB     r0,[sp,#0x5dd]        ;137
0000a6  f44f5000          MOV      r0,#0x2000            ;138
0000aa  f8ad05de          STRH     r0,[sp,#0x5de]        ;138
0000ae  d002              BEQ      |L1.182|
;;;140       {
;;;141          SDOp->Command = ECT_SDO_UP_REQ_CA; /* upload request complete access */
0000b0  f04f0050          MOV      r0,#0x50
0000b4  e001              B        |L1.186|
                  |L1.182|
;;;142       }
;;;143       else
;;;144       {
;;;145          SDOp->Command = ECT_SDO_UP_REQ; /* upload request normal */
0000b6  f04f0040          MOV      r0,#0x40
                  |L1.186|
0000ba  f88d05e0          STRB     r0,[sp,#0x5e0]
;;;146       }
;;;147       SDOp->Index = htoes(index);
0000be  f8dd0bb4          LDR      r0,[sp,#0xbb4]
0000c2  f8ad05e1          STRH     r0,[sp,#0x5e1]
0000c6  d006              BEQ      |L1.214|
;;;148       if (CA && (subindex > 1))
0000c8  f8dd0bb8          LDR      r0,[sp,#0xbb8]
0000cc  2801              CMP      r0,#1
0000ce  d902              BLS      |L1.214|
;;;149       {
;;;150          subindex = 1;
0000d0  2001              MOVS     r0,#1
0000d2  f8cd0bb8          STR      r0,[sp,#0xbb8]
                  |L1.214|
;;;151       }
;;;152       SDOp->SubIndex = subindex;
0000d6  f8dd0bb8          LDR      r0,[sp,#0xbb8]
0000da  f88d05e3          STRB     r0,[sp,#0x5e3]
;;;153       SDOp->ldata[0] = 0;
0000de  2000              MOVS     r0,#0
;;;154       /* send CoE request to slave */
;;;155       wkc = ecx_mbxsend(context, slave, (ec_mbxbuft *)&MbxOut, EC_TIMEOUTTXM);
0000e0  f8cd05e4          STR      r0,[sp,#0x5e4]
0000e4  f6446320          MOV      r3,#0x4e20
0000e8  f50d62bb          ADD      r2,sp,#0x5d8
0000ec  4650              MOV      r0,r10
0000ee  f8dd1bb0          LDR      r1,[sp,#0xbb0]
0000f2  f7fffffe          BL       ecx_mbxsend
0000f6  1e05              SUBS     r5,r0,#0
                  |L1.248|
;;;156    	 if (wkc > 0) /* succeeded to place mailbox in slave ? */
0000f8  dd37              BLE      |L1.362|
;;;157       {
;;;158          /* clean mailboxbuffer */
;;;159          ec_clearmbx(&MbxIn);
0000fa  a802              ADD      r0,sp,#8
0000fc  f7fffffe          BL       ec_clearmbx
;;;160          /* read slave response */
;;;161          wkc = ecx_mbxreceive(context, slave, (ec_mbxbuft *)&MbxIn, timeout);
000100  aa02              ADD      r2,sp,#8
000102  4650              MOV      r0,r10
000104  f8dd3bec          LDR      r3,[sp,#0xbec]
000108  f8dd1bb0          LDR      r1,[sp,#0xbb0]
00010c  f7fffffe          BL       ecx_mbxreceive
000110  1e05              SUBS     r5,r0,#0
;;;162          if (wkc > 0) /* succeeded to read slave response ? */
000112  ddf1              BLE      |L1.248|
;;;163          {
;;;164             /* slave response should be CoE, SDO response and the correct index */
;;;165             if (((aSDOp->MbxHeader.mbxtype & 0x0f) == ECT_MBXT_COE) &&
000114  f89d000d          LDRB     r0,[sp,#0xd]
000118  f000000f          AND      r0,r0,#0xf
00011c  2803              CMP      r0,#3
                  |L1.286|
00011e  d17d              BNE      |L1.540|
;;;166                 ((etohs(aSDOp->CANOpen) >> 12) == ECT_COES_SDORES) &&
000120  f8bd100e          LDRH     r1,[sp,#0xe]
000124  ebb03f11          CMP      r0,r1,LSR #12
000128  d1f9              BNE      |L1.286|
;;;167                  (aSDOp->Index == SDOp->Index))
00012a  f8bd0011          LDRH     r0,[sp,#0x11]
00012e  f8bd15e1          LDRH     r1,[sp,#0x5e1]
000132  4288              CMP      r0,r1
000134  d1f3              BNE      |L1.286|
;;;168             {
;;;169                if ((aSDOp->Command & 0x02) > 0)
000136  f89d0010          LDRB     r0,[sp,#0x10]
00013a  0781              LSLS     r1,r0,#30
00013c  d516              BPL      |L1.364|
;;;170                { 
;;;171                   /* expedited frame response */
;;;172                   bytesize = 4 - ((aSDOp->Command >> 2) & 0x03);
00013e  f3c00081          UBFX     r0,r0,#2,#2
000142  f1c00704          RSB      r7,r0,#4
;;;173                   if (*psize >= bytesize) /* parameter buffer big enough ? */
000146  6830              LDR      r0,[r6,#0]
000148  42b8              CMP      r0,r7
00014a  db04              BLT      |L1.342|
;;;174                   {
;;;175                      /* copy parameter in parameter buffer */
;;;176                      memcpy(p, &aSDOp->ldata[0], bytesize);
00014c  463a              MOV      r2,r7
00014e  f104010c          ADD      r1,r4,#0xc
000152  4648              MOV      r0,r9
;;;177                      /* return the real parameter size */
;;;178                      *psize = bytesize;
000154  e0b4              B        |L1.704|
                  |L1.342|
;;;179                   }
;;;180                   else
;;;181                   {
;;;182                      wkc = 0;
;;;183                      ecx_packeterror(context, slave, index, subindex, 3); /*  data container too small for type */
000156  2003              MOVS     r0,#3
000158  9000              STR      r0,[sp,#0]
00015a  f50d643b          ADD      r4,sp,#0xbb0
00015e  2500              MOVS     r5,#0                 ;182
000160  e894000e          LDM      r4,{r1-r3}
000164  4650              MOV      r0,r10
000166  f7fffffe          BL       ecx_packeterror
                  |L1.362|
00016a  e0bb              B        |L1.740|
                  |L1.364|
;;;184                   }
;;;185                }
;;;186                else
;;;187                { /* normal frame response */
;;;188                   SDOlen = etohl(aSDOp->ldata[0]);
;;;189                   /* Does parameter fit in parameter buffer ? */
;;;190                   if (SDOlen <= *psize)
00016c  9f05              LDR      r7,[sp,#0x14]
00016e  6830              LDR      r0,[r6,#0]
000170  42b8              CMP      r0,r7
000172  dbf0              BLT      |L1.342|
;;;191                   {
;;;192                      bp = p;
;;;193                      hp = p;
;;;194                      /* calculate mailbox transfer size */
;;;195                      Framedatasize = (etohs(aSDOp->MbxHeader.length) - 10);
000174  f8bd1008          LDRH     r1,[sp,#8]
000178  4648              MOV      r0,r9                 ;193
00017a  390a              SUBS     r1,r1,#0xa
00017c  b28a              UXTH     r2,r1
00017e  4690              MOV      r8,r2
000180  a906              ADD      r1,sp,#0x18           ;121
;;;196                      if (Framedatasize < SDOlen) /* transfer in segments? */
000182  42ba              CMP      r2,r7
000184  da7d              BGE      |L1.642|
;;;197                      {
;;;198                         /* copy parameter data in parameter buffer */
;;;199                         memcpy(hp, &aSDOp->ldata[1], Framedatasize);
000186  f7fffffe          BL       __aeabi_memcpy
;;;200                         /* increment buffer pointer */
;;;201                         hp += Framedatasize;
00018a  eb090008          ADD      r0,r9,r8
;;;202                         *psize = Framedatasize;
00018e  9001              STR      r0,[sp,#4]
;;;203                         NotLast = TRUE;
;;;204                         toggle= 0x00;
000190  f8c68000          STR      r8,[r6,#0]
000194  f04f0901          MOV      r9,#1                 ;203
000198  f04f0800          MOV      r8,#0
                  |L1.412|
;;;205                         while (NotLast) /* segmented transfer */
;;;206                         {
;;;207                            SDOp = (ec_SDOt *)&MbxOut;
;;;208                            SDOp->MbxHeader.length = htoes(0x000a);
00019c  200a              MOVS     r0,#0xa
;;;209                            SDOp->MbxHeader.address = htoes(0x0000);
00019e  2500              MOVS     r5,#0
0001a0  f8ad05d8          STRH     r0,[sp,#0x5d8]        ;208
0001a4  f8ad55da          STRH     r5,[sp,#0x5da]
;;;210                            SDOp->MbxHeader.priority = 0x00;
0001a8  f88d55dc          STRB     r5,[sp,#0x5dc]
;;;211                            cnt = ec_nextmbxcnt(context->slavelist[slave].mbx_cnt);
0001ac  f8da1004          LDR      r1,[r10,#4]
0001b0  f811000b          LDRB     r0,[r1,r11]
0001b4  f7fffffe          BL       ec_nextmbxcnt
;;;212                            context->slavelist[slave].mbx_cnt = cnt;
0001b8  f8da2004          LDR      r2,[r10,#4]
;;;213                            SDOp->MbxHeader.mbxtype = ECT_MBXT_COE + (cnt << 4); /* CoE */
0001bc  2703              MOVS     r7,#3
;;;214                            SDOp->CANOpen = htoes(0x000 + (ECT_COES_SDOREQ << 12)); /* number 9bits service upper 4 bits (SDO request) */
;;;215                            SDOp->Command = ECT_SDO_SEG_UP_REQ + toggle; /* segment upload request */
;;;216                            SDOp->Index = htoes(index);
;;;217                            SDOp->SubIndex = subindex;
;;;218                            SDOp->ldata[0] = 0;
;;;219                            /* send segmented upload request to slave */
;;;220                            wkc = ecx_mbxsend(context, slave, (ec_mbxbuft *)&MbxOut, EC_TIMEOUTTXM);
0001be  f6446320          MOV      r3,#0x4e20
0001c2  f802000b          STRB     r0,[r2,r11]           ;212
0001c6  eb071000          ADD      r0,r7,r0,LSL #4       ;213
0001ca  f88d05dd          STRB     r0,[sp,#0x5dd]        ;213
0001ce  f44f5000          MOV      r0,#0x2000            ;214
0001d2  f8ad05de          STRH     r0,[sp,#0x5de]        ;214
0001d6  f1080060          ADD      r0,r8,#0x60           ;215
0001da  f88d05e0          STRB     r0,[sp,#0x5e0]        ;215
0001de  f8dd0bb4          LDR      r0,[sp,#0xbb4]        ;216
0001e2  f8ad05e1          STRH     r0,[sp,#0x5e1]        ;216
0001e6  f8dd0bb8          LDR      r0,[sp,#0xbb8]        ;217
0001ea  f88d05e3          STRB     r0,[sp,#0x5e3]        ;217
0001ee  f50d62bb          ADD      r2,sp,#0x5d8
0001f2  f8cd55e4          STR      r5,[sp,#0x5e4]
0001f6  4650              MOV      r0,r10
0001f8  f8dd1bb0          LDR      r1,[sp,#0xbb0]
0001fc  f7fffffe          BL       ecx_mbxsend
000200  1e05              SUBS     r5,r0,#0
;;;221                            /* is mailbox transfered to slave ? */
;;;222                            if (wkc > 0)
000202  dd29              BLE      |L1.600|
;;;223                            {
;;;224                               ec_clearmbx(&MbxIn);
000204  a802              ADD      r0,sp,#8
000206  f7fffffe          BL       ec_clearmbx
;;;225                               /* read slave response */
;;;226                               wkc = ecx_mbxreceive(context, slave, (ec_mbxbuft *)&MbxIn, timeout);
00020a  aa02              ADD      r2,sp,#8
00020c  4650              MOV      r0,r10
00020e  f8dd3bec          LDR      r3,[sp,#0xbec]
000212  f8dd1bb0          LDR      r1,[sp,#0xbb0]
000216  f7fffffe          BL       ecx_mbxreceive
00021a  e000              B        |L1.542|
                  |L1.540|
00021c  e054              B        |L1.712|
                  |L1.542|
00021e  1e05              SUBS     r5,r0,#0
;;;227                               /* has slave responded ? */
;;;228                               if (wkc > 0)
000220  dd1a              BLE      |L1.600|
;;;229                               {
;;;230                                  /* slave response should be CoE, SDO response */
;;;231                                  if ((((aSDOp->MbxHeader.mbxtype & 0x0f) == ECT_MBXT_COE) &&
000222  7960              LDRB     r0,[r4,#5]
000224  f000000f          AND      r0,r0,#0xf
000228  2803              CMP      r0,#3
00022a  d106              BNE      |L1.570|
;;;232                                       ((etohs(aSDOp->CANOpen) >> 12) == ECT_COES_SDORES) && 
00022c  88e0              LDRH     r0,[r4,#6]
00022e  ebb73f10          CMP      r7,r0,LSR #12
000232  d102              BNE      |L1.570|
;;;233                                       ((aSDOp->Command & 0xe0) == 0x00)))
000234  7a20              LDRB     r0,[r4,#8]
000236  0941              LSRS     r1,r0,#5
000238  d014              BEQ      |L1.612|
                  |L1.570|
;;;234                                            {
;;;235                                     /* calculate mailbox transfer size */
;;;236                                     Framedatasize = etohs(aSDOp->MbxHeader.length) - 3;
;;;237                                     if ((aSDOp->Command & 0x01) > 0)
;;;238                                     { /* last segment */
;;;239                                        NotLast = FALSE;
;;;240                                        if (Framedatasize == 7)
;;;241                                           /* substract unused bytes from frame */
;;;242                                           Framedatasize = Framedatasize - ((aSDOp->Command & 0x0e) >> 1);
;;;243                                        /* copy to parameter buffer */
;;;244                                        memcpy(hp, &(aSDOp->Index), Framedatasize);
;;;245                                     }
;;;246                                     else /* segments follow */
;;;247                                     {
;;;248                                        /* copy to parameter buffer */
;;;249                                        memcpy(hp, &(aSDOp->Index), Framedatasize);
;;;250                                        /* increment buffer pointer */
;;;251                                        hp += Framedatasize;
;;;252                                     }
;;;253                                     /* update parametersize */
;;;254                                     *psize += Framedatasize;
;;;255                                  }
;;;256                                  /* unexpected frame returned from slave */
;;;257                                  else
;;;258                                  {
;;;259                                     NotLast = FALSE;
;;;260                                     if ((aSDOp->Command) == ECT_SDO_ABORT) /* SDO abort frame received */
00023a  7a20              LDRB     r0,[r4,#8]
00023c  f04f0900          MOV      r9,#0                 ;259
000240  2880              CMP      r0,#0x80
000242  d032              BEQ      |L1.682|
;;;261                                        ecx_SDOerror(context, slave, index, subindex, etohl(aSDOp->ldata[0]));
;;;262                                     else
;;;263                                        ecx_packeterror(context, slave, index, subindex, 1); /* Unexpected frame returned */
000244  2001              MOVS     r0,#1
000246  9000              STR      r0,[sp,#0]
000248  f50d653b          ADD      r5,sp,#0xbb0
00024c  4650              MOV      r0,r10
00024e  e895000e          LDM      r5,{r1-r3}
000252  f7fffffe          BL       ecx_packeterror
                  |L1.598|
;;;264                                     wkc = 0;
000256  2500              MOVS     r5,#0
                  |L1.600|
;;;265                                  }
;;;266                               }
;;;267                            }
;;;268                            toggle = toggle ^ 0x10; /* toggle bit for segment request */
000258  f0880810          EOR      r8,r8,#0x10
00025c  f1b90f00          CMP      r9,#0                 ;205
000260  d19c              BNE      |L1.412|
000262  e03f              B        |L1.740|
                  |L1.612|
000264  8821              LDRH     r1,[r4,#0]            ;236
000266  1ec9              SUBS     r1,r1,#3              ;236
000268  b28f              UXTH     r7,r1                 ;236
00026a  07c1              LSLS     r1,r0,#31             ;237
00026c  d010              BEQ      |L1.656|
00026e  f04f0900          MOV      r9,#0                 ;239
000272  2f07              CMP      r7,#7                 ;240
000274  d103              BNE      |L1.638|
000276  f3c00042          UBFX     r0,r0,#1,#3           ;242
00027a  f1c00707          RSB      r7,r0,#7              ;242
                  |L1.638|
00027e  463a              MOV      r2,r7                 ;244
000280  e000              B        |L1.644|
                  |L1.642|
000282  e01c              B        |L1.702|
                  |L1.644|
000284  f1040109          ADD      r1,r4,#9              ;244
000288  9801              LDR      r0,[sp,#4]            ;244
00028a  f7fffffe          BL       __aeabi_memcpy
00028e  e008              B        |L1.674|
                  |L1.656|
000290  463a              MOV      r2,r7                 ;249
000292  f1040109          ADD      r1,r4,#9              ;249
000296  9801              LDR      r0,[sp,#4]            ;249
000298  f7fffffe          BL       __aeabi_memcpy
00029c  9801              LDR      r0,[sp,#4]            ;251
00029e  4438              ADD      r0,r0,r7              ;251
0002a0  9001              STR      r0,[sp,#4]            ;251
                  |L1.674|
0002a2  6830              LDR      r0,[r6,#0]            ;254
0002a4  4438              ADD      r0,r0,r7              ;254
0002a6  6030              STR      r0,[r6,#0]            ;254
0002a8  e7d6              B        |L1.600|
                  |L1.682|
0002aa  68e0              LDR      r0,[r4,#0xc]          ;261
0002ac  9000              STR      r0,[sp,#0]            ;261
0002ae  f50d653b          ADD      r5,sp,#0xbb0          ;261
0002b2  4650              MOV      r0,r10                ;261
0002b4  e895000e          LDM      r5,{r1-r3}            ;261
0002b8  f7fffffe          BL       ecx_SDOerror
0002bc  e7cb              B        |L1.598|
                  |L1.702|
;;;269                         }
;;;270                      }
;;;271                      /* non segmented transfer */
;;;272                      else
;;;273                      {
;;;274                         /* copy to parameter buffer */
;;;275                         memcpy(bp, &aSDOp->ldata[1], SDOlen);
0002be  463a              MOV      r2,r7
                  |L1.704|
0002c0  f7fffffe          BL       __aeabi_memcpy
0002c4  6037              STR      r7,[r6,#0]            ;178
0002c6  e00d              B        |L1.740|
                  |L1.712|
;;;276                         *psize = SDOlen;
;;;277                      }
;;;278                   }
;;;279                   /* parameter buffer too small */
;;;280                   else
;;;281                   {
;;;282                      wkc = 0;
;;;283                      ecx_packeterror(context, slave, index, subindex, 3); /*  data container too small for type */
;;;284                   }
;;;285                }
;;;286             }
;;;287             /* other slave response */
;;;288             else
;;;289             {
;;;290                if ((aSDOp->Command) == ECT_SDO_ABORT) /* SDO abort frame received */
0002c8  f89d0010          LDRB     r0,[sp,#0x10]
0002cc  2880              CMP      r0,#0x80
0002ce  d00e              BEQ      |L1.750|
;;;291                {
;;;292                   ecx_SDOerror(context, slave, index, subindex, etohl(aSDOp->ldata[0]));
;;;293                }
;;;294                else
;;;295                {
;;;296                   ecx_packeterror(context, slave, index, subindex, 1); /* Unexpected frame returned */
0002d0  2001              MOVS     r0,#1
0002d2  9000              STR      r0,[sp,#0]
0002d4  f50d643b          ADD      r4,sp,#0xbb0
0002d8  4650              MOV      r0,r10
0002da  e894000e          LDM      r4,{r1-r3}
0002de  f7fffffe          BL       ecx_packeterror
                  |L1.738|
;;;297                }
;;;298                wkc = 0;
0002e2  2500              MOVS     r5,#0
                  |L1.740|
;;;299             }
;;;300          }
;;;301       }
;;;302       return wkc;
0002e4  4628              MOV      r0,r5
                  |L1.742|
;;;303    }
0002e6  f60d3dbc          ADD      sp,sp,#0xbbc
                  |L1.746|
0002ea  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.750|
0002ee  9805              LDR      r0,[sp,#0x14]         ;292
0002f0  9000              STR      r0,[sp,#0]            ;292
0002f2  f50d643b          ADD      r4,sp,#0xbb0          ;292
0002f6  4650              MOV      r0,r10                ;292
0002f8  e894000e          LDM      r4,{r1-r3}            ;292
0002fc  f7fffffe          BL       ecx_SDOerror
000300  e7ef              B        |L1.738|
;;;304    
                          ENDP

                  ecx_SDOwrite PROC
;;;321     */
;;;322    int ecx_SDOwrite(ecx_contextt *context, uint16 Slave, uint16 Index, uint8 SubIndex,
000302  e92d4fff          PUSH     {r0-r11,lr}
;;;323                    boolean CA, int psize, void *p, int Timeout)
;;;324    {
000306  f6ad3dac          SUB      sp,sp,#0xbac
00030a  4607              MOV      r7,r0
;;;325       ec_SDOt *SDOp, *aSDOp;
;;;326       int wkc, maxdata;
;;;327       ec_mbxbuft MbxIn, MbxOut;
;;;328       uint8 cnt, toggle;
;;;329       uint16 framedatasize;
;;;330       boolean  NotLast;
;;;331       uint8 *hp;
;;;332    
;;;333       ec_clearmbx(&MbxIn);
00030c  a802              ADD      r0,sp,#8
00030e  f8dd9be4          LDR      r9,[sp,#0xbe4]
000312  f7fffffe          BL       ec_clearmbx
;;;334       /* Empty slave out mailbox if something is in. Timout set to 0 */
;;;335       wkc = ecx_mbxreceive(context, Slave, (ec_mbxbuft *)&MbxIn, 0);
000316  2300              MOVS     r3,#0
000318  aa02              ADD      r2,sp,#8
00031a  4638              MOV      r0,r7
00031c  f8dd1bb0          LDR      r1,[sp,#0xbb0]
000320  f7fffffe          BL       ecx_mbxreceive
;;;336    	 ec_clearmbx(&MbxOut);
000324  f50d60bb          ADD      r0,sp,#0x5d8
000328  f7fffffe          BL       ec_clearmbx
;;;337       aSDOp = (ec_SDOt *)&MbxIn;
;;;338       SDOp = (ec_SDOt *)&MbxOut;
;;;339       maxdata = context->slavelist[Slave].mbx_l - 0x10; /* data section=mailbox size - 6 mbx - 2 CoE - 8 sdo req */
00032c  f8dd0bb0          LDR      r0,[sp,#0xbb0]
000330  6879              LDR      r1,[r7,#4]
000332  eb0002c0          ADD      r2,r0,r0,LSL #3
000336  eb021080          ADD      r0,r2,r0,LSL #6
00033a  22c0              MOVS     r2,#0xc0
00033c  eb020280          ADD      r2,r2,r0,LSL #2
000340  5a89              LDRH     r1,[r1,r2]
;;;340       /* if small data use expedited transfer */
;;;341       if ((psize <= 4) && !CA)
;;;342       {
;;;343          SDOp->MbxHeader.length = htoes(0x000a);
;;;344          SDOp->MbxHeader.address = htoes(0x0000);
;;;345          SDOp->MbxHeader.priority = 0x00;
;;;346          /* get new mailbox counter, used for session handle */
;;;347          cnt = ec_nextmbxcnt(context->slavelist[Slave].mbx_cnt);
000342  23ca              MOVS     r3,#0xca
000344  f1a10b10          SUB      r11,r1,#0x10          ;339
000348  2100              MOVS     r1,#0                 ;339
00034a  ad02              ADD      r5,sp,#8              ;337
00034c  f50d6abb          ADD      r10,sp,#0x5d8         ;338
000350  eb030880          ADD      r8,r3,r0,LSL #2
000354  f1b90f04          CMP      r9,#4                 ;341
000358  dc02              BGT      |L1.864|
00035a  f8dd0be0          LDR      r0,[sp,#0xbe0]        ;341
00035e  b340              CBZ      r0,|L1.946|
                  |L1.864|
;;;348          context->slavelist[Slave].mbx_cnt = cnt;
;;;349          SDOp->MbxHeader.mbxtype = ECT_MBXT_COE + (cnt << 4); /* CoE */
;;;350          SDOp->CANOpen = htoes(0x000 + (ECT_COES_SDOREQ << 12)); /* number 9bits service upper 4 bits */
;;;351          SDOp->Command = ECT_SDO_DOWN_EXP | (((4 - psize) << 2) & 0x0c); /* expedited SDO download transfer */
;;;352          SDOp->Index = htoes(Index);
;;;353          SDOp->SubIndex = SubIndex;
;;;354          hp = p;
;;;355          /* copy parameter data to mailbox */
;;;356          memcpy(&SDOp->ldata[0], hp, psize);
;;;357          /* send mailbox SDO download request to slave */
;;;358          wkc = ecx_mbxsend(context, Slave, (ec_mbxbuft *)&MbxOut, EC_TIMEOUTTXM);
;;;359          if (wkc > 0)
;;;360          {
;;;361    		  ec_clearmbx(&MbxIn);
;;;362             /* read slave response */
;;;363             wkc = ecx_mbxreceive(context, Slave, (ec_mbxbuft *)&MbxIn, Timeout);
;;;364             if (wkc > 0)
;;;365             {
;;;366                /* response should be CoE, SDO response, correct index and subindex */
;;;367                if (((aSDOp->MbxHeader.mbxtype & 0x0f) == ECT_MBXT_COE) && 
;;;368                    ((etohs(aSDOp->CANOpen) >> 12) == ECT_COES_SDORES) &&
;;;369                     (aSDOp->Index == SDOp->Index) &&
;;;370                     (aSDOp->SubIndex == SDOp->SubIndex))
;;;371                {
;;;372                     /* all OK */
;;;373                }
;;;374                /* unexpected response from slave */
;;;375                else
;;;376                {
;;;377                   if (aSDOp->Command == ECT_SDO_ABORT) /* SDO abort frame received */
;;;378                   {
;;;379                      ecx_SDOerror(context, Slave, Index, SubIndex, etohl(aSDOp->ldata[0]));
;;;380                   }
;;;381                   else
;;;382                   {
;;;383                      ecx_packeterror(context, Slave, Index, SubIndex, 1); /* Unexpected frame returned */
;;;384                   }
;;;385                   wkc = 0;
;;;386                }
;;;387             }
;;;388          }
;;;389       }
;;;390       else
;;;391       {
;;;392          framedatasize = psize;
000360  fa1ff489          UXTH     r4,r9
;;;393          NotLast = FALSE;
000364  2600              MOVS     r6,#0
;;;394          if (framedatasize > maxdata)
000366  455c              CMP      r4,r11
000368  dd02              BLE      |L1.880|
;;;395          {
;;;396             framedatasize = maxdata;  /*  segmented transfer needed  */
00036a  fa1ff48b          UXTH     r4,r11
;;;397             NotLast = TRUE;
00036e  2601              MOVS     r6,#1
                  |L1.880|
;;;398          }
;;;399          SDOp->MbxHeader.length = htoes(0x0a + framedatasize);
000370  f104000a          ADD      r0,r4,#0xa
000374  f8ad05d8          STRH     r0,[sp,#0x5d8]
;;;400          SDOp->MbxHeader.address = htoes(0x0000);
000378  2000              MOVS     r0,#0
00037a  f8ad05da          STRH     r0,[sp,#0x5da]
;;;401          SDOp->MbxHeader.priority = 0x00;
00037e  f88d05dc          STRB     r0,[sp,#0x5dc]
;;;402          /* get new mailbox counter, used for session handle */
;;;403          cnt = ec_nextmbxcnt(context->slavelist[Slave].mbx_cnt);
000382  6879              LDR      r1,[r7,#4]
000384  f8110008          LDRB     r0,[r1,r8]
000388  f7fffffe          BL       ec_nextmbxcnt
;;;404          context->slavelist[Slave].mbx_cnt = cnt;
00038c  687a              LDR      r2,[r7,#4]
;;;405          SDOp->MbxHeader.mbxtype = ECT_MBXT_COE + (cnt << 4); /* CoE */
00038e  2103              MOVS     r1,#3
000390  f8020008          STRB     r0,[r2,r8]            ;404
000394  eb011000          ADD      r0,r1,r0,LSL #4
000398  f88d05dd          STRB     r0,[sp,#0x5dd]
;;;406          SDOp->CANOpen = htoes(0x000 + (ECT_COES_SDOREQ << 12)); /* number 9bits service upper 4 bits */
00039c  f44f5000          MOV      r0,#0x2000
0003a0  f8ad05de          STRH     r0,[sp,#0x5de]
;;;407          if (CA)
0003a4  f8dd0be0          LDR      r0,[sp,#0xbe0]
0003a8  2800              CMP      r0,#0
0003aa  d072              BEQ      |L1.1170|
;;;408          {
;;;409             SDOp->Command = ECT_SDO_DOWN_INIT_CA; /* Complete Access, normal SDO init download transfer */
0003ac  f04f0031          MOV      r0,#0x31
0003b0  e071              B        |L1.1174|
                  |L1.946|
0003b2  f04f000a          MOV      r0,#0xa               ;343
0003b6  f8ad05d8          STRH     r0,[sp,#0x5d8]        ;343
0003ba  f8ad15da          STRH     r1,[sp,#0x5da]        ;344
0003be  f88d15dc          STRB     r1,[sp,#0x5dc]        ;345
0003c2  6879              LDR      r1,[r7,#4]            ;347
0003c4  f8110008          LDRB     r0,[r1,r8]            ;347
0003c8  f7fffffe          BL       ec_nextmbxcnt
0003cc  687a              LDR      r2,[r7,#4]            ;348
0003ce  2403              MOVS     r4,#3                 ;349
0003d0  210c              MOVS     r1,#0xc               ;351
0003d2  f8020008          STRB     r0,[r2,r8]            ;348
0003d6  eb041000          ADD      r0,r4,r0,LSL #4       ;349
0003da  f88d05dd          STRB     r0,[sp,#0x5dd]        ;349
0003de  f44f5000          MOV      r0,#0x2000            ;350
0003e2  f8ad05de          STRH     r0,[sp,#0x5de]        ;350
0003e6  f1c90004          RSB      r0,r9,#4              ;351
0003ea  ea010080          AND      r0,r1,r0,LSL #2       ;351
0003ee  f0400023          ORR      r0,r0,#0x23           ;351
0003f2  f88d05e0          STRB     r0,[sp,#0x5e0]        ;351
0003f6  f8dd0bb4          LDR      r0,[sp,#0xbb4]        ;352
0003fa  f8ad05e1          STRH     r0,[sp,#0x5e1]        ;352
0003fe  f8dd0bb8          LDR      r0,[sp,#0xbb8]        ;353
000402  f88d05e3          STRB     r0,[sp,#0x5e3]        ;353
000406  464a              MOV      r2,r9                 ;356
000408  f10a000c          ADD      r0,r10,#0xc           ;356
00040c  f8dd1be8          LDR      r1,[sp,#0xbe8]        ;356
000410  f7fffffe          BL       __aeabi_memcpy
000414  f6446320          MOV      r3,#0x4e20            ;358
000418  f50d62bb          ADD      r2,sp,#0x5d8          ;358
00041c  4638              MOV      r0,r7                 ;358
00041e  f8dd1bb0          LDR      r1,[sp,#0xbb0]        ;358
000422  f7fffffe          BL       ecx_mbxsend
000426  2800              CMP      r0,#0                 ;359
000428  dd31              BLE      |L1.1166|
00042a  a802              ADD      r0,sp,#8              ;361
00042c  f7fffffe          BL       ec_clearmbx
000430  aa02              ADD      r2,sp,#8              ;363
000432  4638              MOV      r0,r7                 ;363
000434  f8dd3bec          LDR      r3,[sp,#0xbec]        ;363
000438  f8dd1bb0          LDR      r1,[sp,#0xbb0]        ;363
00043c  f7fffffe          BL       ecx_mbxreceive
000440  2800              CMP      r0,#0                 ;364
000442  dd24              BLE      |L1.1166|
000444  f89d100d          LDRB     r1,[sp,#0xd]          ;367
000448  f001010f          AND      r1,r1,#0xf            ;367
00044c  2903              CMP      r1,#3                 ;367
00044e  d110              BNE      |L1.1138|
000450  f8bd100e          LDRH     r1,[sp,#0xe]          ;368
000454  ebb43f11          CMP      r4,r1,LSR #12         ;368
000458  d10b              BNE      |L1.1138|
00045a  f8bd1011          LDRH     r1,[sp,#0x11]         ;369
00045e  f8bd25e1          LDRH     r2,[sp,#0x5e1]        ;369
000462  4291              CMP      r1,r2                 ;369
000464  d105              BNE      |L1.1138|
000466  f89d1013          LDRB     r1,[sp,#0x13]         ;370
00046a  f89d25e3          LDRB     r2,[sp,#0x5e3]        ;370
00046e  4291              CMP      r1,r2                 ;370
000470  d00d              BEQ      |L1.1166|
                  |L1.1138|
000472  f89d0010          LDRB     r0,[sp,#0x10]         ;377
000476  2880              CMP      r0,#0x80              ;377
000478  d078              BEQ      |L1.1388|
;;;410          }
;;;411          else
;;;412          {
;;;413             SDOp->Command = ECT_SDO_DOWN_INIT; /* normal SDO init download transfer */
;;;414          }
;;;415          SDOp->Index = htoes(Index);
;;;416          SDOp->SubIndex = SubIndex;
;;;417          if (CA && (SubIndex > 1))
;;;418          {
;;;419             SDOp->SubIndex = 1;
;;;420          }		
;;;421          SDOp->ldata[0] = htoel(psize);
;;;422          hp = p;
;;;423          /* copy parameter data to mailbox */
;;;424          memcpy(&SDOp->ldata[1], hp, framedatasize);
;;;425          hp += framedatasize;
;;;426          psize -= framedatasize;
;;;427          /* send mailbox SDO download request to slave */
;;;428          wkc = ecx_mbxsend(context, Slave, (ec_mbxbuft *)&MbxOut, EC_TIMEOUTTXM);
;;;429          if (wkc > 0)
;;;430          {
;;;431             ec_clearmbx(&MbxIn);
;;;432             /* read slave response */
;;;433             wkc = ecx_mbxreceive(context, Slave, (ec_mbxbuft *)&MbxIn, Timeout);
;;;434    				if (wkc > 0)
;;;435             {
;;;436                /* response should be CoE, SDO response, correct index and subindex */
;;;437                if (((aSDOp->MbxHeader.mbxtype & 0x0f) == ECT_MBXT_COE) && 
;;;438                    ((etohs(aSDOp->CANOpen) >> 12) == ECT_COES_SDORES) &&
;;;439                     (aSDOp->Index == SDOp->Index) &&
;;;440                     (aSDOp->SubIndex == SDOp->SubIndex))
;;;441                {
;;;442                   /* all ok */
;;;443                   maxdata += 7;
;;;444                   toggle = 0;
;;;445                   /* repeat while segments left */
;;;446                   while (NotLast)
;;;447                   {
;;;448                      SDOp = (ec_SDOt *)&MbxOut;
;;;449                      framedatasize = psize;
;;;450                      NotLast = FALSE;
;;;451                      SDOp->Command = 0x01; /* last segment */
;;;452                      if (framedatasize > maxdata)
;;;453                      {
;;;454                         framedatasize = maxdata;  /*  more segments needed  */
;;;455                         NotLast = TRUE;
;;;456                         SDOp->Command = 0x00; /* segments follow */
;;;457                      }
;;;458                      if (!NotLast && (framedatasize < 7))
;;;459                      {
;;;460                         SDOp->MbxHeader.length = htoes(0x0a); /* minimum size */
;;;461                         SDOp->Command = 0x01 + ((7 - framedatasize) << 1); /* last segment reduced octets */
;;;462                      }
;;;463                      else
;;;464                      {
;;;465                         SDOp->MbxHeader.length = htoes(framedatasize + 3); /* data + 2 CoE + 1 SDO */
;;;466                      }
;;;467                      SDOp->MbxHeader.address = htoes(0x0000);
;;;468                      SDOp->MbxHeader.priority = 0x00;
;;;469                      /* get new mailbox counter value */
;;;470                      cnt = ec_nextmbxcnt(context->slavelist[Slave].mbx_cnt);
;;;471                      context->slavelist[Slave].mbx_cnt = cnt;
;;;472                      SDOp->MbxHeader.mbxtype = ECT_MBXT_COE + (cnt << 4); /* CoE */
;;;473                      SDOp->CANOpen = htoes(0x000 + (ECT_COES_SDOREQ << 12)); /* number 9bits service upper 4 bits (SDO request) */
;;;474                      SDOp->Command = SDOp->Command + toggle; /* add toggle bit to command byte */
;;;475                      /* copy parameter data to mailbox */
;;;476                      memcpy(&SDOp->Index, hp, framedatasize);
;;;477                      /* update parameter buffer pointer */
;;;478                      hp += framedatasize;
;;;479                      psize -= framedatasize;
;;;480                      /* send SDO download request */
;;;481                      wkc = ecx_mbxsend(context, Slave, (ec_mbxbuft *)&MbxOut, EC_TIMEOUTTXM);
;;;482                      if (wkc > 0)
;;;483                      {
;;;484                         ec_clearmbx(&MbxIn);
;;;485                         /* read slave response */
;;;486                         wkc = ecx_mbxreceive(context, Slave, (ec_mbxbuft *)&MbxIn, Timeout);
;;;487                         if (wkc > 0)
;;;488                         {
;;;489                            if (((aSDOp->MbxHeader.mbxtype & 0x0f) == ECT_MBXT_COE) &&
;;;490                                ((etohs(aSDOp->CANOpen) >> 12) == ECT_COES_SDORES) &&
;;;491                                ((aSDOp->Command & 0xe0) == 0x20))
;;;492                            {
;;;493                                       /* all OK, nothing to do */
;;;494                            }
;;;495                            else
;;;496                            {
;;;497                               if (aSDOp->Command == ECT_SDO_ABORT) /* SDO abort frame received */
;;;498                               {
;;;499                                  ecx_SDOerror(context, Slave, Index, SubIndex, etohl(aSDOp->ldata[0]));
;;;500                               }
;;;501                               else
;;;502                               {
;;;503                                  ecx_packeterror(context, Slave, Index, SubIndex, 1); /* Unexpected frame returned */
;;;504                               }
;;;505                               wkc = 0;
;;;506                               NotLast = FALSE;
;;;507                            }
;;;508                         }
;;;509                      }
;;;510                      toggle = toggle ^ 0x10; /* toggle bit for segment request */
;;;511                   }
;;;512                }
;;;513                /* unexpected response from slave */
;;;514                else
;;;515                {
;;;516                   if (aSDOp->Command == ECT_SDO_ABORT) /* SDO abort frame received */
;;;517                   {
;;;518                      ecx_SDOerror(context, Slave, Index, SubIndex, etohl(aSDOp->ldata[0]));
;;;519                   }
;;;520                   else
;;;521                   {
;;;522                      ecx_packeterror(context, Slave, Index, SubIndex, 1); /* Unexpected frame returned */
00047a  2001              MOVS     r0,#1
00047c  9000              STR      r0,[sp,#0]
00047e  f50d643b          ADD      r4,sp,#0xbb0
000482  4638              MOV      r0,r7
000484  e894000e          LDM      r4,{r1-r3}
000488  f7fffffe          BL       ecx_packeterror
                  |L1.1164|
00048c  2000              MOVS     r0,#0                 ;385
                  |L1.1166|
;;;523                   }
;;;524                   wkc = 0;
;;;525                }
;;;526             }
;;;527          }
;;;528       }
;;;529    
;;;530       return wkc;
;;;531    }
00048e  e72a              B        |L1.742|
000490  e7ff              B        |L1.1170|
                  |L1.1170|
000492  f04f0021          MOV      r0,#0x21              ;413
                  |L1.1174|
000496  f88d05e0          STRB     r0,[sp,#0x5e0]        ;413
00049a  f8dd0bb4          LDR      r0,[sp,#0xbb4]        ;415
00049e  f8ad05e1          STRH     r0,[sp,#0x5e1]        ;415
0004a2  f8dd0bb8          LDR      r0,[sp,#0xbb8]        ;416
0004a6  f88d05e3          STRB     r0,[sp,#0x5e3]        ;416
0004aa  d006              BEQ      |L1.1210|
0004ac  f8dd0bb8          LDR      r0,[sp,#0xbb8]        ;417
0004b0  2801              CMP      r0,#1                 ;417
0004b2  d902              BLS      |L1.1210|
0004b4  2001              MOVS     r0,#1                 ;419
0004b6  f88d05e3          STRB     r0,[sp,#0x5e3]        ;419
                  |L1.1210|
0004ba  f8cd95e4          STR      r9,[sp,#0x5e4]        ;422
0004be  f8dd0be8          LDR      r0,[sp,#0xbe8]        ;422
0004c2  9001              STR      r0,[sp,#4]            ;424
0004c4  4601              MOV      r1,r0                 ;424
0004c6  4622              MOV      r2,r4                 ;424
0004c8  f10a0010          ADD      r0,r10,#0x10          ;424
0004cc  f7fffffe          BL       __aeabi_memcpy
0004d0  9801              LDR      r0,[sp,#4]            ;425
0004d2  eba90a04          SUB      r10,r9,r4             ;426
0004d6  4420              ADD      r0,r0,r4              ;425
0004d8  9001              STR      r0,[sp,#4]            ;428
0004da  f6446320          MOV      r3,#0x4e20            ;428
0004de  f50d62bb          ADD      r2,sp,#0x5d8          ;428
0004e2  4638              MOV      r0,r7                 ;428
0004e4  f8dd1bb0          LDR      r1,[sp,#0xbb0]        ;428
0004e8  f7fffffe          BL       ecx_mbxsend
0004ec  2800              CMP      r0,#0                 ;429
0004ee  ddce              BLE      |L1.1166|
0004f0  a802              ADD      r0,sp,#8              ;431
0004f2  f7fffffe          BL       ec_clearmbx
0004f6  aa02              ADD      r2,sp,#8              ;433
0004f8  4638              MOV      r0,r7                 ;433
0004fa  f8dd3bec          LDR      r3,[sp,#0xbec]        ;433
0004fe  f8dd1bb0          LDR      r1,[sp,#0xbb0]        ;433
000502  f7fffffe          BL       ecx_mbxreceive
000506  2800              CMP      r0,#0                 ;434
000508  ddc1              BLE      |L1.1166|
00050a  f89d100d          LDRB     r1,[sp,#0xd]          ;437
00050e  f001010f          AND      r1,r1,#0xf            ;437
000512  2903              CMP      r1,#3                 ;437
000514  d1ad              BNE      |L1.1138|
000516  f8bd200e          LDRH     r2,[sp,#0xe]          ;438
00051a  ebb13f12          CMP      r1,r2,LSR #12         ;438
00051e  d1a8              BNE      |L1.1138|
000520  f8bd1011          LDRH     r1,[sp,#0x11]         ;439
000524  f8bd25e1          LDRH     r2,[sp,#0x5e1]        ;439
000528  4291              CMP      r1,r2                 ;439
00052a  d1a2              BNE      |L1.1138|
00052c  f89d1013          LDRB     r1,[sp,#0x13]         ;440
000530  f89d25e3          LDRB     r2,[sp,#0x5e3]        ;440
000534  4291              CMP      r1,r2                 ;440
000536  d19c              BNE      |L1.1138|
000538  f10b0107          ADD      r1,r11,#7             ;443
00053c  f8cd1ba8          STR      r1,[sp,#0xba8]        ;444
000540  2100              MOVS     r1,#0                 ;444
000542  e07f              B        |L1.1604|
                  |L1.1348|
000544  f50d60bb          ADD      r0,sp,#0x5d8          ;448
000548  f04f0b01          MOV      r11,#1                ;451
00054c  9000              STR      r0,[sp,#0]            ;451
00054e  f88db5e0          STRB     r11,[sp,#0x5e0]       ;451
000552  f8dd0ba8          LDR      r0,[sp,#0xba8]        ;452
000556  fa1ff48a          UXTH     r4,r10                ;449
00055a  2600              MOVS     r6,#0                 ;450
00055c  4284              CMP      r4,r0                 ;452
00055e  dd06              BLE      |L1.1390|
000560  b284              UXTH     r4,r0                 ;454
000562  2601              MOVS     r6,#1                 ;455
000564  2000              MOVS     r0,#0                 ;456
000566  f88d05e0          STRB     r0,[sp,#0x5e0]        ;456
00056a  e00c              B        |L1.1414|
                  |L1.1388|
00056c  e079              B        |L1.1634|
                  |L1.1390|
00056e  2c07              CMP      r4,#7                 ;458
000570  d209              BCS      |L1.1414|
000572  200a              MOVS     r0,#0xa               ;460
000574  f8ad05d8          STRH     r0,[sp,#0x5d8]        ;460
000578  f1c40107          RSB      r1,r4,#7              ;461
00057c  eb0b0041          ADD      r0,r11,r1,LSL #1      ;461
000580  f88d05e0          STRB     r0,[sp,#0x5e0]        ;461
000584  e002              B        |L1.1420|
                  |L1.1414|
000586  1ce0              ADDS     r0,r4,#3              ;465
000588  f8ad05d8          STRH     r0,[sp,#0x5d8]        ;465
                  |L1.1420|
00058c  2000              MOVS     r0,#0                 ;467
00058e  f8ad05da          STRH     r0,[sp,#0x5da]        ;467
000592  f88d05dc          STRB     r0,[sp,#0x5dc]        ;468
000596  6879              LDR      r1,[r7,#4]            ;470
000598  f8110008          LDRB     r0,[r1,r8]            ;470
00059c  f7fffffe          BL       ec_nextmbxcnt
0005a0  687a              LDR      r2,[r7,#4]            ;471
0005a2  2103              MOVS     r1,#3                 ;472
0005a4  f8020008          STRB     r0,[r2,r8]            ;471
0005a8  eb011000          ADD      r0,r1,r0,LSL #4       ;472
0005ac  f88d05dd          STRB     r0,[sp,#0x5dd]        ;472
0005b0  f44f5000          MOV      r0,#0x2000            ;473
0005b4  f89d15e0          LDRB     r1,[sp,#0x5e0]        ;474
0005b8  f8ad05de          STRH     r0,[sp,#0x5de]        ;473
0005bc  eb010009          ADD      r0,r1,r9              ;474
0005c0  f88d05e0          STRB     r0,[sp,#0x5e0]        ;474
0005c4  e9dd0100          LDRD     r0,r1,[sp,#0]         ;476
0005c8  4622              MOV      r2,r4                 ;476
0005ca  3009              ADDS     r0,r0,#9              ;476
0005cc  f7fffffe          BL       __aeabi_memcpy
0005d0  9801              LDR      r0,[sp,#4]            ;478
0005d2  ebaa0a04          SUB      r10,r10,r4            ;479
0005d6  4420              ADD      r0,r0,r4              ;478
0005d8  9001              STR      r0,[sp,#4]            ;481
0005da  f6446320          MOV      r3,#0x4e20            ;481
0005de  f50d62bb          ADD      r2,sp,#0x5d8          ;481
0005e2  4638              MOV      r0,r7                 ;481
0005e4  f8dd1bb0          LDR      r1,[sp,#0xbb0]        ;481
0005e8  f7fffffe          BL       ecx_mbxsend
0005ec  2800              CMP      r0,#0                 ;482
0005ee  dd27              BLE      |L1.1600|
0005f0  a802              ADD      r0,sp,#8              ;484
0005f2  f7fffffe          BL       ec_clearmbx
0005f6  aa02              ADD      r2,sp,#8              ;486
0005f8  4638              MOV      r0,r7                 ;486
0005fa  f8dd3bec          LDR      r3,[sp,#0xbec]        ;486
0005fe  f8dd1bb0          LDR      r1,[sp,#0xbb0]        ;486
000602  f7fffffe          BL       ecx_mbxreceive
000606  2800              CMP      r0,#0                 ;487
000608  dd1a              BLE      |L1.1600|
00060a  7969              LDRB     r1,[r5,#5]            ;489
00060c  f001010f          AND      r1,r1,#0xf            ;489
000610  2903              CMP      r1,#3                 ;489
000612  d107              BNE      |L1.1572|
000614  88ea              LDRH     r2,[r5,#6]            ;490
000616  ebb13f12          CMP      r1,r2,LSR #12         ;490
00061a  d103              BNE      |L1.1572|
00061c  7a2a              LDRB     r2,[r5,#8]            ;491
00061e  ebbb1f52          CMP      r11,r2,LSR #5         ;491
000622  d00d              BEQ      |L1.1600|
                  |L1.1572|
000624  7a28              LDRB     r0,[r5,#8]            ;497
000626  2880              CMP      r0,#0x80              ;497
000628  d011              BEQ      |L1.1614|
00062a  f50d643b          ADD      r4,sp,#0xbb0          ;503
00062e  f8cdb000          STR      r11,[sp,#0]           ;503
000632  e894000e          LDM      r4,{r1-r3}            ;503
000636  4638              MOV      r0,r7                 ;503
000638  f7fffffe          BL       ecx_packeterror
                  |L1.1596|
00063c  2000              MOVS     r0,#0                 ;505
00063e  4606              MOV      r6,r0                 ;506
                  |L1.1600|
000640  f0890110          EOR      r1,r9,#0x10           ;510
                  |L1.1604|
000644  4689              MOV      r9,r1                 ;444
000646  2e00              CMP      r6,#0                 ;444
000648  f47faf7c          BNE      |L1.1348|
00064c  e64b              B        |L1.742|
                  |L1.1614|
00064e  68e8              LDR      r0,[r5,#0xc]          ;499
000650  9000              STR      r0,[sp,#0]            ;499
000652  f50d643b          ADD      r4,sp,#0xbb0          ;499
000656  4638              MOV      r0,r7                 ;499
000658  e894000e          LDM      r4,{r1-r3}            ;499
00065c  f7fffffe          BL       ecx_SDOerror
000660  e7ec              B        |L1.1596|
                  |L1.1634|
000662  9805              LDR      r0,[sp,#0x14]         ;518
000664  9000              STR      r0,[sp,#0]            ;518
000666  f50d643b          ADD      r4,sp,#0xbb0          ;518
00066a  4638              MOV      r0,r7                 ;518
00066c  e894000e          LDM      r4,{r1-r3}            ;518
000670  f7fffffe          BL       ecx_SDOerror
000674  e70a              B        |L1.1164|
;;;532    
                          ENDP

                  ecx_RxPDO PROC
;;;543     */
;;;544    int ecx_RxPDO(ecx_contextt *context, uint16 Slave, uint16 RxPDOnumber, int psize, void *p)
000676  e92d47f0          PUSH     {r4-r10,lr}
;;;545    {
00067a  f5ad6d3a          SUB      sp,sp,#0xba0
00067e  4605              MOV      r5,r0
000680  461c              MOV      r4,r3
000682  4690              MOV      r8,r2
000684  4689              MOV      r9,r1
;;;546       ec_SDOt *SDOp;
;;;547       int wkc, maxdata;
;;;548       ec_mbxbuft MbxIn, MbxOut;
;;;549       uint8 cnt;
;;;550       uint16 framedatasize;
;;;551    
;;;552       ec_clearmbx(&MbxIn);
000686  f50d60ba          ADD      r0,sp,#0x5d0
00068a  f8ddabc0          LDR      r10,[sp,#0xbc0]
00068e  f7fffffe          BL       ec_clearmbx
;;;553       /* Empty slave out mailbox if something is in. Timout set to 0 */
;;;554       wkc = ecx_mbxreceive(context, Slave, (ec_mbxbuft *)&MbxIn, 0);
000692  2300              MOVS     r3,#0
000694  f50d62ba          ADD      r2,sp,#0x5d0
000698  4649              MOV      r1,r9
00069a  4628              MOV      r0,r5
00069c  f7fffffe          BL       ecx_mbxreceive
;;;555       ec_clearmbx(&MbxOut);
0006a0  4668              MOV      r0,sp
0006a2  f7fffffe          BL       ec_clearmbx
;;;556       SDOp = (ec_SDOt *)&MbxOut;
;;;557       maxdata = context->slavelist[Slave].mbx_l - 0x08; /* data section=mailbox size - 6 mbx - 2 CoE */
0006a6  eb0901c9          ADD      r1,r9,r9,LSL #3
0006aa  686a              LDR      r2,[r5,#4]
0006ac  eb011189          ADD      r1,r1,r9,LSL #6
0006b0  20c0              MOVS     r0,#0xc0
0006b2  eb000081          ADD      r0,r0,r1,LSL #2
0006b6  5a10              LDRH     r0,[r2,r0]
;;;558       framedatasize = psize;
0006b8  b2a4              UXTH     r4,r4
0006ba  3808              SUBS     r0,r0,#8
0006bc  466e              MOV      r6,sp                 ;556
;;;559       if (framedatasize > maxdata)
0006be  4284              CMP      r4,r0
0006c0  dd00              BLE      |L1.1732|
;;;560       {
;;;561          framedatasize = maxdata;  /*  limit transfer */
0006c2  b284              UXTH     r4,r0
                  |L1.1732|
;;;562       }
;;;563       SDOp->MbxHeader.length = htoes(0x02 + framedatasize);
0006c4  1ca0              ADDS     r0,r4,#2
0006c6  f8ad0000          STRH     r0,[sp,#0]
;;;564       SDOp->MbxHeader.address = htoes(0x0000);
0006ca  2000              MOVS     r0,#0
0006cc  f8ad0002          STRH     r0,[sp,#2]
;;;565       SDOp->MbxHeader.priority = 0x00;
0006d0  f88d0004          STRB     r0,[sp,#4]
;;;566       /* get new mailbox counter, used for session handle */
;;;567       cnt = ec_nextmbxcnt(context->slavelist[Slave].mbx_cnt);
0006d4  20ca              MOVS     r0,#0xca
0006d6  686a              LDR      r2,[r5,#4]
0006d8  eb000781          ADD      r7,r0,r1,LSL #2
0006dc  5dd0              LDRB     r0,[r2,r7]
0006de  f7fffffe          BL       ec_nextmbxcnt
;;;568       context->slavelist[Slave].mbx_cnt = cnt;
0006e2  6869              LDR      r1,[r5,#4]
;;;569       SDOp->MbxHeader.mbxtype = ECT_MBXT_COE + (cnt << 4); /* CoE */
;;;570       SDOp->CANOpen = htoes((RxPDOnumber & 0x01ff) + (ECT_COES_RXPDO << 12)); /* number 9bits service upper 4 bits */
;;;571       /* copy PDO data to mailbox */
;;;572       memcpy(&SDOp->Command, p, framedatasize);
0006e4  4622              MOV      r2,r4
0006e6  55c8              STRB     r0,[r1,r7]            ;568
0006e8  2103              MOVS     r1,#3                 ;569
0006ea  eb011000          ADD      r0,r1,r0,LSL #4       ;569
0006ee  f88d0005          STRB     r0,[sp,#5]            ;569
0006f2  f3c80008          UBFX     r0,r8,#0,#9           ;570
0006f6  f50040a0          ADD      r0,r0,#0x5000         ;570
0006fa  f8ad0006          STRH     r0,[sp,#6]            ;570
0006fe  4651              MOV      r1,r10
000700  f1060008          ADD      r0,r6,#8
000704  f7fffffe          BL       __aeabi_memcpy
;;;573       /* send mailbox RxPDO request to slave */
;;;574       wkc = ecx_mbxsend(context, Slave, (ec_mbxbuft *)&MbxOut, EC_TIMEOUTTXM);
000708  f6446320          MOV      r3,#0x4e20
00070c  466a              MOV      r2,sp
00070e  4649              MOV      r1,r9
000710  4628              MOV      r0,r5
000712  f7fffffe          BL       ecx_mbxsend
;;;575    
;;;576       return wkc;
;;;577    }
000716  f50d6d3a          ADD      sp,sp,#0xba0
00071a  e8bd87f0          POP      {r4-r10,pc}
;;;578    
                          ENDP

                  ecx_TxPDO PROC
;;;590     */
;;;591    int ecx_TxPDO(ecx_contextt *context, uint16 slave, uint16 TxPDOnumber , int *psize, void *p, int timeout)
00071e  e92d4ff0          PUSH     {r4-r11,lr}
;;;592    {
000722  f6ad3da4          SUB      sp,sp,#0xba4
000726  4680              MOV      r8,r0
000728  461f              MOV      r7,r3
00072a  4615              MOV      r5,r2
00072c  468a              MOV      r10,r1
;;;593       ec_SDOt *SDOp, *aSDOp;
;;;594       int wkc;
;;;595       ec_mbxbuft MbxIn, MbxOut;
;;;596       uint8 cnt;
;;;597       uint16 framedatasize;
;;;598    
;;;599       ec_clearmbx(&MbxIn);
00072e  a801              ADD      r0,sp,#4
000730  f8ddbbcc          LDR      r11,[sp,#0xbcc]
000734  f7fffffe          BL       ec_clearmbx
;;;600       /* Empty slave out mailbox if something is in. Timout set to 0 */
;;;601       wkc = ecx_mbxreceive(context, slave, (ec_mbxbuft *)&MbxIn, 0);
000738  2300              MOVS     r3,#0
00073a  aa01              ADD      r2,sp,#4
00073c  4651              MOV      r1,r10
00073e  4640              MOV      r0,r8
000740  f7fffffe          BL       ecx_mbxreceive
;;;602       ec_clearmbx(&MbxOut);
000744  f20d50d4          ADD      r0,sp,#0x5d4
000748  f7fffffe          BL       ec_clearmbx
;;;603       aSDOp = (ec_SDOt *)&MbxIn;
;;;604       SDOp = (ec_SDOt *)&MbxOut;
;;;605       SDOp->MbxHeader.length = htoes(0x02);
00074c  2002              MOVS     r0,#2
00074e  f8ad05d4          STRH     r0,[sp,#0x5d4]
;;;606       SDOp->MbxHeader.address = htoes(0x0000);
000752  2000              MOVS     r0,#0
000754  f8ad05d6          STRH     r0,[sp,#0x5d6]
;;;607       SDOp->MbxHeader.priority = 0x00;
000758  f88d05d8          STRB     r0,[sp,#0x5d8]
;;;608       /* get new mailbox counter, used for session handle */
;;;609       cnt = ec_nextmbxcnt(context->slavelist[slave].mbx_cnt);
00075c  eb0a02ca          ADD      r2,r10,r10,LSL #3
000760  eb02128a          ADD      r2,r2,r10,LSL #6
000764  20ca              MOVS     r0,#0xca
000766  f8d81004          LDR      r1,[r8,#4]
00076a  eb000482          ADD      r4,r0,r2,LSL #2
00076e  ae01              ADD      r6,sp,#4              ;603
000770  5d08              LDRB     r0,[r1,r4]
000772  f7fffffe          BL       ec_nextmbxcnt
;;;610       context->slavelist[slave].mbx_cnt = cnt;
000776  f8d81004          LDR      r1,[r8,#4]
;;;611       SDOp->MbxHeader.mbxtype = ECT_MBXT_COE + (cnt << 4); /* CoE */
00077a  f04f0903          MOV      r9,#3
;;;612       SDOp->CANOpen = htoes((TxPDOnumber & 0x01ff) + (ECT_COES_TXPDO_RR << 12)); /* number 9bits service upper 4 bits */
;;;613       wkc = ecx_mbxsend(context, slave, (ec_mbxbuft *)&MbxOut, EC_TIMEOUTTXM);
00077e  f6446320          MOV      r3,#0x4e20
000782  5508              STRB     r0,[r1,r4]            ;610
000784  eb091000          ADD      r0,r9,r0,LSL #4       ;611
000788  f88d05d9          STRB     r0,[sp,#0x5d9]        ;611
00078c  f3c50008          UBFX     r0,r5,#0,#9           ;612
000790  f50040c0          ADD      r0,r0,#0x6000         ;612
000794  f8ad05da          STRH     r0,[sp,#0x5da]        ;612
000798  f20d52d4          ADD      r2,sp,#0x5d4
00079c  4651              MOV      r1,r10
00079e  4640              MOV      r0,r8
0007a0  f7fffffe          BL       ecx_mbxsend
0007a4  1e04              SUBS     r4,r0,#0
;;;614       if (wkc > 0)
0007a6  dd3d              BLE      |L1.2084|
;;;615       {
;;;616          /* clean mailboxbuffer */
;;;617          ec_clearmbx(&MbxIn);
0007a8  a801              ADD      r0,sp,#4
0007aa  f7fffffe          BL       ec_clearmbx
;;;618          /* read slave response */
;;;619          wkc = ecx_mbxreceive(context, slave, (ec_mbxbuft *)&MbxIn, timeout);
0007ae  465b              MOV      r3,r11
0007b0  aa01              ADD      r2,sp,#4
0007b2  4651              MOV      r1,r10
0007b4  4640              MOV      r0,r8
0007b6  f7fffffe          BL       ecx_mbxreceive
0007ba  1e04              SUBS     r4,r0,#0
;;;620          if (wkc > 0) /* succeeded to read slave response ? */
0007bc  dd32              BLE      |L1.2084|
;;;621          {
;;;622             /* slave response should be CoE, TxPDO */
;;;623             if (((aSDOp->MbxHeader.mbxtype & 0x0f) == ECT_MBXT_COE) &&
0007be  f89d0009          LDRB     r0,[sp,#9]
0007c2  f000000f          AND      r0,r0,#0xf
0007c6  2803              CMP      r0,#3
0007c8  d11f              BNE      |L1.2058|
;;;624                 ((etohs(aSDOp->CANOpen) >> 12) == ECT_COES_TXPDO))
0007ca  f8bd000a          LDRH     r0,[sp,#0xa]
0007ce  2104              MOVS     r1,#4
0007d0  ebb13f10          CMP      r1,r0,LSR #12
0007d4  d119              BNE      |L1.2058|
;;;625             {
;;;626                /* TxPDO response */
;;;627                framedatasize = (aSDOp->MbxHeader.length - 2);
0007d6  f8bd0004          LDRH     r0,[sp,#4]
0007da  1e80              SUBS     r0,r0,#2
0007dc  b285              UXTH     r5,r0
;;;628                if (*psize >= framedatasize) /* parameter buffer big enough ? */
0007de  6838              LDR      r0,[r7,#0]
0007e0  42a8              CMP      r0,r5
0007e2  db08              BLT      |L1.2038|
;;;629                {
;;;630                   /* copy parameter in parameter buffer */
;;;631                   memcpy(p, &aSDOp->Command, framedatasize);
0007e4  462a              MOV      r2,r5
0007e6  f1060108          ADD      r1,r6,#8
0007ea  f8dd0bc8          LDR      r0,[sp,#0xbc8]
0007ee  f7fffffe          BL       __aeabi_memcpy
;;;632                   /* return the real parameter size */
;;;633                   *psize = framedatasize;
0007f2  603d              STR      r5,[r7,#0]
0007f4  e016              B        |L1.2084|
                  |L1.2038|
;;;634                }
;;;635                /* parameter buffer too small */
;;;636                else
;;;637                {
;;;638                   wkc = 0;
0007f6  2400              MOVS     r4,#0
;;;639                   ecx_packeterror(context, slave, 0, 0, 3); /*  data container too small for type */
0007f8  4623              MOV      r3,r4
0007fa  4622              MOV      r2,r4
0007fc  4651              MOV      r1,r10
0007fe  4640              MOV      r0,r8
000800  f8cd9000          STR      r9,[sp,#0]
000804  f7fffffe          BL       ecx_packeterror
000808  e00c              B        |L1.2084|
                  |L1.2058|
;;;640                }
;;;641             }   
;;;642             /* other slave response */
;;;643             else
;;;644             {
;;;645                if ((aSDOp->Command) == ECT_SDO_ABORT) /* SDO abort frame received */
00080a  f89d000c          LDRB     r0,[sp,#0xc]
00080e  2880              CMP      r0,#0x80
000810  d00c              BEQ      |L1.2092|
;;;646                {
;;;647                   ecx_SDOerror(context, slave, 0, 0, etohl(aSDOp->ldata[0]));
;;;648                }
;;;649                else
;;;650                {
;;;651                   ecx_packeterror(context, slave, 0, 0, 1); /* Unexpected frame returned */
000812  2001              MOVS     r0,#1
000814  2300              MOVS     r3,#0
000816  9000              STR      r0,[sp,#0]
000818  461a              MOV      r2,r3
00081a  4651              MOV      r1,r10
00081c  4640              MOV      r0,r8
00081e  f7fffffe          BL       ecx_packeterror
                  |L1.2082|
;;;652                }
;;;653                wkc = 0;
000822  2400              MOVS     r4,#0
                  |L1.2084|
;;;654             }
;;;655          }         
;;;656       }
;;;657    
;;;658       return wkc;
000824  4620              MOV      r0,r4
;;;659    }
000826  f60d3da4          ADD      sp,sp,#0xba4
00082a  e55e              B        |L1.746|
                  |L1.2092|
00082c  9804              LDR      r0,[sp,#0x10]         ;647
00082e  2300              MOVS     r3,#0                 ;647
000830  9000              STR      r0,[sp,#0]            ;647
000832  461a              MOV      r2,r3                 ;647
000834  4651              MOV      r1,r10                ;647
000836  4640              MOV      r0,r8                 ;647
000838  f7fffffe          BL       ecx_SDOerror
00083c  e7f1              B        |L1.2082|
;;;660    
                          ENDP

                  ecx_readPDOassign PROC
;;;666     */
;;;667    int ecx_readPDOassign(ecx_contextt *context, uint16 Slave, uint16 PDOassign)
00083e  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;668    {
000842  b08a              SUB      sp,sp,#0x28
;;;669       uint16 idxloop, nidx, subidxloop, rdat, idx, subidx;
;;;670       uint8 subcnt;
;;;671       int wkc, bsize = 0, rdl;
000844  2500              MOVS     r5,#0
;;;672       int32 rdat2;
;;;673    
;;;674       rdl = sizeof(rdat); rdat = 0;
000846  f04f0902          MOV      r9,#2
00084a  f8cd9014          STR      r9,[sp,#0x14]
;;;675       /* read PDO assign subindex 0 ( = number of PDO's) */
;;;676       wkc = ecx_SDOread(context, Slave, PDOassign, 0x00, FALSE, &rdl, &rdat, EC_TIMEOUTRXM);
00084e  f10d0b14          ADD      r11,sp,#0x14
000852  aa01              ADD      r2,sp,#4
000854  f8ad5010          STRH     r5,[sp,#0x10]         ;674
000858  f8dfa478          LDR      r10,|L1.3284|
00085c  ab04              ADD      r3,sp,#0x10
00085e  4658              MOV      r0,r11
000860  9500              STR      r5,[sp,#0]
000862  e8820409          STM      r2,{r0,r3,r10}
000866  ac0a              ADD      r4,sp,#0x28
000868  46a8              MOV      r8,r5                 ;674
00086a  e8940007          LDM      r4,{r0-r2}
00086e  462b              MOV      r3,r5
000870  f7fffffe          BL       ecx_SDOread
000874  1e01              SUBS     r1,r0,#0
;;;677       rdat = etohs(rdat);
000876  f8bd0010          LDRH     r0,[sp,#0x10]
;;;678       /* positive result from slave ? */
;;;679       if ((wkc > 0) && (rdat > 0))
00087a  dd56              BLE      |L1.2346|
00087c  b3f0              CBZ      r0,|L1.2300|
;;;680       {
;;;681          /* number of available sub indexes */
;;;682          nidx = rdat;
;;;683          bsize = 0;
;;;684          /* read all PDO's */
;;;685          for (idxloop = 1; idxloop <= nidx; idxloop++)
00087e  2601              MOVS     r6,#1
000880  9009              STR      r0,[sp,#0x24]
000882  e04f              B        |L1.2340|
                  |L1.2180|
;;;686          {
;;;687             rdl = sizeof(rdat); rdat = 0;
000884  f8cd9014          STR      r9,[sp,#0x14]
;;;688             /* read PDO assign */
;;;689             wkc = ecx_SDOread(context, Slave, PDOassign, (uint8)idxloop, FALSE, &rdl, &rdat, EC_TIMEOUTRXM);
000888  a904              ADD      r1,sp,#0x10
00088a  e9cd8b00          STRD     r8,r11,[sp,#0]
00088e  e9cd1a02          STRD     r1,r10,[sp,#8]
000892  f10d0c28          ADD      r12,sp,#0x28
000896  f8ad8010          STRH     r8,[sp,#0x10]         ;687
00089a  e89c0007          LDM      r12,{r0-r2}
00089e  4654              MOV      r4,r10
0008a0  465f              MOV      r7,r11
0008a2  b2f3              UXTB     r3,r6
0008a4  f7fffffe          BL       ecx_SDOread
;;;690             /* result is index of PDO */
;;;691             idx = etohs(rdat);
0008a8  f8bd0010          LDRH     r0,[sp,#0x10]
;;;692             if (idx > 0)
0008ac  9006              STR      r0,[sp,#0x18]
0008ae  b330              CBZ      r0,|L1.2302|
;;;693             {
;;;694                rdl = sizeof(subcnt); subcnt = 0;
0008b0  2001              MOVS     r0,#1
0008b2  9005              STR      r0,[sp,#0x14]
;;;695                /* read number of subindexes of PDO */
;;;696                wkc = ecx_SDOread(context, Slave,idx, 0x00, FALSE, &rdl, &subcnt, EC_TIMEOUTRXM);
0008b4  e9cd8700          STRD     r8,r7,[sp,#0]
0008b8  f88d801c          STRB     r8,[sp,#0x1c]         ;694
0008bc  ab07              ADD      r3,sp,#0x1c
0008be  e9cd3402          STRD     r3,r4,[sp,#8]
0008c2  e9dd010a          LDRD     r0,r1,[sp,#0x28]
0008c6  46a2              MOV      r10,r4
0008c8  46bb              MOV      r11,r7
0008ca  2300              MOVS     r3,#0
0008cc  9a06              LDR      r2,[sp,#0x18]
0008ce  f7fffffe          BL       ecx_SDOread
;;;697                subidx = subcnt;
0008d2  f89d701c          LDRB     r7,[sp,#0x1c]
;;;698                /* for each subindex */
;;;699                for (subidxloop = 1; subidxloop <= subidx; subidxloop++)
0008d6  2401              MOVS     r4,#1
0008d8  e020              B        |L1.2332|
                  |L1.2266|
;;;700                {
;;;701                   rdl = sizeof(rdat2); rdat2 = 0;
0008da  2004              MOVS     r0,#4
;;;702                   /* read SDO that is mapped in PDO */
;;;703                   wkc = ecx_SDOread(context, Slave, idx, (uint8)subidxloop, FALSE, &rdl, &rdat2, EC_TIMEOUTRXM);
0008dc  9005              STR      r0,[sp,#0x14]
0008de  e9cd8b00          STRD     r8,r11,[sp,#0]
0008e2  ab08              ADD      r3,sp,#0x20
0008e4  f8cd8020          STR      r8,[sp,#0x20]
0008e8  e9cd3a02          STRD     r3,r10,[sp,#8]
0008ec  e9dd010a          LDRD     r0,r1,[sp,#0x28]
0008f0  b2e3              UXTB     r3,r4
0008f2  9a06              LDR      r2,[sp,#0x18]
0008f4  f7fffffe          BL       ecx_SDOread
;;;704                   rdat2 = etohl(rdat2);
;;;705                   /* extract bitlength of SDO */
;;;706                   if (LO_BYTE(rdat2) < 0xff)
0008f8  9808              LDR      r0,[sp,#0x20]
0008fa  e001              B        |L1.2304|
                  |L1.2300|
0008fc  e015              B        |L1.2346|
                  |L1.2302|
0008fe  e00f              B        |L1.2336|
                  |L1.2304|
000900  b2c1              UXTB     r1,r0
000902  29ff              CMP      r1,#0xff
000904  d202              BCS      |L1.2316|
;;;707                   {
;;;708                      bsize += LO_BYTE(rdat2);
000906  fa55f580          UXTAB    r5,r5,r0
00090a  e005              B        |L1.2328|
                  |L1.2316|
;;;709                   }
;;;710                   else
;;;711                   {
;;;712                      rdl = sizeof(rdat); rdat = htoes(0xff);
00090c  20ff              MOVS     r0,#0xff
00090e  f8cd9014          STR      r9,[sp,#0x14]
000912  f8ad0010          STRH     r0,[sp,#0x10]
000916  35ff              ADDS     r5,r5,#0xff
                  |L1.2328|
000918  1c64              ADDS     r4,r4,#1
00091a  b2a4              UXTH     r4,r4                 ;699
                  |L1.2332|
00091c  42bc              CMP      r4,r7                 ;699
00091e  d9dc              BLS      |L1.2266|
                  |L1.2336|
000920  1c76              ADDS     r6,r6,#1              ;699
000922  b2b6              UXTH     r6,r6                 ;685
                  |L1.2340|
000924  9809              LDR      r0,[sp,#0x24]         ;685
000926  4286              CMP      r6,r0                 ;685
000928  d9ac              BLS      |L1.2180|
                  |L1.2346|
;;;713                      /* read Object Entry in Object database */
;;;714    //                  wkc = ec_readOEsingle(idx, (uint8)SubCount, pODlist, pOElist);
;;;715                      bsize += etohs(rdat);                  
;;;716                   }
;;;717                }
;;;718             }
;;;719          }
;;;720       }
;;;721       /* return total found bitlength (PDO) */
;;;722       return bsize;
00092a  4628              MOV      r0,r5
                  |L1.2348|
;;;723    }
00092c  b00d              ADD      sp,sp,#0x34
00092e  e4dc              B        |L1.746|
;;;724    
                          ENDP

                  ecx_readPDOassignCA PROC
;;;730     */
;;;731    int ecx_readPDOassignCA(ecx_contextt *context, uint16 Slave, uint16 PDOassign)
000930  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;732    {
000934  b086              SUB      sp,sp,#0x18
000936  4604              MOV      r4,r0
;;;733       uint16 idxloop, nidx, subidxloop, idx, subidx;
;;;734       int wkc, bsize = 0, rdl;
;;;735    
;;;736       /* find maximum size of PDOassign buffer */
;;;737       rdl = sizeof(ec_PDOassignt); 
000938  f2402002          MOV      r0,#0x202
;;;738       context->PDOassign->n=0;
00093c  9004              STR      r0,[sp,#0x10]
00093e  2600              MOVS     r6,#0                 ;734
000940  6be1              LDR      r1,[r4,#0x3c]
;;;739       /* read rxPDOassign in CA mode, all subindexes are read in one struct */
;;;740       wkc = ecx_SDOread(context, Slave, PDOassign, 0x00, TRUE, &rdl, context->PDOassign, EC_TIMEOUTRXM);
000942  f8dfb390          LDR      r11,|L1.3284|
000946  f04f0901          MOV      r9,#1
00094a  700e              STRB     r6,[r1,#0]            ;738
00094c  6be1              LDR      r1,[r4,#0x3c]
00094e  f10d0810          ADD      r8,sp,#0x10
000952  f8cdb00c          STR      r11,[sp,#0xc]
000956  f8cd9000          STR      r9,[sp,#0]
00095a  e9cd8101          STRD     r8,r1,[sp,#4]
00095e  46b2              MOV      r10,r6                ;738
000960  4633              MOV      r3,r6
000962  4620              MOV      r0,r4
000964  9907              LDR      r1,[sp,#0x1c]
000966  f7fffffe          BL       ecx_SDOread
;;;741       /* positive result from slave ? */
;;;742       if ((wkc > 0) && (context->PDOassign->n > 0))
00096a  2800              CMP      r0,#0
00096c  dd2a              BLE      |L1.2500|
00096e  6be0              LDR      r0,[r4,#0x3c]
000970  7807              LDRB     r7,[r0,#0]
000972  b33f              CBZ      r7,|L1.2500|
;;;743       {
;;;744          nidx = context->PDOassign->n;
;;;745          bsize = 0;
;;;746          /* for each PDO do */
;;;747          for (idxloop = 1; idxloop <= nidx; idxloop++)
000974  2501              MOVS     r5,#1
000976  e023              B        |L1.2496|
                  |L1.2424|
;;;748          {
;;;749             /* get index from PDOassign struct */
;;;750             idx = etohs(context->PDOassign->index[idxloop - 1]);
000978  6be0              LDR      r0,[r4,#0x3c]
00097a  f8302015          LDRH     r2,[r0,r5,LSL #1]
;;;751             if (idx > 0)
00097e  b1ea              CBZ      r2,|L1.2492|
;;;752             {
;;;753                rdl = sizeof(ec_PDOdesct); context->PDOdesc->n = 0;
000980  f2404004          MOV      r0,#0x404
000984  9004              STR      r0,[sp,#0x10]
000986  6c21              LDR      r1,[r4,#0x40]
;;;754                /* read SDO's that are mapped in PDO, CA mode */
;;;755                wkc = ecx_SDOread(context, Slave,idx, 0x00, TRUE, &rdl, context->PDOdesc, EC_TIMEOUTRXM);
000988  2300              MOVS     r3,#0
00098a  4620              MOV      r0,r4
00098c  f881a000          STRB     r10,[r1,#0]           ;753
000990  6c21              LDR      r1,[r4,#0x40]
000992  f8cdb00c          STR      r11,[sp,#0xc]
000996  f8cd9000          STR      r9,[sp,#0]
00099a  e9cd8101          STRD     r8,r1,[sp,#4]
00099e  9907              LDR      r1,[sp,#0x1c]
0009a0  f7fffffe          BL       ecx_SDOread
;;;756                subidx = context->PDOdesc->n;
0009a4  6c21              LDR      r1,[r4,#0x40]
;;;757                /* extract all bitlengths of SDO's */
;;;758                for (subidxloop = 1; subidxloop <= subidx; subidxloop++)
0009a6  2001              MOVS     r0,#1
0009a8  780a              LDRB     r2,[r1,#0]            ;756
0009aa  e005              B        |L1.2488|
                  |L1.2476|
;;;759                {
;;;760                   bsize += LO_BYTE(etohl(context->PDOdesc->PDO[subidxloop -1]));
0009ac  f8513020          LDR      r3,[r1,r0,LSL #2]
0009b0  fa56f683          UXTAB    r6,r6,r3
0009b4  1c40              ADDS     r0,r0,#1
0009b6  b280              UXTH     r0,r0                 ;758
                  |L1.2488|
0009b8  4290              CMP      r0,r2                 ;758
0009ba  d9f7              BLS      |L1.2476|
                  |L1.2492|
0009bc  1c6d              ADDS     r5,r5,#1              ;758
0009be  b2ad              UXTH     r5,r5                 ;747
                  |L1.2496|
0009c0  42bd              CMP      r5,r7                 ;747
0009c2  d9d9              BLS      |L1.2424|
                  |L1.2500|
;;;761                }
;;;762             }
;;;763          }
;;;764       }
;;;765    
;;;766       /* return total found bitlength (PDO) */
;;;767       return bsize;
0009c4  4630              MOV      r0,r6
;;;768    }
0009c6  b009              ADD      sp,sp,#0x24
0009c8  e48f              B        |L1.746|
;;;769    
                          ENDP

                  ecx_readPDOmap PROC
;;;798     */
;;;799    int ecx_readPDOmap(ecx_contextt *context, uint16 Slave, int *Osize, int *Isize)
0009ca  e92d4fff          PUSH     {r0-r11,lr}
;;;800    {
0009ce  4680              MOV      r8,r0
;;;801       int wkc, rdl;
;;;802       int retVal = 0;
0009d0  2000              MOVS     r0,#0
0009d2  b089              SUB      sp,sp,#0x24           ;800
;;;803       uint8 nSM, iSM, tSM;
;;;804       int Tsize;
;;;805       uint8 SMt_bug_add;
;;;806       
;;;807       *Isize = 0;
;;;808       *Osize = 0;
;;;809       SMt_bug_add = 0;
;;;810       rdl = sizeof(nSM); nSM = 0;
0009d4  2101              MOVS     r1,#1
0009d6  9007              STR      r0,[sp,#0x1c]         ;807
0009d8  6018              STR      r0,[r3,#0]            ;808
0009da  6010              STR      r0,[r2,#0]
0009dc  9105              STR      r1,[sp,#0x14]
0009de  461e              MOV      r6,r3                 ;800
0009e0  4617              MOV      r7,r2                 ;800
;;;811       /* read SyncManager Communication Type object count */
;;;812       wkc = ecx_SDOread(context, Slave, ECT_SDO_SMCOMMTYPE, 0x00, FALSE, &rdl, &nSM, EC_TIMEOUTRXM);
0009e2  49bc              LDR      r1,|L1.3284|
0009e4  f88d0018          STRB     r0,[sp,#0x18]         ;810
0009e8  ab06              ADD      r3,sp,#0x18
0009ea  aa05              ADD      r2,sp,#0x14
0009ec  9103              STR      r1,[sp,#0xc]
0009ee  e88d000d          STM      sp,{r0,r2,r3}
0009f2  4683              MOV      r11,r0                ;807
0009f4  4681              MOV      r9,r0                 ;809
0009f6  4603              MOV      r3,r0
0009f8  f44f52e0          MOV      r2,#0x1c00
0009fc  4640              MOV      r0,r8
0009fe  990a              LDR      r1,[sp,#0x28]
000a00  f7fffffe          BL       ecx_SDOread
;;;813       /* positive result from slave ? */
;;;814       if ((wkc > 0) && (nSM > 2))
000a04  2800              CMP      r0,#0
000a06  dd7d              BLE      |L1.2820|
000a08  f89d0018          LDRB     r0,[sp,#0x18]
000a0c  2802              CMP      r0,#2
000a0e  d979              BLS      |L1.2820|
;;;815       {
;;;816          /* limit to maximum number of SM defined, if true the slave can't be configured */
;;;817          if (nSM > EC_MAXSM)
000a10  2808              CMP      r0,#8
000a12  d902              BLS      |L1.2586|
;;;818             nSM = EC_MAXSM;
000a14  2008              MOVS     r0,#8
000a16  f88d0018          STRB     r0,[sp,#0x18]
                  |L1.2586|
;;;819          /* iterate for every SM type defined */
;;;820          for (iSM = 2 ; iSM < nSM ; iSM++)
;;;821          {
;;;822             rdl = sizeof(tSM); tSM = 0;
;;;823             /* read SyncManager Communication Type */
;;;824             wkc = ecx_SDOread(context, Slave, ECT_SDO_SMCOMMTYPE, iSM + 1, FALSE, &rdl, &tSM, EC_TIMEOUTRXM);
;;;825             if (wkc > 0)
;;;826             {
;;;827    // start slave bug prevention code, remove if possible            
;;;828                if((iSM == 2) && (tSM == 2)) // SM2 has type 2 == mailbox out, this is a bug in the slave!
;;;829                {   
;;;830                   SMt_bug_add = 1; // try to correct, this works if the types are 0 1 2 3 and should be 1 2 3 4
;;;831                }
;;;832                if(tSM)
;;;833                {   
;;;834                   tSM += SMt_bug_add; // only add if SMt > 0
;;;835                }
;;;836                if((iSM == 2) && (tSM == 0)) // SM2 has type 0, this is a bug in the slave!
;;;837                {   
;;;838                   tSM = 3;
;;;839                }
;;;840                if((iSM == 3) && (tSM == 0)) // SM3 has type 0, this is a bug in the slave!
;;;841                {   
;;;842                   tSM = 4;
;;;843                }
;;;844    // end slave bug prevention code            
;;;845    
;;;846                context->slavelist[Slave].SMtype[iSM] = tSM;
000a1a  980a              LDR      r0,[sp,#0x28]
000a1c  2402              MOVS     r4,#2                 ;820
000a1e  eb0001c0          ADD      r1,r0,r0,LSL #3
000a22  eb011580          ADD      r5,r1,r0,LSL #6
000a26  e073              B        |L1.2832|
                  |L1.2600|
000a28  2001              MOVS     r0,#1                 ;822
000a2a  9005              STR      r0,[sp,#0x14]         ;822
000a2c  4658              MOV      r0,r11                ;822
000a2e  f88db010          STRB     r11,[sp,#0x10]        ;822
000a32  4ba8              LDR      r3,|L1.3284|
000a34  aa04              ADD      r2,sp,#0x10           ;824
000a36  a905              ADD      r1,sp,#0x14           ;824
000a38  e88d000f          STM      sp,{r0-r3}            ;824
000a3c  f1040a01          ADD      r10,r4,#1             ;824
000a40  f00a03ff          AND      r3,r10,#0xff          ;824
000a44  f44f52e0          MOV      r2,#0x1c00            ;824
000a48  4640              MOV      r0,r8                 ;824
000a4a  990a              LDR      r1,[sp,#0x28]         ;824
000a4c  f7fffffe          BL       ecx_SDOread
000a50  2800              CMP      r0,#0                 ;825
000a52  dd5b              BLE      |L1.2828|
000a54  2c02              CMP      r4,#2                 ;828
000a56  d103              BNE      |L1.2656|
000a58  f89d0010          LDRB     r0,[sp,#0x10]         ;828
000a5c  2802              CMP      r0,#2                 ;828
000a5e  d00d              BEQ      |L1.2684|
                  |L1.2656|
000a60  f89d0010          LDRB     r0,[sp,#0x10]         ;832
000a64  b128              CBZ      r0,|L1.2674|
                  |L1.2662|
000a66  f89d1010          LDRB     r1,[sp,#0x10]         ;834
000a6a  eb010009          ADD      r0,r1,r9              ;834
000a6e  f88d0010          STRB     r0,[sp,#0x10]         ;834
                  |L1.2674|
000a72  2c02              CMP      r4,#2                 ;836
000a74  d005              BEQ      |L1.2690|
000a76  2c03              CMP      r4,#3                 ;840
000a78  d008              BEQ      |L1.2700|
000a7a  e00d              B        |L1.2712|
                  |L1.2684|
000a7c  f04f0901          MOV      r9,#1                 ;830
000a80  e7f1              B        |L1.2662|
                  |L1.2690|
000a82  f01000ff          ANDS     r0,r0,#0xff           ;836
000a86  d107              BNE      |L1.2712|
000a88  2003              MOVS     r0,#3                 ;838
000a8a  e003              B        |L1.2708|
                  |L1.2700|
000a8c  f01000ff          ANDS     r0,r0,#0xff           ;840
000a90  d102              BNE      |L1.2712|
000a92  2004              MOVS     r0,#4                 ;842
                  |L1.2708|
000a94  f88d0010          STRB     r0,[sp,#0x10]         ;838
                  |L1.2712|
000a98  b2c1              UXTB     r1,r0
000a9a  f8d80004          LDR      r0,[r8,#4]
000a9e  eb000285          ADD      r2,r0,r5,LSL #2
000aa2  f1040074          ADD      r0,r4,#0x74
000aa6  5411              STRB     r1,[r2,r0]
;;;847                /* check if SM is unused -> clear enable flag */
;;;848                if (tSM == 0)
000aa8  f89d0010          LDRB     r0,[sp,#0x10]
000aac  b950              CBNZ     r0,|L1.2756|
;;;849                {
;;;850                   context->slavelist[Slave].SM[iSM].SMflags = 
000aae  f8d80004          LDR      r0,[r8,#4]
000ab2  2138              MOVS     r1,#0x38
000ab4  eb000085          ADD      r0,r0,r5,LSL #2
000ab8  eb0101c4          ADD      r1,r1,r4,LSL #3
000abc  5842              LDR      r2,[r0,r1]
000abe  f4223280          BIC      r2,r2,#0x10000
000ac2  5042              STR      r2,[r0,r1]
                  |L1.2756|
;;;851                      htoel( etohl(context->slavelist[Slave].SM[iSM].SMflags) & EC_SMENABLEMASK);
;;;852                }
;;;853                if ((tSM == 3) || (tSM == 4))
000ac4  f89d0010          LDRB     r0,[sp,#0x10]
000ac8  2803              CMP      r0,#3
000aca  d001              BEQ      |L1.2768|
000acc  2804              CMP      r0,#4
000ace  d11d              BNE      |L1.2828|
                  |L1.2768|
;;;854                {
;;;855                   /* read the assign PDO */
;;;856                   Tsize = ecx_readPDOassign(context, Slave, ECT_SDO_PDOASSIGN + iSM );
000ad0  f6414010          MOV      r0,#0x1c10
000ad4  1822              ADDS     r2,r4,r0
000ad6  4640              MOV      r0,r8
000ad8  990a              LDR      r1,[sp,#0x28]
000ada  f7fffffe          BL       ecx_readPDOassign
;;;857                   /* if a mapping is found */
;;;858                   if (Tsize)
000ade  b1a8              CBZ      r0,|L1.2828|
;;;859                   {
;;;860                      context->slavelist[Slave].SM[iSM].SMlength = htoes((Tsize + 7) / 8);
000ae0  1dc1              ADDS     r1,r0,#7
000ae2  17ca              ASRS     r2,r1,#31
000ae4  eb017152          ADD      r1,r1,r2,LSR #29
000ae8  08ca              LSRS     r2,r1,#3
000aea  f8d81004          LDR      r1,[r8,#4]
000aee  2336              MOVS     r3,#0x36
000af0  eb010185          ADD      r1,r1,r5,LSL #2
000af4  eb0303c4          ADD      r3,r3,r4,LSL #3
000af8  52ca              STRH     r2,[r1,r3]
;;;861                      if (tSM == 3)
000afa  f89d1010          LDRB     r1,[sp,#0x10]
000afe  2903              CMP      r1,#3
000b00  d012              BEQ      |L1.2856|
;;;862                      {  
;;;863                         /* we are doing outputs */
;;;864                         *Osize += Tsize;
;;;865                      }
;;;866                      else
;;;867                      {
;;;868                         /* we are doing inputs */
;;;869                         *Isize += Tsize;
000b02  e000              B        |L1.2822|
                  |L1.2820|
000b04  e008              B        |L1.2840|
                  |L1.2822|
000b06  6831              LDR      r1,[r6,#0]
000b08  4408              ADD      r0,r0,r1
000b0a  6030              STR      r0,[r6,#0]
                  |L1.2828|
000b0c  f00a04ff          AND      r4,r10,#0xff          ;820
                  |L1.2832|
000b10  f89d0018          LDRB     r0,[sp,#0x18]         ;820
000b14  4284              CMP      r4,r0                 ;820
000b16  d387              BCC      |L1.2600|
                  |L1.2840|
;;;870                      }   
;;;871                   }   
;;;872                }   
;;;873             }   
;;;874          }
;;;875       }
;;;876    
;;;877       /* found some I/O bits ? */
;;;878       if ((*Isize > 0) || (*Osize > 0))
000b18  6830              LDR      r0,[r6,#0]
000b1a  2800              CMP      r0,#0
000b1c  dc08              BGT      |L1.2864|
000b1e  6838              LDR      r0,[r7,#0]
000b20  2800              CMP      r0,#0
000b22  dc05              BGT      |L1.2864|
;;;879       {
;;;880          retVal = 1;
000b24  9807              LDR      r0,[sp,#0x1c]
;;;881       }
;;;882          
;;;883       return retVal;
;;;884    }
000b26  e701              B        |L1.2348|
                  |L1.2856|
000b28  6839              LDR      r1,[r7,#0]            ;864
000b2a  4408              ADD      r0,r0,r1              ;864
000b2c  6038              STR      r0,[r7,#0]            ;864
000b2e  e7ed              B        |L1.2828|
                  |L1.2864|
000b30  2001              MOVS     r0,#1                 ;880
000b32  9007              STR      r0,[sp,#0x1c]         ;880
000b34  e6fa              B        |L1.2348|
;;;885    
                          ENDP

                  ecx_readPDOmapCA PROC
;;;897     */
;;;898    int ecx_readPDOmapCA(ecx_contextt *context, uint16 Slave, int *Osize, int *Isize)
000b36  e92d4fff          PUSH     {r0-r11,lr}
;;;899    {
000b3a  b087              SUB      sp,sp,#0x1c
000b3c  4606              MOV      r6,r0
;;;900       int wkc, rdl;
;;;901       int retVal = 0;
000b3e  2000              MOVS     r0,#0
;;;902       uint8 nSM, iSM, tSM;
;;;903       int Tsize;
;;;904       uint8 SMt_bug_add;
;;;905       
;;;906       *Isize = 0;
000b40  9004              STR      r0,[sp,#0x10]
;;;907       *Osize = 0;
000b42  6018              STR      r0,[r3,#0]
;;;908       SMt_bug_add = 0;
;;;909       rdl = sizeof(ec_SMcommtypet); 
000b44  240a              MOVS     r4,#0xa
000b46  6010              STR      r0,[r2,#0]
;;;910       context->SMcommtype->n = 0;
000b48  9405              STR      r4,[sp,#0x14]
000b4a  6bb1              LDR      r1,[r6,#0x38]
000b4c  4698              MOV      r8,r3                 ;899
000b4e  4691              MOV      r9,r2                 ;899
000b50  7008              STRB     r0,[r1,#0]
000b52  4683              MOV      r11,r0                ;908
;;;911       /* read SyncManager Communication Type object count Complete Access*/
;;;912       wkc = ecx_SDOread(context, Slave, ECT_SDO_SMCOMMTYPE, 0x00, TRUE, &rdl, context->SMcommtype, EC_TIMEOUTRXM);
000b54  4b5f              LDR      r3,|L1.3284|
000b56  a905              ADD      r1,sp,#0x14
000b58  2001              MOVS     r0,#1
000b5a  6bb2              LDR      r2,[r6,#0x38]
000b5c  e88d000f          STM      sp,{r0-r3}
000b60  2300              MOVS     r3,#0
000b62  f44f52e0          MOV      r2,#0x1c00
000b66  4630              MOV      r0,r6
000b68  9908              LDR      r1,[sp,#0x20]
000b6a  f7fffffe          BL       ecx_SDOread
;;;913       /* positive result from slave ? */
;;;914       if ((wkc > 0) && (context->SMcommtype->n > 2))
000b6e  2800              CMP      r0,#0
000b70  dd5c              BLE      |L1.3116|
000b72  6bb0              LDR      r0,[r6,#0x38]
000b74  7800              LDRB     r0,[r0,#0]
000b76  2802              CMP      r0,#2
000b78  d958              BLS      |L1.3116|
000b7a  1e40              SUBS     r0,r0,#1
;;;915       {
;;;916          /* make nSM equal to number of defined SM */
;;;917          nSM = context->SMcommtype->n - 1;
000b7c  f0000aff          AND      r10,r0,#0xff
;;;918          /* limit to maximum number of SM defined, if true the slave can't be configured */
;;;919          if (nSM > EC_MAXSM)
000b80  f1ba0f08          CMP      r10,#8
000b84  d908              BLS      |L1.2968|
;;;920          {
;;;921             nSM = EC_MAXSM;
;;;922             ecx_packeterror(context, Slave, 0, 0, 10); /* #SM larger than EC_MAXSM */         
000b86  2300              MOVS     r3,#0
000b88  f04f0a08          MOV      r10,#8                ;921
000b8c  461a              MOV      r2,r3
000b8e  9400              STR      r4,[sp,#0]
000b90  4630              MOV      r0,r6
000b92  9908              LDR      r1,[sp,#0x20]
000b94  f7fffffe          BL       ecx_packeterror
                  |L1.2968|
;;;923          }
;;;924          /* iterate for every SM type defined */
;;;925          for (iSM = 2 ; iSM <= nSM ; iSM++)
;;;926          {
;;;927             tSM = context->SMcommtype->SMtype[iSM];
;;;928    
;;;929    // start slave bug prevention code, remove if possible            
;;;930             if((iSM == 2) && (tSM == 2)) // SM2 has type 2 == mailbox out, this is a bug in the slave!
;;;931             {
;;;932                SMt_bug_add = 1; // try to correct, this works if the types are 0 1 2 3 and should be 1 2 3 4
;;;933             }
;;;934             if(tSM)
;;;935             {
;;;936                tSM += SMt_bug_add; // only add if SMt > 0
;;;937             }
;;;938    // end slave bug prevention code
;;;939             
;;;940             context->slavelist[Slave].SMtype[iSM] = tSM;
000b98  9808              LDR      r0,[sp,#0x20]
000b9a  2502              MOVS     r5,#2                 ;925
000b9c  eb0001c0          ADD      r1,r0,r0,LSL #3
000ba0  eb011780          ADD      r7,r1,r0,LSL #6
000ba4  e040              B        |L1.3112|
                  |L1.2982|
000ba6  6bb1              LDR      r1,[r6,#0x38]         ;927
000ba8  1ca8              ADDS     r0,r5,#2              ;927
000baa  2d02              CMP      r5,#2                 ;930
000bac  5c0c              LDRB     r4,[r1,r0]            ;927
000bae  d101              BNE      |L1.2996|
000bb0  2c02              CMP      r4,#2                 ;930
000bb2  d00f              BEQ      |L1.3028|
                  |L1.2996|
000bb4  b114              CBZ      r4,|L1.3004|
                  |L1.2998|
000bb6  eb04000b          ADD      r0,r4,r11             ;936
000bba  b2c4              UXTB     r4,r0                 ;936
                  |L1.3004|
000bbc  6870              LDR      r0,[r6,#4]
000bbe  eb000187          ADD      r1,r0,r7,LSL #2
000bc2  f1050074          ADD      r0,r5,#0x74
000bc6  540c              STRB     r4,[r1,r0]
;;;941             /* check if SM is unused -> clear enable flag */
;;;942             if (tSM == 0)
000bc8  b13c              CBZ      r4,|L1.3034|
;;;943             {
;;;944                context->slavelist[Slave].SM[iSM].SMflags =
;;;945                   htoel( etohl(context->slavelist[Slave].SM[iSM].SMflags) & EC_SMENABLEMASK);
;;;946             }
;;;947             if ((tSM == 3) || (tSM == 4))
000bca  2c03              CMP      r4,#3
000bcc  d010              BEQ      |L1.3056|
000bce  2c04              CMP      r4,#4
000bd0  d00e              BEQ      |L1.3056|
000bd2  e027              B        |L1.3108|
                  |L1.3028|
000bd4  f04f0b01          MOV      r11,#1                ;932
000bd8  e7ed              B        |L1.2998|
                  |L1.3034|
000bda  6870              LDR      r0,[r6,#4]            ;944
000bdc  2138              MOVS     r1,#0x38              ;944
000bde  eb000087          ADD      r0,r0,r7,LSL #2       ;944
000be2  eb0101c5          ADD      r1,r1,r5,LSL #3       ;944
000be6  5842              LDR      r2,[r0,r1]            ;944
000be8  f4223280          BIC      r2,r2,#0x10000        ;944
000bec  5042              STR      r2,[r0,r1]            ;944
000bee  e019              B        |L1.3108|
                  |L1.3056|
;;;948             {
;;;949                /* read the assign PDO */
;;;950                Tsize = ecx_readPDOassignCA(context, Slave, ECT_SDO_PDOASSIGN + iSM );
000bf0  f6414010          MOV      r0,#0x1c10
000bf4  182a              ADDS     r2,r5,r0
000bf6  4630              MOV      r0,r6
000bf8  9908              LDR      r1,[sp,#0x20]
000bfa  f7fffffe          BL       ecx_readPDOassignCA
;;;951                /* if a mapping is found */
;;;952                if (Tsize)
000bfe  b188              CBZ      r0,|L1.3108|
;;;953                {
;;;954    							 context->slavelist[Slave].SM[2].SMlength = 0x0c;
000c00  6872              LDR      r2,[r6,#4]
000c02  2346              MOVS     r3,#0x46
000c04  210c              MOVS     r1,#0xc
000c06  eb030387          ADD      r3,r3,r7,LSL #2
000c0a  52d1              STRH     r1,[r2,r3]
;;;955    							 context->slavelist[Slave].SM[3].SMlength = 0x0c;
000c0c  234e              MOVS     r3,#0x4e
000c0e  6872              LDR      r2,[r6,#4]
000c10  eb030387          ADD      r3,r3,r7,LSL #2
;;;956     //              context->slavelist[Slave].SM[iSM].SMlength = htoes((Tsize + 7) / 8);
;;;957                   if (tSM == 3)
000c14  2c03              CMP      r4,#3
000c16  52d1              STRH     r1,[r2,r3]            ;955
000c18  d014              BEQ      |L1.3140|
;;;958                   {
;;;959                      /* we are doing outputs */
;;;960                      *Osize += Tsize;
;;;961                   }
;;;962                   else
;;;963                   {
;;;964                      /* we are doing inputs */
;;;965                      *Isize += Tsize;
000c1a  f8d81000          LDR      r1,[r8,#0]
000c1e  4401              ADD      r1,r1,r0
000c20  f8c81000          STR      r1,[r8,#0]
                  |L1.3108|
000c24  1c6d              ADDS     r5,r5,#1
000c26  b2ed              UXTB     r5,r5                 ;925
                  |L1.3112|
000c28  4555              CMP      r5,r10                ;925
000c2a  d9bc              BLS      |L1.2982|
                  |L1.3116|
;;;966                   }
;;;967                }   
;;;968             }   
;;;969          }
;;;970       }
;;;971    
;;;972       /* found some I/O bits ? */
;;;973       if ((*Isize > 0) || (*Osize > 0))
000c2c  f8d80000          LDR      r0,[r8,#0]
000c30  2800              CMP      r0,#0
000c32  dc0d              BGT      |L1.3152|
000c34  f8d90000          LDR      r0,[r9,#0]
000c38  2800              CMP      r0,#0
000c3a  dc09              BGT      |L1.3152|
;;;974       {
;;;975          retVal = 1;
000c3c  9804              LDR      r0,[sp,#0x10]
                  |L1.3134|
;;;976       }
;;;977       return retVal;
;;;978    }
000c3e  b00b              ADD      sp,sp,#0x2c
000c40  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.3140|
000c44  f8d91000          LDR      r1,[r9,#0]            ;960
000c48  4401              ADD      r1,r1,r0              ;960
000c4a  f8c91000          STR      r1,[r9,#0]            ;960
000c4e  e7e9              B        |L1.3108|
                  |L1.3152|
000c50  2001              MOVS     r0,#1                 ;975
000c52  9004              STR      r0,[sp,#0x10]         ;975
000c54  e7f3              B        |L1.3134|
;;;979    
                          ENDP

                  ec_SDOread PROC
;;;980    #ifdef EC_VER1
;;;981    int ec_SDOread(uint16 slave, uint16 index, uint8 subindex,
000c56  b57f              PUSH     {r0-r6,lr}
;;;982                   boolean CA, int *psize, void *p, int timeout)
;;;983    {
000c58  f10d0c20          ADD      r12,sp,#0x20
000c5c  461c              MOV      r4,r3
000c5e  4615              MOV      r5,r2
000c60  460e              MOV      r6,r1
000c62  e89c000e          LDM      r12,{r1-r3}
;;;984       return ecx_SDOread(&ecx_context, slave, index, subindex, CA, psize, p, timeout);
000c66  f10d0c04          ADD      r12,sp,#4
000c6a  9400              STR      r4,[sp,#0]
000c6c  e88c000e          STM      r12,{r1-r3}
000c70  4601              MOV      r1,r0
000c72  462b              MOV      r3,r5
000c74  4632              MOV      r2,r6
000c76  4818              LDR      r0,|L1.3288|
000c78  f7fffffe          BL       ecx_SDOread
                  |L1.3196|
;;;985    }
000c7c  b004              ADD      sp,sp,#0x10
000c7e  bd70              POP      {r4-r6,pc}
;;;986    
                          ENDP

                  ec_SDOwrite PROC
;;;987    int ec_SDOwrite(uint16 Slave, uint16 Index, uint8 SubIndex,
000c80  b57f              PUSH     {r0-r6,lr}
;;;988                    boolean CA, int psize, void *p, int Timeout)
;;;989    {
000c82  f10d0c20          ADD      r12,sp,#0x20
000c86  461c              MOV      r4,r3
000c88  4615              MOV      r5,r2
000c8a  460e              MOV      r6,r1
000c8c  e89c000e          LDM      r12,{r1-r3}
;;;990       return ecx_SDOwrite(&ecx_context, Slave, Index, SubIndex, CA, psize, p, Timeout);
000c90  f10d0c04          ADD      r12,sp,#4
000c94  9400              STR      r4,[sp,#0]
000c96  e88c000e          STM      r12,{r1-r3}
000c9a  4601              MOV      r1,r0
000c9c  462b              MOV      r3,r5
000c9e  4632              MOV      r2,r6
000ca0  480d              LDR      r0,|L1.3288|
000ca2  f7fffffe          BL       ecx_SDOwrite
;;;991    }
000ca6  e7e9              B        |L1.3196|
;;;992    
                          ENDP

                  ec_RxPDO PROC
;;;993    int ec_RxPDO(uint16 Slave, uint16 RxPDOnumber, int psize, void *p)
000ca8  b508              PUSH     {r3,lr}
;;;994    {
;;;995       return ecx_RxPDO(&ecx_context, Slave, RxPDOnumber, psize, p);
000caa  9300              STR      r3,[sp,#0]
000cac  4613              MOV      r3,r2
000cae  460a              MOV      r2,r1
000cb0  4601              MOV      r1,r0
000cb2  4809              LDR      r0,|L1.3288|
000cb4  f7fffffe          BL       ecx_RxPDO
;;;996    }
000cb8  bd08              POP      {r3,pc}
;;;997    
                          ENDP

                  ec_TxPDO PROC
;;;998    int ec_TxPDO(uint16 slave, uint16 TxPDOnumber , int *psize, void *p, int timeout)
000cba  b51c              PUSH     {r2-r4,lr}
;;;999    {
000cbc  460c              MOV      r4,r1
000cbe  9904              LDR      r1,[sp,#0x10]
000cc0  e9cd3100          STRD     r3,r1,[sp,#0]
;;;1000      return ecx_TxPDO(&ecx_context, slave, TxPDOnumber, psize, p, timeout);
000cc4  4613              MOV      r3,r2
000cc6  4601              MOV      r1,r0
000cc8  4622              MOV      r2,r4
000cca  4803              LDR      r0,|L1.3288|
000ccc  f7fffffe          BL       ecx_TxPDO
;;;1001   }
000cd0  bd1c              POP      {r2-r4,pc}
;;;1002   #endif
                          ENDP

000cd2  0000              DCW      0x0000
                  |L1.3284|
                          DCD      0x000aae60
                  |L1.3288|
                          DCD      ecx_context
