; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\stm32f4xx_rtc.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4xx_rtc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\FWLIB\STM32F4xx_StdPeriph_Driver\inc -I..\USER -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\ETHERNET -I..\HARDWARE\TIMER -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\RTC -I..\HARDWARE\ADC -I..\HARDWARE\SRAM -I..\HARDWARE\InterTemperate -I..\FWLIB\STM32F4x7_ETH_Driver\inc -I..\MALLOC -I..\USMART -I..\HARDWARE -I..\ETHERCAT -I.\RTE\_LWIP -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS --omf_browse=..\obj\stm32f4xx_rtc.crf ..\FWLIB\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rtc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;618      */
;;;619    ErrorStatus RTC_WaitForSynchro(void)
000000  b518              PUSH     {r3,r4,lr}
;;;620    {
;;;621      __IO uint32_t synchrocounter = 0;
000002  2000              MOVS     r0,#0
;;;622      ErrorStatus status = ERROR;
;;;623      uint32_t synchrostatus = 0x00;
;;;624    
;;;625      /* Disable the write protection for RTC registers */
;;;626      RTC->WPR = 0xCA;
000004  4bfa              LDR      r3,|L1.1008|
000006  9000              STR      r0,[sp,#0]
000008  20ca              MOVS     r0,#0xca
00000a  6018              STR      r0,[r3,#0]
;;;627      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6018              STR      r0,[r3,#0]
;;;628        
;;;629      /* Clear RSF flag */
;;;630      RTC->ISR &= (uint32_t)RTC_RSF_MASK;
000010  49f7              LDR      r1,|L1.1008|
000012  3918              SUBS     r1,r1,#0x18
000014  6808              LDR      r0,[r1,#0]
000016  f02000a0          BIC      r0,r0,#0xa0
00001a  6008              STR      r0,[r1,#0]
;;;631        
;;;632      /* Wait the registers to be synchronised */
;;;633      do
;;;634      {
;;;635        synchrostatus = RTC->ISR & RTC_ISR_RSF;
;;;636        synchrocounter++;  
;;;637      } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
00001c  f44f3400          MOV      r4,#0x20000
                  |L1.32|
000020  6808              LDR      r0,[r1,#0]            ;635
000022  9a00              LDR      r2,[sp,#0]            ;636
000024  f0000020          AND      r0,r0,#0x20           ;635
000028  1c52              ADDS     r2,r2,#1              ;636
00002a  9200              STR      r2,[sp,#0]
00002c  42a2              CMP      r2,r4
00002e  d001              BEQ      |L1.52|
000030  2800              CMP      r0,#0
000032  d0f5              BEQ      |L1.32|
                  |L1.52|
;;;638        
;;;639      if ((RTC->ISR & RTC_ISR_RSF) != RESET)
000034  6808              LDR      r0,[r1,#0]
000036  0680              LSLS     r0,r0,#26
000038  d501              BPL      |L1.62|
;;;640      {
;;;641        status = SUCCESS;
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L1.64|
                  |L1.62|
;;;642      }
;;;643      else
;;;644      {
;;;645        status = ERROR;
00003e  2000              MOVS     r0,#0
                  |L1.64|
;;;646      }        
;;;647    
;;;648      /* Enable the write protection for RTC registers */
;;;649      RTC->WPR = 0xFF; 
000040  21ff              MOVS     r1,#0xff
000042  6019              STR      r1,[r3,#0]
;;;650        
;;;651      return (status); 
;;;652    }
000044  bd18              POP      {r3,r4,pc}
;;;653    
                          ENDP

                  RTC_EnterInitMode PROC
;;;551      */
;;;552    ErrorStatus RTC_EnterInitMode(void)
000046  b508              PUSH     {r3,lr}
;;;553    {
;;;554      __IO uint32_t initcounter = 0x00;
;;;555      ErrorStatus status = ERROR;
;;;556      uint32_t initstatus = 0x00;
;;;557         
;;;558      /* Check if the Initialization mode is set */
;;;559      if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
000048  49e9              LDR      r1,|L1.1008|
00004a  2000              MOVS     r0,#0                 ;554
00004c  3918              SUBS     r1,r1,#0x18
00004e  9000              STR      r0,[sp,#0]
000050  6808              LDR      r0,[r1,#0]
000052  0640              LSLS     r0,r0,#25
000054  d412              BMI      |L1.124|
;;;560      {
;;;561        /* Set the Initialization mode */
;;;562        RTC->ISR = (uint32_t)RTC_INIT_MASK;
000056  f04f30ff          MOV      r0,#0xffffffff
00005a  6008              STR      r0,[r1,#0]
;;;563        
;;;564        /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;565        do
;;;566        {
;;;567          initstatus = RTC->ISR & RTC_ISR_INITF;
;;;568          initcounter++;  
;;;569        } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
00005c  138b              ASRS     r3,r1,#14
                  |L1.94|
00005e  6808              LDR      r0,[r1,#0]            ;567
000060  9a00              LDR      r2,[sp,#0]            ;568
000062  f0000040          AND      r0,r0,#0x40           ;567
000066  1c52              ADDS     r2,r2,#1              ;568
000068  9200              STR      r2,[sp,#0]
00006a  429a              CMP      r2,r3
00006c  d001              BEQ      |L1.114|
00006e  2800              CMP      r0,#0
000070  d0f5              BEQ      |L1.94|
                  |L1.114|
;;;570        
;;;571        if ((RTC->ISR & RTC_ISR_INITF) != RESET)
000072  6808              LDR      r0,[r1,#0]
000074  0640              LSLS     r0,r0,#25
000076  d401              BMI      |L1.124|
;;;572        {
;;;573          status = SUCCESS;
;;;574        }
;;;575        else
;;;576        {
;;;577          status = ERROR;
000078  2000              MOVS     r0,#0
;;;578        }        
;;;579      }
;;;580      else
;;;581      {
;;;582        status = SUCCESS;  
;;;583      } 
;;;584        
;;;585      return (status);  
;;;586    }
00007a  bd08              POP      {r3,pc}
                  |L1.124|
00007c  2001              MOVS     r0,#1                 ;582
00007e  bd08              POP      {r3,pc}
;;;587    
                          ENDP

                  RTC_DeInit PROC
;;;374      */
;;;375    ErrorStatus RTC_DeInit(void)
000080  b578              PUSH     {r3-r6,lr}
;;;376    {
;;;377      __IO uint32_t wutcounter = 0x00;
000082  2400              MOVS     r4,#0
;;;378      uint32_t wutwfstatus = 0x00;
;;;379      ErrorStatus status = ERROR;
;;;380      
;;;381      /* Disable the write protection for RTC registers */
;;;382      RTC->WPR = 0xCA;
000084  4eda              LDR      r6,|L1.1008|
000086  20ca              MOVS     r0,#0xca
000088  9400              STR      r4,[sp,#0]
00008a  4625              MOV      r5,r4                 ;379
00008c  6030              STR      r0,[r6,#0]
;;;383      RTC->WPR = 0x53;
00008e  2053              MOVS     r0,#0x53
000090  6030              STR      r0,[r6,#0]
;;;384    
;;;385      /* Set Initialization mode */
;;;386      if (RTC_EnterInitMode() == ERROR)
000092  f7fffffe          BL       RTC_EnterInitMode
000096  b3e0              CBZ      r0,|L1.274|
;;;387      {
;;;388        status = ERROR;
;;;389      }  
;;;390      else
;;;391      {
;;;392        /* Reset TR, DR and CR registers */
;;;393        RTC->TR = (uint32_t)0x00000000;
000098  48d5              LDR      r0,|L1.1008|
00009a  3824              SUBS     r0,r0,#0x24
00009c  6004              STR      r4,[r0,#0]
;;;394        RTC->DR = (uint32_t)0x00002101;
00009e  49d4              LDR      r1,|L1.1008|
0000a0  f2421001          MOV      r0,#0x2101
0000a4  3920              SUBS     r1,r1,#0x20
0000a6  6008              STR      r0,[r1,#0]
;;;395        /* Reset All CR bits except CR[2:0] */
;;;396        RTC->CR &= (uint32_t)0x00000007;
0000a8  1d0b              ADDS     r3,r1,#4
0000aa  6818              LDR      r0,[r3,#0]
0000ac  f0000007          AND      r0,r0,#7
0000b0  6018              STR      r0,[r3,#0]
;;;397      
;;;398        /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;399        do
;;;400        {
;;;401          wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
;;;402          wutcounter++;  
;;;403        } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
0000b2  138d              ASRS     r5,r1,#14
0000b4  1d1a              ADDS     r2,r3,#4              ;401
                  |L1.182|
0000b6  6810              LDR      r0,[r2,#0]            ;401
0000b8  9900              LDR      r1,[sp,#0]            ;402
0000ba  f0000004          AND      r0,r0,#4              ;401
0000be  1c49              ADDS     r1,r1,#1              ;402
0000c0  9100              STR      r1,[sp,#0]
0000c2  42a9              CMP      r1,r5
0000c4  d001              BEQ      |L1.202|
0000c6  2800              CMP      r0,#0
0000c8  d0f5              BEQ      |L1.182|
                  |L1.202|
;;;404        
;;;405        if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
0000ca  6810              LDR      r0,[r2,#0]
0000cc  0740              LSLS     r0,r0,#29
0000ce  d529              BPL      |L1.292|
;;;406        {
;;;407          status = ERROR;
;;;408        }
;;;409        else
;;;410        {
;;;411          /* Reset all RTC CR register bits */
;;;412          RTC->CR &= (uint32_t)0x00000000;
0000d0  6818              LDR      r0,[r3,#0]
0000d2  601c              STR      r4,[r3,#0]
;;;413          RTC->WUTR = (uint32_t)0x0000FFFF;
0000d4  49c6              LDR      r1,|L1.1008|
0000d6  f64f70ff          MOV      r0,#0xffff
0000da  3910              SUBS     r1,r1,#0x10
0000dc  6008              STR      r0,[r1,#0]
;;;414          RTC->PRER = (uint32_t)0x007F00FF;
0000de  1f09              SUBS     r1,r1,#4
0000e0  48c4              LDR      r0,|L1.1012|
0000e2  6008              STR      r0,[r1,#0]
;;;415          RTC->CALIBR = (uint32_t)0x00000000;
0000e4  48c2              LDR      r0,|L1.1008|
0000e6  380c              SUBS     r0,r0,#0xc
0000e8  6004              STR      r4,[r0,#0]
;;;416          RTC->ALRMAR = (uint32_t)0x00000000;        
0000ea  1d00              ADDS     r0,r0,#4
0000ec  6004              STR      r4,[r0,#0]
;;;417          RTC->ALRMBR = (uint32_t)0x00000000;
0000ee  1d00              ADDS     r0,r0,#4
0000f0  6004              STR      r4,[r0,#0]
;;;418          RTC->SHIFTR = (uint32_t)0x00000000;
0000f2  48bf              LDR      r0,|L1.1008|
0000f4  3008              ADDS     r0,r0,#8
0000f6  6004              STR      r4,[r0,#0]
;;;419          RTC->CALR = (uint32_t)0x00000000;
0000f8  48bd              LDR      r0,|L1.1008|
0000fa  3018              ADDS     r0,r0,#0x18
0000fc  6004              STR      r4,[r0,#0]
;;;420          RTC->ALRMASSR = (uint32_t)0x00000000;
0000fe  48bc              LDR      r0,|L1.1008|
000100  3020              ADDS     r0,r0,#0x20
000102  6004              STR      r4,[r0,#0]
;;;421          RTC->ALRMBSSR = (uint32_t)0x00000000;
000104  1d00              ADDS     r0,r0,#4
000106  6004              STR      r4,[r0,#0]
;;;422          
;;;423          /* Reset ISR register and exit initialization mode */
;;;424          RTC->ISR = (uint32_t)0x00000000;
000108  6014              STR      r4,[r2,#0]
;;;425          
;;;426          /* Reset Tamper and alternate functions configuration register */
;;;427          RTC->TAFCR = 0x00000000;
00010a  48b9              LDR      r0,|L1.1008|
00010c  301c              ADDS     r0,r0,#0x1c
00010e  6004              STR      r4,[r0,#0]
;;;428      
;;;429          if(RTC_WaitForSynchro() == ERROR)
000110  e000              B        |L1.276|
                  |L1.274|
000112  e003              B        |L1.284|
                  |L1.276|
000114  f7fffffe          BL       RTC_WaitForSynchro
000118  b120              CBZ      r0,|L1.292|
;;;430          {
;;;431            status = ERROR;
;;;432          }
;;;433          else
;;;434          {
;;;435            status = SUCCESS;      
00011a  2501              MOVS     r5,#1
                  |L1.284|
;;;436          }
;;;437        }
;;;438      }
;;;439      
;;;440      /* Enable the write protection for RTC registers */
;;;441      RTC->WPR = 0xFF;  
00011c  20ff              MOVS     r0,#0xff
00011e  6030              STR      r0,[r6,#0]
;;;442      
;;;443      return status;
000120  4628              MOV      r0,r5
;;;444    }
000122  bd78              POP      {r3-r6,pc}
                  |L1.292|
000124  2500              MOVS     r5,#0                 ;431
000126  e7f9              B        |L1.284|
;;;445    
                          ENDP

                  RTC_ExitInitMode PROC
;;;596      */
;;;597    void RTC_ExitInitMode(void)
000128  48b1              LDR      r0,|L1.1008|
;;;598    { 
;;;599      /* Exit Initialization mode */
;;;600      RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
00012a  3818              SUBS     r0,r0,#0x18
00012c  6801              LDR      r1,[r0,#0]
00012e  f0210180          BIC      r1,r1,#0x80
000132  6001              STR      r1,[r0,#0]
;;;601    }
000134  4770              BX       lr
;;;602    
                          ENDP

                  RTC_Init PROC
;;;456      */
;;;457    ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
000136  b570              PUSH     {r4-r6,lr}
;;;458    {
;;;459      ErrorStatus status = ERROR;
;;;460      
;;;461      /* Check the parameters */
;;;462      assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
;;;463      assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
;;;464      assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
;;;465    
;;;466      /* Disable the write protection for RTC registers */
;;;467      RTC->WPR = 0xCA;
000138  4ead              LDR      r6,|L1.1008|
00013a  4604              MOV      r4,r0                 ;458
00013c  2500              MOVS     r5,#0                 ;459
00013e  20ca              MOVS     r0,#0xca
000140  6030              STR      r0,[r6,#0]
;;;468      RTC->WPR = 0x53;
000142  2053              MOVS     r0,#0x53
000144  6030              STR      r0,[r6,#0]
;;;469    
;;;470      /* Set Initialization mode */
;;;471      if (RTC_EnterInitMode() == ERROR)
000146  f7fffffe          BL       RTC_EnterInitMode
00014a  b1a8              CBZ      r0,|L1.376|
;;;472      {
;;;473        status = ERROR;
;;;474      } 
;;;475      else
;;;476      {
;;;477        /* Clear RTC CR FMT Bit */
;;;478        RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
00014c  48a8              LDR      r0,|L1.1008|
00014e  381c              SUBS     r0,r0,#0x1c
000150  6801              LDR      r1,[r0,#0]
000152  f0210140          BIC      r1,r1,#0x40
000156  6001              STR      r1,[r0,#0]
;;;479        /* Set RTC_CR register */
;;;480        RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
000158  6801              LDR      r1,[r0,#0]
00015a  6822              LDR      r2,[r4,#0]
00015c  4311              ORRS     r1,r1,r2
00015e  6001              STR      r1,[r0,#0]
;;;481      
;;;482        /* Configure the RTC PRER */
;;;483        RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
000160  48a3              LDR      r0,|L1.1008|
000162  68a1              LDR      r1,[r4,#8]
000164  3814              SUBS     r0,r0,#0x14
000166  6001              STR      r1,[r0,#0]
;;;484        RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
000168  6801              LDR      r1,[r0,#0]
00016a  88a2              LDRH     r2,[r4,#4]
00016c  ea414102          ORR      r1,r1,r2,LSL #16
000170  6001              STR      r1,[r0,#0]
;;;485    
;;;486        /* Exit Initialization mode */
;;;487        RTC_ExitInitMode();
000172  f7fffffe          BL       RTC_ExitInitMode
;;;488    
;;;489        status = SUCCESS;    
000176  2501              MOVS     r5,#1
                  |L1.376|
;;;490      }
;;;491      /* Enable the write protection for RTC registers */
;;;492      RTC->WPR = 0xFF; 
000178  20ff              MOVS     r0,#0xff
00017a  6030              STR      r0,[r6,#0]
;;;493      
;;;494      return status;
00017c  4628              MOV      r0,r5
;;;495    }
00017e  bd70              POP      {r4-r6,pc}
;;;496    
                          ENDP

                  RTC_StructInit PROC
;;;502      */
;;;503    void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
000180  2100              MOVS     r1,#0
;;;504    {
;;;505      /* Initialize the RTC_HourFormat member */
;;;506      RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
;;;507        
;;;508      /* Initialize the RTC_AsynchPrediv member */
;;;509      RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
000182  6001              STR      r1,[r0,#0]
000184  217f              MOVS     r1,#0x7f
;;;510    
;;;511      /* Initialize the RTC_SynchPrediv member */
;;;512      RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
000186  6041              STR      r1,[r0,#4]
000188  21ff              MOVS     r1,#0xff
00018a  6081              STR      r1,[r0,#8]
;;;513    }
00018c  4770              BX       lr
;;;514    
                          ENDP

                  RTC_WriteProtectionCmd PROC
;;;524      */
;;;525    void RTC_WriteProtectionCmd(FunctionalState NewState)
00018e  4998              LDR      r1,|L1.1008|
;;;526    {
000190  b108              CBZ      r0,|L1.406|
;;;527      /* Check the parameters */
;;;528      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;529        
;;;530      if (NewState != DISABLE)
;;;531      {
;;;532        /* Enable the write protection for RTC registers */
;;;533        RTC->WPR = 0xFF;   
000192  20ff              MOVS     r0,#0xff
000194  e002              B        |L1.412|
                  |L1.406|
;;;534      }
;;;535      else
;;;536      {
;;;537        /* Disable the write protection for RTC registers */
;;;538        RTC->WPR = 0xCA;
000196  20ca              MOVS     r0,#0xca
000198  6008              STR      r0,[r1,#0]
;;;539        RTC->WPR = 0x53;    
00019a  2053              MOVS     r0,#0x53
                  |L1.412|
00019c  6008              STR      r0,[r1,#0]            ;533
;;;540      }
;;;541    }
00019e  4770              BX       lr
;;;542    
                          ENDP

                  RTC_RefClockCmd PROC
;;;661      */
;;;662    ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
0001a0  b570              PUSH     {r4-r6,lr}
;;;663    { 
;;;664      ErrorStatus status = ERROR;
;;;665      
;;;666      /* Check the parameters */
;;;667      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;668      
;;;669      /* Disable the write protection for RTC registers */
;;;670      RTC->WPR = 0xCA;
0001a2  4e93              LDR      r6,|L1.1008|
0001a4  4605              MOV      r5,r0                 ;663
0001a6  2400              MOVS     r4,#0                 ;664
0001a8  20ca              MOVS     r0,#0xca
0001aa  6030              STR      r0,[r6,#0]
;;;671      RTC->WPR = 0x53;
0001ac  2053              MOVS     r0,#0x53
0001ae  6030              STR      r0,[r6,#0]
;;;672        
;;;673      /* Set Initialization mode */
;;;674      if (RTC_EnterInitMode() == ERROR)
0001b0  f7fffffe          BL       RTC_EnterInitMode
0001b4  b160              CBZ      r0,|L1.464|
;;;675      {
;;;676        status = ERROR;
;;;677      } 
;;;678      else
;;;679      {  
;;;680        if (NewState != DISABLE)
;;;681        {
;;;682          /* Enable the RTC reference clock detection */
;;;683          RTC->CR |= RTC_CR_REFCKON;   
0001b6  488e              LDR      r0,|L1.1008|
0001b8  381c              SUBS     r0,r0,#0x1c
;;;684        }
;;;685        else
;;;686        {
;;;687          /* Disable the RTC reference clock detection */
;;;688          RTC->CR &= ~RTC_CR_REFCKON;    
0001ba  6801              LDR      r1,[r0,#0]
0001bc  b115              CBZ      r5,|L1.452|
0001be  f0410110          ORR      r1,r1,#0x10           ;683
0001c2  e001              B        |L1.456|
                  |L1.452|
0001c4  f0210110          BIC      r1,r1,#0x10
                  |L1.456|
0001c8  6001              STR      r1,[r0,#0]
;;;689        }
;;;690        /* Exit Initialization mode */
;;;691        RTC_ExitInitMode();
0001ca  f7fffffe          BL       RTC_ExitInitMode
;;;692        
;;;693        status = SUCCESS;
0001ce  2401              MOVS     r4,#1
                  |L1.464|
;;;694      }
;;;695      
;;;696      /* Enable the write protection for RTC registers */
;;;697      RTC->WPR = 0xFF;  
0001d0  20ff              MOVS     r0,#0xff
0001d2  6030              STR      r0,[r6,#0]
;;;698      
;;;699      return status; 
0001d4  4620              MOV      r0,r4
;;;700    }
0001d6  bd70              POP      {r4-r6,pc}
;;;701    
                          ENDP

                  RTC_BypassShadowCmd PROC
;;;709    */
;;;710    void RTC_BypassShadowCmd(FunctionalState NewState)
0001d8  4a85              LDR      r2,|L1.1008|
;;;711    {
;;;712      /* Check the parameters */
;;;713      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;714    
;;;715      /* Disable the write protection for RTC registers */
;;;716      RTC->WPR = 0xCA;
0001da  21ca              MOVS     r1,#0xca
0001dc  6011              STR      r1,[r2,#0]
;;;717      RTC->WPR = 0x53;
0001de  2153              MOVS     r1,#0x53
0001e0  6011              STR      r1,[r2,#0]
;;;718      
;;;719      if (NewState != DISABLE)
;;;720      {
;;;721        /* Set the BYPSHAD bit */
;;;722        RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
0001e2  4983              LDR      r1,|L1.1008|
0001e4  391c              SUBS     r1,r1,#0x1c
0001e6  2800              CMP      r0,#0                 ;719
;;;723      }
;;;724      else
;;;725      {
;;;726        /* Reset the BYPSHAD bit */
;;;727        RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
0001e8  6808              LDR      r0,[r1,#0]
0001ea  d002              BEQ      |L1.498|
0001ec  f0400020          ORR      r0,r0,#0x20           ;722
0001f0  e001              B        |L1.502|
                  |L1.498|
0001f2  f00000df          AND      r0,r0,#0xdf
                  |L1.502|
0001f6  6008              STR      r0,[r1,#0]
;;;728      }
;;;729    
;;;730      /* Enable the write protection for RTC registers */
;;;731      RTC->WPR = 0xFF;
0001f8  20ff              MOVS     r0,#0xff
0001fa  6010              STR      r0,[r2,#0]
;;;732    }
0001fc  4770              BX       lr
;;;733    
                          ENDP

                  RTC_SetTime PROC
;;;764      */
;;;765    ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
0001fe  e92d41f0          PUSH     {r4-r8,lr}
;;;766    {
000202  460c              MOV      r4,r1
;;;767      uint32_t tmpreg = 0;
;;;768      ErrorStatus status = ERROR;
000204  2600              MOVS     r6,#0
;;;769        
;;;770      /* Check the parameters */
;;;771      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;772      
;;;773      if (RTC_Format == RTC_Format_BIN)
;;;774      {
;;;775        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000206  4f7c              LDR      r7,|L1.1016|
000208  0001              MOVS     r1,r0                 ;773
;;;776        {
;;;777          assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;778          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
;;;779        } 
;;;780        else
;;;781        {
;;;782          RTC_TimeStruct->RTC_H12 = 0x00;
;;;783          assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
;;;784        }
;;;785        assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;786        assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
;;;787      }
;;;788      else
;;;789      {
;;;790        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;791        {
;;;792          tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00020a  7820              LDRB     r0,[r4,#0]
00020c  6839              LDR      r1,[r7,#0]            ;790
00020e  4632              MOV      r2,r6                 ;773
000210  ea4f6141          LSL      r1,r1,#25             ;790
000214  d004              BEQ      |L1.544|
000216  2900              CMP      r1,#0                 ;790
000218  da2f              BGE      |L1.634|
00021a  f7fffffe          BL       RTC_Bcd2ToByte
;;;793          assert_param(IS_RTC_HOUR12(tmpreg));
;;;794          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
00021e  e02d              B        |L1.636|
                  |L1.544|
000220  2900              CMP      r1,#0                 ;775
000222  db00              BLT      |L1.550|
000224  70e2              STRB     r2,[r4,#3]            ;782
                  |L1.550|
;;;795        } 
;;;796        else
;;;797        {
;;;798          RTC_TimeStruct->RTC_H12 = 0x00;
;;;799          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
;;;800        }
;;;801        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;802        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
;;;803      }
;;;804      
;;;805      /* Check the input parameters format */
;;;806      if (RTC_Format != RTC_Format_BIN)
;;;807      {
;;;808        tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
;;;809                 ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;810                 ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;811                 ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;812      }  
;;;813      else
;;;814      {
;;;815        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
000226  f7fffffe          BL       RTC_ByteToBcd2
00022a  0405              LSLS     r5,r0,#16
00022c  7860              LDRB     r0,[r4,#1]
00022e  f7fffffe          BL       RTC_ByteToBcd2
000232  ea452500          ORR      r5,r5,r0,LSL #8
000236  78a0              LDRB     r0,[r4,#2]
000238  f7fffffe          BL       RTC_ByteToBcd2
00023c  4305              ORRS     r5,r5,r0
00023e  78e0              LDRB     r0,[r4,#3]
000240  ea454500          ORR      r5,r5,r0,LSL #16
                  |L1.580|
;;;816                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;817                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;818                       (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;819      }  
;;;820    
;;;821      /* Disable the write protection for RTC registers */
;;;822      RTC->WPR = 0xCA;
000244  4c6a              LDR      r4,|L1.1008|
000246  20ca              MOVS     r0,#0xca
000248  6020              STR      r0,[r4,#0]
;;;823      RTC->WPR = 0x53;
00024a  2053              MOVS     r0,#0x53
00024c  6020              STR      r0,[r4,#0]
;;;824    
;;;825      /* Set Initialization mode */
;;;826      if (RTC_EnterInitMode() == ERROR)
00024e  f7fffffe          BL       RTC_EnterInitMode
000252  b168              CBZ      r0,|L1.624|
;;;827      {
;;;828        status = ERROR;
;;;829      } 
;;;830      else
;;;831      {
;;;832        /* Set the RTC_TR register */
;;;833        RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
000254  4869              LDR      r0,|L1.1020|
000256  4005              ANDS     r5,r5,r0
000258  4867              LDR      r0,|L1.1016|
00025a  3808              SUBS     r0,r0,#8
00025c  6005              STR      r5,[r0,#0]
;;;834    
;;;835        /* Exit Initialization mode */
;;;836        RTC_ExitInitMode(); 
00025e  f7fffffe          BL       RTC_ExitInitMode
;;;837    
;;;838        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;839        if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
000262  6838              LDR      r0,[r7,#0]
000264  0680              LSLS     r0,r0,#26
000266  d402              BMI      |L1.622|
;;;840        {
;;;841        if(RTC_WaitForSynchro() == ERROR)
000268  f7fffffe          BL       RTC_WaitForSynchro
00026c  b100              CBZ      r0,|L1.624|
                  |L1.622|
;;;842        {
;;;843          status = ERROR;
;;;844        }
;;;845        else
;;;846        {
;;;847          status = SUCCESS;
;;;848        }
;;;849      }
;;;850        else
;;;851        {
;;;852          status = SUCCESS;
00026e  2601              MOVS     r6,#1
                  |L1.624|
;;;853        }
;;;854      }
;;;855      /* Enable the write protection for RTC registers */
;;;856      RTC->WPR = 0xFF; 
000270  20ff              MOVS     r0,#0xff
000272  6020              STR      r0,[r4,#0]
;;;857        
;;;858      return status;
000274  4630              MOV      r0,r6
;;;859    }
000276  e8bd81f0          POP      {r4-r8,pc}
                  |L1.634|
00027a  70e2              STRB     r2,[r4,#3]            ;798
                  |L1.636|
00027c  78a0              LDRB     r0,[r4,#2]            ;808
00027e  7821              LDRB     r1,[r4,#0]            ;808
000280  ea404501          ORR      r5,r0,r1,LSL #16      ;808
000284  7860              LDRB     r0,[r4,#1]            ;808
000286  78e1              LDRB     r1,[r4,#3]            ;808
000288  0200              LSLS     r0,r0,#8              ;808
00028a  ea404001          ORR      r0,r0,r1,LSL #16      ;808
00028e  4305              ORRS     r5,r5,r0              ;808
000290  e7d8              B        |L1.580|
;;;860    
                          ENDP

                  RTC_TimeStructInit PROC
;;;867      */
;;;868    void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
000292  2100              MOVS     r1,#0
;;;869    {
;;;870      /* Time = 00h:00min:00sec */
;;;871      RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
000294  70c1              STRB     r1,[r0,#3]
;;;872      RTC_TimeStruct->RTC_Hours = 0;
000296  7001              STRB     r1,[r0,#0]
;;;873      RTC_TimeStruct->RTC_Minutes = 0;
000298  7041              STRB     r1,[r0,#1]
;;;874      RTC_TimeStruct->RTC_Seconds = 0; 
00029a  7081              STRB     r1,[r0,#2]
;;;875    }
00029c  4770              BX       lr
;;;876    
                          ENDP

                  RTC_GetTime PROC
;;;886      */
;;;887    void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
00029e  0002              MOVS     r2,r0
;;;888    {
0002a0  b510              PUSH     {r4,lr}
;;;889      uint32_t tmpreg = 0;
;;;890    
;;;891      /* Check the parameters */
;;;892      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;893    
;;;894      /* Get the RTC_TR register */
;;;895      tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
0002a2  4857              LDR      r0,|L1.1024|
0002a4  460c              MOV      r4,r1                 ;888
0002a6  6801              LDR      r1,[r0,#0]
0002a8  4854              LDR      r0,|L1.1020|
0002aa  ea010100          AND      r1,r1,r0
;;;896      
;;;897      /* Fill the structure fields with the read parameters */
;;;898      RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
0002ae  f3c14005          UBFX     r0,r1,#16,#6
0002b2  7020              STRB     r0,[r4,#0]
;;;899      RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
0002b4  f3c12306          UBFX     r3,r1,#8,#7
0002b8  7063              STRB     r3,[r4,#1]
;;;900      RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
0002ba  f001037f          AND      r3,r1,#0x7f
0002be  70a3              STRB     r3,[r4,#2]
;;;901      RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
0002c0  f04f0340          MOV      r3,#0x40
0002c4  ea034111          AND      r1,r3,r1,LSR #16
0002c8  70e1              STRB     r1,[r4,#3]
0002ca  d10a              BNE      |L1.738|
;;;902    
;;;903      /* Check the input parameters format */
;;;904      if (RTC_Format == RTC_Format_BIN)
;;;905      {
;;;906        /* Convert the structure parameters to Binary format */
;;;907        RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
0002cc  f7fffffe          BL       RTC_Bcd2ToByte
0002d0  7020              STRB     r0,[r4,#0]
;;;908        RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
0002d2  7860              LDRB     r0,[r4,#1]
0002d4  f7fffffe          BL       RTC_Bcd2ToByte
0002d8  7060              STRB     r0,[r4,#1]
;;;909        RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
0002da  78a0              LDRB     r0,[r4,#2]
0002dc  f7fffffe          BL       RTC_Bcd2ToByte
0002e0  70a0              STRB     r0,[r4,#2]
                  |L1.738|
;;;910      }
;;;911    }
0002e2  bd10              POP      {r4,pc}
;;;912    
                          ENDP

                  RTC_GetSubSecond PROC
;;;919      */
;;;920    uint32_t RTC_GetSubSecond(void)
0002e4  4842              LDR      r0,|L1.1008|
;;;921    {
;;;922      uint32_t tmpreg = 0;
;;;923      
;;;924      /* Get sub seconds values from the correspondent registers*/
;;;925      tmpreg = (uint32_t)(RTC->SSR);
0002e6  1d00              ADDS     r0,r0,#4
0002e8  6800              LDR      r0,[r0,#0]
;;;926      
;;;927      /* Read DR register to unfroze calendar registers */
;;;928      (void) (RTC->DR);
0002ea  4943              LDR      r1,|L1.1016|
0002ec  1f09              SUBS     r1,r1,#4
0002ee  6809              LDR      r1,[r1,#0]
;;;929      
;;;930      return (tmpreg);
;;;931    }
0002f0  4770              BX       lr
;;;932    
                          ENDP

                  RTC_SetDate PROC
;;;944      */
;;;945    ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
0002f2  b570              PUSH     {r4-r6,lr}
;;;946    {
0002f4  460c              MOV      r4,r1
;;;947      uint32_t tmpreg = 0;
;;;948      ErrorStatus status = ERROR;
0002f6  2600              MOVS     r6,#0
;;;949      
;;;950      /* Check the parameters */
;;;951      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;952    
;;;953      if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
0002f8  0001              MOVS     r1,r0
0002fa  7860              LDRB     r0,[r4,#1]
0002fc  d00f              BEQ      |L1.798|
;;;954      {
;;;955        RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
;;;956      }  
;;;957      if (RTC_Format == RTC_Format_BIN)
;;;958      {
;;;959        assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;960        assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;961        assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
;;;962      }
;;;963      else
;;;964      {
;;;965        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
;;;966        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
0002fe  f7fffffe          BL       RTC_Bcd2ToByte
;;;967        assert_param(IS_RTC_MONTH(tmpreg));
;;;968        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
000302  78a0              LDRB     r0,[r4,#2]
000304  f7fffffe          BL       RTC_Bcd2ToByte
;;;969        assert_param(IS_RTC_DATE(tmpreg));
;;;970      }
;;;971      assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
;;;972    
;;;973      /* Check the input parameters format */
;;;974      if (RTC_Format != RTC_Format_BIN)
;;;975      {
;;;976        tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
000308  78a0              LDRB     r0,[r4,#2]
00030a  78e1              LDRB     r1,[r4,#3]
00030c  ea404501          ORR      r5,r0,r1,LSL #16
000310  7860              LDRB     r0,[r4,#1]
000312  7821              LDRB     r1,[r4,#0]
000314  0200              LSLS     r0,r0,#8
000316  ea403041          ORR      r0,r0,r1,LSL #13
00031a  4305              ORRS     r5,r5,r0
00031c  e015              B        |L1.842|
                  |L1.798|
00031e  06c1              LSLS     r1,r0,#27             ;953
000320  d503              BPL      |L1.810|
000322  f0200010          BIC      r0,r0,#0x10           ;955
000326  300a              ADDS     r0,r0,#0xa            ;955
000328  7060              STRB     r0,[r4,#1]            ;955
                  |L1.810|
;;;977                  (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;978                  ((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;979                  (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;980      }  
;;;981      else
;;;982      {
;;;983        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
00032a  78e0              LDRB     r0,[r4,#3]
00032c  f7fffffe          BL       RTC_ByteToBcd2
000330  0405              LSLS     r5,r0,#16
000332  7860              LDRB     r0,[r4,#1]
000334  f7fffffe          BL       RTC_ByteToBcd2
000338  ea452500          ORR      r5,r5,r0,LSL #8
00033c  78a0              LDRB     r0,[r4,#2]
00033e  f7fffffe          BL       RTC_ByteToBcd2
000342  4305              ORRS     r5,r5,r0
000344  7820              LDRB     r0,[r4,#0]
000346  ea453540          ORR      r5,r5,r0,LSL #13
                  |L1.842|
;;;984                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;985                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;986                  ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;987      }
;;;988    
;;;989      /* Disable the write protection for RTC registers */
;;;990      RTC->WPR = 0xCA;
00034a  4c29              LDR      r4,|L1.1008|
00034c  20ca              MOVS     r0,#0xca
00034e  6020              STR      r0,[r4,#0]
;;;991      RTC->WPR = 0x53;
000350  2053              MOVS     r0,#0x53
000352  6020              STR      r0,[r4,#0]
;;;992    
;;;993      /* Set Initialization mode */
;;;994      if (RTC_EnterInitMode() == ERROR)
000354  f7fffffe          BL       RTC_EnterInitMode
000358  b170              CBZ      r0,|L1.888|
;;;995      {
;;;996        status = ERROR;
;;;997      } 
;;;998      else
;;;999      {
;;;1000       /* Set the RTC_DR register */
;;;1001       RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
00035a  482a              LDR      r0,|L1.1028|
00035c  4005              ANDS     r5,r5,r0
00035e  4826              LDR      r0,|L1.1016|
000360  1f00              SUBS     r0,r0,#4
000362  6005              STR      r5,[r0,#0]
;;;1002   
;;;1003       /* Exit Initialization mode */
;;;1004       RTC_ExitInitMode(); 
000364  f7fffffe          BL       RTC_ExitInitMode
;;;1005   
;;;1006       /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;1007       if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
000368  4823              LDR      r0,|L1.1016|
00036a  6800              LDR      r0,[r0,#0]
00036c  0680              LSLS     r0,r0,#26
00036e  d402              BMI      |L1.886|
;;;1008       {
;;;1009       if(RTC_WaitForSynchro() == ERROR)
000370  f7fffffe          BL       RTC_WaitForSynchro
000374  b100              CBZ      r0,|L1.888|
                  |L1.886|
;;;1010       {
;;;1011         status = ERROR;
;;;1012       }
;;;1013       else
;;;1014       {
;;;1015         status = SUCCESS;
;;;1016       }
;;;1017     }
;;;1018       else
;;;1019       {
;;;1020         status = SUCCESS;
000376  2601              MOVS     r6,#1
                  |L1.888|
;;;1021       }
;;;1022     }
;;;1023     /* Enable the write protection for RTC registers */
;;;1024     RTC->WPR = 0xFF;   
000378  20ff              MOVS     r0,#0xff
00037a  6020              STR      r0,[r4,#0]
;;;1025     
;;;1026     return status;
00037c  4630              MOV      r0,r6
;;;1027   }
00037e  bd70              POP      {r4-r6,pc}
;;;1028   
                          ENDP

                  RTC_DateStructInit PROC
;;;1035     */
;;;1036   void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
000380  2101              MOVS     r1,#1
;;;1037   {
;;;1038     /* Monday, January 01 xx00 */
;;;1039     RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
000382  7001              STRB     r1,[r0,#0]
;;;1040     RTC_DateStruct->RTC_Date = 1;
000384  7081              STRB     r1,[r0,#2]
;;;1041     RTC_DateStruct->RTC_Month = RTC_Month_January;
000386  7041              STRB     r1,[r0,#1]
;;;1042     RTC_DateStruct->RTC_Year = 0;
000388  2100              MOVS     r1,#0
00038a  70c1              STRB     r1,[r0,#3]
;;;1043   }
00038c  4770              BX       lr
;;;1044   
                          ENDP

                  RTC_GetDate PROC
;;;1054     */
;;;1055   void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
00038e  0002              MOVS     r2,r0
;;;1056   {
000390  b510              PUSH     {r4,lr}
;;;1057     uint32_t tmpreg = 0;
;;;1058   
;;;1059     /* Check the parameters */
;;;1060     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1061     
;;;1062     /* Get the RTC_TR register */
;;;1063     tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
000392  481d              LDR      r0,|L1.1032|
000394  460c              MOV      r4,r1                 ;1056
000396  6801              LDR      r1,[r0,#0]
000398  481a              LDR      r0,|L1.1028|
00039a  ea010100          AND      r1,r1,r0
;;;1064   
;;;1065     /* Fill the structure fields with the read parameters */
;;;1066     RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
00039e  ea4f4011          LSR      r0,r1,#16
0003a2  70e0              STRB     r0,[r4,#3]
;;;1067     RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
0003a4  f3c12304          UBFX     r3,r1,#8,#5
0003a8  7063              STRB     r3,[r4,#1]
;;;1068     RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
0003aa  f001033f          AND      r3,r1,#0x3f
0003ae  70a3              STRB     r3,[r4,#2]
;;;1069     RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
0003b0  f3c13142          UBFX     r1,r1,#13,#3
0003b4  7021              STRB     r1,[r4,#0]
0003b6  d10a              BNE      |L1.974|
;;;1070   
;;;1071     /* Check the input parameters format */
;;;1072     if (RTC_Format == RTC_Format_BIN)
;;;1073     {
;;;1074       /* Convert the structure parameters to Binary format */
;;;1075       RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
0003b8  f7fffffe          BL       RTC_Bcd2ToByte
0003bc  70e0              STRB     r0,[r4,#3]
;;;1076       RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
0003be  7860              LDRB     r0,[r4,#1]
0003c0  f7fffffe          BL       RTC_Bcd2ToByte
0003c4  7060              STRB     r0,[r4,#1]
;;;1077       RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
0003c6  78a0              LDRB     r0,[r4,#2]
0003c8  f7fffffe          BL       RTC_Bcd2ToByte
0003cc  70a0              STRB     r0,[r4,#2]
                  |L1.974|
;;;1078     }
;;;1079   }
0003ce  bd10              POP      {r4,pc}
;;;1080   
                          ENDP

                  RTC_SetAlarm PROC
;;;1114     */
;;;1115   void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
0003d0  b570              PUSH     {r4-r6,lr}
;;;1116   {
0003d2  4614              MOV      r4,r2
0003d4  460d              MOV      r5,r1
;;;1117     uint32_t tmpreg = 0;
;;;1118     
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1121     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1122     assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
;;;1123     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
;;;1124   
;;;1125     if (RTC_Format == RTC_Format_BIN)
;;;1126     {
;;;1127       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
0003d6  4a08              LDR      r2,|L1.1016|
0003d8  2100              MOVS     r1,#0                 ;1116
0003da  2800              CMP      r0,#0                 ;1125
;;;1128       {
;;;1129         assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1130         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
;;;1131       } 
;;;1132       else
;;;1133       {
;;;1134         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1135         assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1136       }
;;;1137       assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
;;;1138       assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
;;;1139       
;;;1140       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1141       {
;;;1142         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1143       }
;;;1144       else
;;;1145       {
;;;1146         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1147       }
;;;1148     }
;;;1149     else
;;;1150     {
;;;1151       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
0003dc  6810              LDR      r0,[r2,#0]
0003de  ea4f6040          LSL      r0,r0,#25
0003e2  d013              BEQ      |L1.1036|
0003e4  2800              CMP      r0,#0
0003e6  da2a              BGE      |L1.1086|
;;;1152       {
;;;1153         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
0003e8  7820              LDRB     r0,[r4,#0]
0003ea  f7fffffe          BL       RTC_Bcd2ToByte
;;;1154         assert_param(IS_RTC_HOUR12(tmpreg));
;;;1155         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
0003ee  e027              B        |L1.1088|
                  |L1.1008|
                          DCD      0x40002824
                  |L1.1012|
                          DCD      0x007f00ff
                  |L1.1016|
                          DCD      0x40002808
                  |L1.1020|
                          DCD      0x007f7f7f
                  |L1.1024|
                          DCD      0x40002800
                  |L1.1028|
                          DCD      0x00ffff3f
                  |L1.1032|
                          DCD      0x40002804
                  |L1.1036|
00040c  2800              CMP      r0,#0                 ;1127
00040e  db00              BLT      |L1.1042|
000410  70e1              STRB     r1,[r4,#3]            ;1134
                  |L1.1042|
;;;1156       } 
;;;1157       else
;;;1158       {
;;;1159         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1160         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
;;;1161       }
;;;1162       
;;;1163       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
;;;1164       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
;;;1165       
;;;1166       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1167       {
;;;1168         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1169         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
;;;1170       }
;;;1171       else
;;;1172       {
;;;1173         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1174         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
;;;1175       }    
;;;1176     }
;;;1177   
;;;1178     /* Check the input parameters format */
;;;1179     if (RTC_Format != RTC_Format_BIN)
;;;1180     {
;;;1181       tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
;;;1182                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1183                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
;;;1184                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1185                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1186                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1187                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1188     }  
;;;1189     else
;;;1190     {
;;;1191       tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
000412  7820              LDRB     r0,[r4,#0]
000414  f7fffffe          BL       RTC_ByteToBcd2
000418  0406              LSLS     r6,r0,#16
00041a  7860              LDRB     r0,[r4,#1]
00041c  f7fffffe          BL       RTC_ByteToBcd2
000420  ea462600          ORR      r6,r6,r0,LSL #8
000424  78a0              LDRB     r0,[r4,#2]
000426  f7fffffe          BL       RTC_ByteToBcd2
00042a  4306              ORRS     r6,r6,r0
00042c  78e0              LDRB     r0,[r4,#3]
00042e  ea464600          ORR      r6,r6,r0,LSL #16
000432  7b20              LDRB     r0,[r4,#0xc]
000434  f7fffffe          BL       RTC_ByteToBcd2
000438  ea466000          ORR      r0,r6,r0,LSL #24
00043c  e010              B        |L1.1120|
                  |L1.1086|
00043e  70e1              STRB     r1,[r4,#3]            ;1159
                  |L1.1088|
000440  7b20              LDRB     r0,[r4,#0xc]          ;1168
000442  f7fffffe          BL       RTC_Bcd2ToByte
000446  78a0              LDRB     r0,[r4,#2]            ;1181
000448  7821              LDRB     r1,[r4,#0]            ;1181
00044a  78e2              LDRB     r2,[r4,#3]            ;1181
00044c  ea404001          ORR      r0,r0,r1,LSL #16      ;1181
000450  7861              LDRB     r1,[r4,#1]            ;1181
000452  0209              LSLS     r1,r1,#8              ;1181
000454  ea414102          ORR      r1,r1,r2,LSL #16      ;1181
000458  4308              ORRS     r0,r0,r1              ;1181
00045a  7b21              LDRB     r1,[r4,#0xc]          ;1181
00045c  ea406001          ORR      r0,r0,r1,LSL #24      ;1181
                  |L1.1120|
000460  68a1              LDR      r1,[r4,#8]
000462  4308              ORRS     r0,r0,r1
000464  6861              LDR      r1,[r4,#4]
000466  4308              ORRS     r0,r0,r1
;;;1192                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1193                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
;;;1194                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1195                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1196                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1197                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1198     } 
;;;1199   
;;;1200     /* Disable the write protection for RTC registers */
;;;1201     RTC->WPR = 0xCA;
000468  49f8              LDR      r1,|L1.2124|
00046a  22ca              MOVS     r2,#0xca
00046c  600a              STR      r2,[r1,#0]
;;;1202     RTC->WPR = 0x53;
00046e  2253              MOVS     r2,#0x53
000470  600a              STR      r2,[r1,#0]
;;;1203   
;;;1204     /* Configure the Alarm register */
;;;1205     if (RTC_Alarm == RTC_Alarm_A)
000472  f5b57f80          CMP      r5,#0x100
000476  d004              BEQ      |L1.1154|
;;;1206     {
;;;1207       RTC->ALRMAR = (uint32_t)tmpreg;
;;;1208     }
;;;1209     else
;;;1210     {
;;;1211       RTC->ALRMBR = (uint32_t)tmpreg;
000478  1f0a              SUBS     r2,r1,#4
                  |L1.1146|
00047a  6010              STR      r0,[r2,#0]
;;;1212     }
;;;1213   
;;;1214     /* Enable the write protection for RTC registers */
;;;1215     RTC->WPR = 0xFF;   
00047c  20ff              MOVS     r0,#0xff
00047e  6008              STR      r0,[r1,#0]
;;;1216   }
000480  bd70              POP      {r4-r6,pc}
                  |L1.1154|
000482  4af2              LDR      r2,|L1.2124|
000484  3a08              SUBS     r2,r2,#8              ;1207
000486  e7f8              B        |L1.1146|
;;;1217   
                          ENDP

                  RTC_AlarmStructInit PROC
;;;1225     */
;;;1226   void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
000488  2100              MOVS     r1,#0
;;;1227   {
;;;1228     /* Alarm Time Settings : Time = 00h:00mn:00sec */
;;;1229     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
00048a  70c1              STRB     r1,[r0,#3]
;;;1230     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
00048c  7001              STRB     r1,[r0,#0]
;;;1231     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
00048e  7041              STRB     r1,[r0,#1]
;;;1232     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
000490  7081              STRB     r1,[r0,#2]
;;;1233   
;;;1234     /* Alarm Date Settings : Date = 1st day of the month */
;;;1235     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
;;;1236     RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
000492  2201              MOVS     r2,#1
000494  6081              STR      r1,[r0,#8]
000496  7302              STRB     r2,[r0,#0xc]
;;;1237   
;;;1238     /* Alarm Masks Settings : Mask =  all fields are not masked */
;;;1239     RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
000498  6041              STR      r1,[r0,#4]
;;;1240   }
00049a  4770              BX       lr
;;;1241   
                          ENDP

                  RTC_GetAlarm PROC
;;;1255     */
;;;1256   void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
00049c  b510              PUSH     {r4,lr}
;;;1257   {
00049e  4614              MOV      r4,r2
0004a0  4602              MOV      r2,r0
;;;1258     uint32_t tmpreg = 0;
;;;1259   
;;;1260     /* Check the parameters */
;;;1261     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1262     assert_param(IS_RTC_ALARM(RTC_Alarm)); 
;;;1263   
;;;1264     /* Get the RTC_ALRMxR register */
;;;1265     if (RTC_Alarm == RTC_Alarm_A)
0004a2  f5b17f80          CMP      r1,#0x100
0004a6  d02a              BEQ      |L1.1278|
;;;1266     {
;;;1267       tmpreg = (uint32_t)(RTC->ALRMAR);
;;;1268     }
;;;1269     else
;;;1270     {
;;;1271       tmpreg = (uint32_t)(RTC->ALRMBR);
0004a8  48e8              LDR      r0,|L1.2124|
0004aa  1f00              SUBS     r0,r0,#4
                  |L1.1196|
0004ac  6801              LDR      r1,[r0,#0]
;;;1272     }
;;;1273   
;;;1274     /* Fill the structure with the read parameters */
;;;1275     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
0004ae  f3c14005          UBFX     r0,r1,#16,#6
0004b2  7020              STRB     r0,[r4,#0]
;;;1276                                                        RTC_ALRMAR_HU)) >> 16);
;;;1277     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
0004b4  f3c12306          UBFX     r3,r1,#8,#7
0004b8  7063              STRB     r3,[r4,#1]
;;;1278                                                        RTC_ALRMAR_MNU)) >> 8);
;;;1279     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
0004ba  f001037f          AND      r3,r1,#0x7f
0004be  70a3              STRB     r3,[r4,#2]
;;;1280                                                        RTC_ALRMAR_SU));
;;;1281     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
0004c0  2340              MOVS     r3,#0x40
0004c2  ea034311          AND      r3,r3,r1,LSR #16
0004c6  70e3              STRB     r3,[r4,#3]
;;;1282     RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
0004c8  f3c16305          UBFX     r3,r1,#24,#6
0004cc  7323              STRB     r3,[r4,#0xc]
;;;1283     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
0004ce  f0014380          AND      r3,r1,#0x40000000
;;;1284     RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
0004d2  f0013180          AND      r1,r1,#0x80808080
0004d6  e9c41301          STRD     r1,r3,[r4,#4]
0004da  2a00              CMP      r2,#0
0004dc  d10e              BNE      |L1.1276|
;;;1285   
;;;1286     if (RTC_Format == RTC_Format_BIN)
;;;1287     {
;;;1288       RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
0004de  f7fffffe          BL       RTC_Bcd2ToByte
0004e2  7020              STRB     r0,[r4,#0]
;;;1289                                                           RTC_AlarmTime.RTC_Hours);
;;;1290       RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
0004e4  7860              LDRB     r0,[r4,#1]
0004e6  f7fffffe          BL       RTC_Bcd2ToByte
0004ea  7060              STRB     r0,[r4,#1]
;;;1291                                                           RTC_AlarmTime.RTC_Minutes);
;;;1292       RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
0004ec  78a0              LDRB     r0,[r4,#2]
0004ee  f7fffffe          BL       RTC_Bcd2ToByte
0004f2  70a0              STRB     r0,[r4,#2]
;;;1293                                                           RTC_AlarmTime.RTC_Seconds);
;;;1294       RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
0004f4  7b20              LDRB     r0,[r4,#0xc]
0004f6  f7fffffe          BL       RTC_Bcd2ToByte
0004fa  7320              STRB     r0,[r4,#0xc]
                  |L1.1276|
;;;1295     }  
;;;1296   }
0004fc  bd10              POP      {r4,pc}
                  |L1.1278|
0004fe  48d3              LDR      r0,|L1.2124|
000500  3808              SUBS     r0,r0,#8              ;1267
000502  e7d3              B        |L1.1196|
;;;1297   
                          ENDP

                  RTC_AlarmCmd PROC
;;;1309     */
;;;1310   ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
000504  b538              PUSH     {r3-r5,lr}
;;;1311   {
;;;1312     __IO uint32_t alarmcounter = 0x00;
000506  2200              MOVS     r2,#0
;;;1313     uint32_t alarmstatus = 0x00;
;;;1314     ErrorStatus status = ERROR;
;;;1315       
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
;;;1318     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1319   
;;;1320     /* Disable the write protection for RTC registers */
;;;1321     RTC->WPR = 0xCA;
000508  4cd0              LDR      r4,|L1.2124|
00050a  9200              STR      r2,[sp,#0]
00050c  22ca              MOVS     r2,#0xca
00050e  6022              STR      r2,[r4,#0]
;;;1322     RTC->WPR = 0x53;
000510  2253              MOVS     r2,#0x53
000512  6022              STR      r2,[r4,#0]
;;;1323   
;;;1324     /* Configure the Alarm state */
;;;1325     if (NewState != DISABLE)
;;;1326     {
;;;1327       RTC->CR |= (uint32_t)RTC_Alarm;
000514  4acd              LDR      r2,|L1.2124|
000516  3a1c              SUBS     r2,r2,#0x1c
000518  2900              CMP      r1,#0                 ;1325
;;;1328   
;;;1329       status = SUCCESS;    
;;;1330     }
;;;1331     else
;;;1332     { 
;;;1333       /* Disable the Alarm in RTC_CR register */
;;;1334       RTC->CR &= (uint32_t)~RTC_Alarm;
00051a  6811              LDR      r1,[r2,#0]
00051c  d002              BEQ      |L1.1316|
00051e  4301              ORRS     r1,r1,r0              ;1327
000520  6011              STR      r1,[r2,#0]            ;1327
000522  e012              B        |L1.1354|
                  |L1.1316|
000524  4381              BICS     r1,r1,r0
000526  6011              STR      r1,[r2,#0]
;;;1335      
;;;1336       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1337       do
;;;1338       {
;;;1339         alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
000528  4ac8              LDR      r2,|L1.2124|
00052a  3a18              SUBS     r2,r2,#0x18
;;;1340         alarmcounter++;  
;;;1341       } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
00052c  1395              ASRS     r5,r2,#14
                  |L1.1326|
00052e  6811              LDR      r1,[r2,#0]            ;1339
000530  9b00              LDR      r3,[sp,#0]            ;1340
000532  ea012110          AND      r1,r1,r0,LSR #8       ;1339
000536  1c5b              ADDS     r3,r3,#1              ;1340
000538  9300              STR      r3,[sp,#0]
00053a  42ab              CMP      r3,r5
00053c  d001              BEQ      |L1.1346|
00053e  2900              CMP      r1,#0
000540  d0f5              BEQ      |L1.1326|
                  |L1.1346|
;;;1342       
;;;1343       if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
000542  6811              LDR      r1,[r2,#0]
000544  ea112010          ANDS     r0,r1,r0,LSR #8
000548  d000              BEQ      |L1.1356|
                  |L1.1354|
;;;1344       {
;;;1345         status = ERROR;
;;;1346       } 
;;;1347       else
;;;1348       {
;;;1349         status = SUCCESS;
00054a  2001              MOVS     r0,#1
                  |L1.1356|
;;;1350       }        
;;;1351     } 
;;;1352   
;;;1353     /* Enable the write protection for RTC registers */
;;;1354     RTC->WPR = 0xFF; 
00054c  21ff              MOVS     r1,#0xff
00054e  6021              STR      r1,[r4,#0]
;;;1355     
;;;1356     return status;
;;;1357   }
000550  bd38              POP      {r3-r5,pc}
;;;1358   
                          ENDP

                  RTC_AlarmSubSecondConfig PROC
;;;1403     */
;;;1404   void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
000552  b510              PUSH     {r4,lr}
;;;1405   {
;;;1406     uint32_t tmpreg = 0;
;;;1407   
;;;1408     /* Check the parameters */
;;;1409     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1410     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
;;;1411     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
;;;1412     
;;;1413     /* Disable the write protection for RTC registers */
;;;1414     RTC->WPR = 0xCA;
000554  4bbd              LDR      r3,|L1.2124|
000556  24ca              MOVS     r4,#0xca
000558  601c              STR      r4,[r3,#0]
;;;1415     RTC->WPR = 0x53;
00055a  2453              MOVS     r4,#0x53
00055c  601c              STR      r4,[r3,#0]
;;;1416     
;;;1417     /* Configure the Alarm A or Alarm B Sub Second registers */
;;;1418     tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
00055e  4311              ORRS     r1,r1,r2
;;;1419     
;;;1420     if (RTC_Alarm == RTC_Alarm_A)
000560  f5b07f80          CMP      r0,#0x100
000564  d005              BEQ      |L1.1394|
;;;1421     {
;;;1422       /* Configure the Alarm A Sub Second register */
;;;1423       RTC->ALRMASSR = tmpreg;
;;;1424     }
;;;1425     else
;;;1426     {
;;;1427       /* Configure the Alarm B Sub Second register */
;;;1428       RTC->ALRMBSSR = tmpreg;
000566  48b9              LDR      r0,|L1.2124|
000568  3024              ADDS     r0,r0,#0x24
                  |L1.1386|
00056a  6001              STR      r1,[r0,#0]
;;;1429     }
;;;1430   
;;;1431     /* Enable the write protection for RTC registers */
;;;1432     RTC->WPR = 0xFF;
00056c  20ff              MOVS     r0,#0xff
00056e  6018              STR      r0,[r3,#0]
;;;1433   
;;;1434   }
000570  bd10              POP      {r4,pc}
                  |L1.1394|
000572  48b6              LDR      r0,|L1.2124|
000574  3020              ADDS     r0,r0,#0x20           ;1423
000576  e7f8              B        |L1.1386|
;;;1435   
                          ENDP

                  RTC_GetAlarmSubSecond PROC
;;;1444     */
;;;1445   uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
000578  f5b07f80          CMP      r0,#0x100
;;;1446   {
00057c  d005              BEQ      |L1.1418|
;;;1447     uint32_t tmpreg = 0;
;;;1448     
;;;1449     /* Get the RTC_ALRMxR register */
;;;1450     if (RTC_Alarm == RTC_Alarm_A)
;;;1451     {
;;;1452       tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
;;;1453     }
;;;1454     else
;;;1455     {
;;;1456       tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
00057e  48b3              LDR      r0,|L1.2124|
000580  3024              ADDS     r0,r0,#0x24
                  |L1.1410|
000582  6800              LDR      r0,[r0,#0]            ;1452
000584  f3c0000e          UBFX     r0,r0,#0,#15          ;1452
;;;1457     } 
;;;1458     
;;;1459     return (tmpreg);
;;;1460   }
000588  4770              BX       lr
                  |L1.1418|
00058a  48b0              LDR      r0,|L1.2124|
00058c  3020              ADDS     r0,r0,#0x20           ;1452
00058e  e7f8              B        |L1.1410|
;;;1461   
                          ENDP

                  RTC_WakeUpClockConfig PROC
;;;1493     */
;;;1494   void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
000590  4aae              LDR      r2,|L1.2124|
;;;1495   {
;;;1496     /* Check the parameters */
;;;1497     assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
;;;1498   
;;;1499     /* Disable the write protection for RTC registers */
;;;1500     RTC->WPR = 0xCA;
000592  21ca              MOVS     r1,#0xca
000594  6011              STR      r1,[r2,#0]
;;;1501     RTC->WPR = 0x53;
000596  2153              MOVS     r1,#0x53
000598  6011              STR      r1,[r2,#0]
;;;1502   
;;;1503     /* Clear the Wakeup Timer clock source bits in CR register */
;;;1504     RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
00059a  49ac              LDR      r1,|L1.2124|
00059c  391c              SUBS     r1,r1,#0x1c
00059e  680b              LDR      r3,[r1,#0]
0005a0  f0230307          BIC      r3,r3,#7
0005a4  600b              STR      r3,[r1,#0]
;;;1505   
;;;1506     /* Configure the clock source */
;;;1507     RTC->CR |= (uint32_t)RTC_WakeUpClock;
0005a6  680b              LDR      r3,[r1,#0]
0005a8  4303              ORRS     r3,r3,r0
0005aa  600b              STR      r3,[r1,#0]
;;;1508     
;;;1509     /* Enable the write protection for RTC registers */
;;;1510     RTC->WPR = 0xFF; 
0005ac  20ff              MOVS     r0,#0xff
0005ae  6010              STR      r0,[r2,#0]
;;;1511   }
0005b0  4770              BX       lr
;;;1512   
                          ENDP

                  RTC_SetWakeUpCounter PROC
;;;1520     */
;;;1521   void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
0005b2  49a6              LDR      r1,|L1.2124|
;;;1522   {
;;;1523     /* Check the parameters */
;;;1524     assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
;;;1525     
;;;1526     /* Disable the write protection for RTC registers */
;;;1527     RTC->WPR = 0xCA;
0005b4  22ca              MOVS     r2,#0xca
0005b6  600a              STR      r2,[r1,#0]
;;;1528     RTC->WPR = 0x53;
0005b8  2253              MOVS     r2,#0x53
0005ba  600a              STR      r2,[r1,#0]
;;;1529     
;;;1530     /* Configure the Wakeup Timer counter */
;;;1531     RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
0005bc  4aa3              LDR      r2,|L1.2124|
0005be  3a10              SUBS     r2,r2,#0x10
0005c0  6010              STR      r0,[r2,#0]
;;;1532     
;;;1533     /* Enable the write protection for RTC registers */
;;;1534     RTC->WPR = 0xFF; 
0005c2  20ff              MOVS     r0,#0xff
0005c4  6008              STR      r0,[r1,#0]
;;;1535   }
0005c6  4770              BX       lr
;;;1536   
                          ENDP

                  RTC_GetWakeUpCounter PROC
;;;1541     */
;;;1542   uint32_t RTC_GetWakeUpCounter(void)
0005c8  48a0              LDR      r0,|L1.2124|
;;;1543   {
;;;1544     /* Get the counter value */
;;;1545     return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
0005ca  3810              SUBS     r0,r0,#0x10
0005cc  6800              LDR      r0,[r0,#0]
0005ce  b280              UXTH     r0,r0
;;;1546   }
0005d0  4770              BX       lr
;;;1547   
                          ENDP

                  RTC_WakeUpCmd PROC
;;;1553     */
;;;1554   ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
0005d2  b518              PUSH     {r3,r4,lr}
;;;1555   {
;;;1556     __IO uint32_t wutcounter = 0x00;
0005d4  2100              MOVS     r1,#0
;;;1557     uint32_t wutwfstatus = 0x00;
;;;1558     ErrorStatus status = ERROR;
;;;1559     
;;;1560     /* Check the parameters */
;;;1561     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1562   
;;;1563     /* Disable the write protection for RTC registers */
;;;1564     RTC->WPR = 0xCA;
0005d6  4b9d              LDR      r3,|L1.2124|
0005d8  9100              STR      r1,[sp,#0]
0005da  21ca              MOVS     r1,#0xca
0005dc  6019              STR      r1,[r3,#0]
;;;1565     RTC->WPR = 0x53;
0005de  2153              MOVS     r1,#0x53
0005e0  6019              STR      r1,[r3,#0]
;;;1566   
;;;1567     if (NewState != DISABLE)
;;;1568     {
;;;1569       /* Enable the Wakeup Timer */
;;;1570       RTC->CR |= (uint32_t)RTC_CR_WUTE;
0005e2  499a              LDR      r1,|L1.2124|
0005e4  391c              SUBS     r1,r1,#0x1c
0005e6  2800              CMP      r0,#0                 ;1567
;;;1571       status = SUCCESS;    
;;;1572     }
;;;1573     else
;;;1574     {
;;;1575       /* Disable the Wakeup Timer */
;;;1576       RTC->CR &= (uint32_t)~RTC_CR_WUTE;
0005e8  6808              LDR      r0,[r1,#0]
0005ea  d003              BEQ      |L1.1524|
0005ec  f4406080          ORR      r0,r0,#0x400          ;1570
0005f0  6008              STR      r0,[r1,#0]            ;1570
0005f2  e014              B        |L1.1566|
                  |L1.1524|
0005f4  f4206080          BIC      r0,r0,#0x400
0005f8  6008              STR      r0,[r1,#0]
;;;1577       /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;1578       do
;;;1579       {
;;;1580         wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
0005fa  4994              LDR      r1,|L1.2124|
0005fc  3918              SUBS     r1,r1,#0x18
;;;1581         wutcounter++;  
;;;1582       } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
0005fe  138c              ASRS     r4,r1,#14
                  |L1.1536|
000600  6808              LDR      r0,[r1,#0]            ;1580
000602  9a00              LDR      r2,[sp,#0]            ;1581
000604  f0000004          AND      r0,r0,#4              ;1580
000608  1c52              ADDS     r2,r2,#1              ;1581
00060a  9200              STR      r2,[sp,#0]
00060c  42a2              CMP      r2,r4
00060e  d001              BEQ      |L1.1556|
000610  2800              CMP      r0,#0
000612  d0f5              BEQ      |L1.1536|
                  |L1.1556|
;;;1583       
;;;1584       if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
000614  6808              LDR      r0,[r1,#0]
000616  0740              LSLS     r0,r0,#29
000618  d401              BMI      |L1.1566|
;;;1585       {
;;;1586         status = ERROR;
00061a  2000              MOVS     r0,#0
00061c  e000              B        |L1.1568|
                  |L1.1566|
;;;1587       }
;;;1588       else
;;;1589       {
;;;1590         status = SUCCESS;
00061e  2001              MOVS     r0,#1
                  |L1.1568|
;;;1591       }    
;;;1592     }
;;;1593   
;;;1594     /* Enable the write protection for RTC registers */
;;;1595     RTC->WPR = 0xFF; 
000620  21ff              MOVS     r1,#0xff
000622  6019              STR      r1,[r3,#0]
;;;1596     
;;;1597     return status;
;;;1598   }
000624  bd18              POP      {r3,r4,pc}
;;;1599   
                          ENDP

                  RTC_DayLightSavingConfig PROC
;;;1630     */
;;;1631   void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
000626  4b89              LDR      r3,|L1.2124|
;;;1632   {
000628  b510              PUSH     {r4,lr}
;;;1633     /* Check the parameters */
;;;1634     assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
;;;1635     assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
;;;1636   
;;;1637     /* Disable the write protection for RTC registers */
;;;1638     RTC->WPR = 0xCA;
00062a  22ca              MOVS     r2,#0xca
00062c  601a              STR      r2,[r3,#0]
;;;1639     RTC->WPR = 0x53;
00062e  2253              MOVS     r2,#0x53
000630  601a              STR      r2,[r3,#0]
;;;1640   
;;;1641     /* Clear the bits to be configured */
;;;1642     RTC->CR &= (uint32_t)~(RTC_CR_BCK);
000632  4a86              LDR      r2,|L1.2124|
000634  3a1c              SUBS     r2,r2,#0x1c
000636  6814              LDR      r4,[r2,#0]
000638  f4242480          BIC      r4,r4,#0x40000
00063c  6014              STR      r4,[r2,#0]
;;;1643   
;;;1644     /* Configure the RTC_CR register */
;;;1645     RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
00063e  6814              LDR      r4,[r2,#0]
000640  4308              ORRS     r0,r0,r1
000642  4304              ORRS     r4,r4,r0
000644  6014              STR      r4,[r2,#0]
;;;1646   
;;;1647     /* Enable the write protection for RTC registers */
;;;1648     RTC->WPR = 0xFF; 
000646  20ff              MOVS     r0,#0xff
000648  6018              STR      r0,[r3,#0]
;;;1649   }
00064a  bd10              POP      {r4,pc}
;;;1650   
                          ENDP

                  RTC_GetStoreOperation PROC
;;;1657     */
;;;1658   uint32_t RTC_GetStoreOperation(void)
00064c  487f              LDR      r0,|L1.2124|
;;;1659   {
;;;1660     return (RTC->CR & RTC_CR_BCK);
00064e  381c              SUBS     r0,r0,#0x1c
000650  6800              LDR      r0,[r0,#0]
000652  f4002080          AND      r0,r0,#0x40000
;;;1661   }
000656  4770              BX       lr
;;;1662   
                          ENDP

                  RTC_OutputConfig PROC
;;;1696     */
;;;1697   void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
000658  4b7c              LDR      r3,|L1.2124|
;;;1698   {
00065a  b510              PUSH     {r4,lr}
;;;1699     /* Check the parameters */
;;;1700     assert_param(IS_RTC_OUTPUT(RTC_Output));
;;;1701     assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
;;;1702   
;;;1703     /* Disable the write protection for RTC registers */
;;;1704     RTC->WPR = 0xCA;
00065c  22ca              MOVS     r2,#0xca
00065e  601a              STR      r2,[r3,#0]
;;;1705     RTC->WPR = 0x53;
000660  2253              MOVS     r2,#0x53
000662  601a              STR      r2,[r3,#0]
;;;1706   
;;;1707     /* Clear the bits to be configured */
;;;1708     RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
000664  4a79              LDR      r2,|L1.2124|
000666  3a1c              SUBS     r2,r2,#0x1c
000668  6814              LDR      r4,[r2,#0]
00066a  f42404e0          BIC      r4,r4,#0x700000
00066e  6014              STR      r4,[r2,#0]
;;;1709   
;;;1710     /* Configure the output selection and polarity */
;;;1711     RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
000670  6814              LDR      r4,[r2,#0]
000672  4308              ORRS     r0,r0,r1
000674  4304              ORRS     r4,r4,r0
000676  6014              STR      r4,[r2,#0]
;;;1712   
;;;1713     /* Enable the write protection for RTC registers */
;;;1714     RTC->WPR = 0xFF; 
000678  20ff              MOVS     r0,#0xff
00067a  6018              STR      r0,[r3,#0]
;;;1715   }
00067c  bd10              POP      {r4,pc}
;;;1716   
                          ENDP

                  RTC_CoarseCalibConfig PROC
;;;1750     */
;;;1751   ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
00067e  b5f0              PUSH     {r4-r7,lr}
;;;1752   {
;;;1753     ErrorStatus status = ERROR;
;;;1754      
;;;1755     /* Check the parameters */
;;;1756     assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
;;;1757     assert_param(IS_RTC_CALIB_VALUE(Value)); 
;;;1758   
;;;1759     /* Disable the write protection for RTC registers */
;;;1760     RTC->WPR = 0xCA;
000680  4d72              LDR      r5,|L1.2124|
000682  4606              MOV      r6,r0                 ;1752
000684  2400              MOVS     r4,#0                 ;1753
000686  20ca              MOVS     r0,#0xca
000688  460f              MOV      r7,r1                 ;1752
00068a  6028              STR      r0,[r5,#0]
;;;1761     RTC->WPR = 0x53;
00068c  2053              MOVS     r0,#0x53
00068e  6028              STR      r0,[r5,#0]
;;;1762   
;;;1763     /* Set Initialization mode */
;;;1764     if (RTC_EnterInitMode() == ERROR)
000690  f7fffffe          BL       RTC_EnterInitMode
000694  b130              CBZ      r0,|L1.1700|
;;;1765     {
;;;1766       status = ERROR;
;;;1767     } 
;;;1768     else
;;;1769     {
;;;1770       /* Set the coarse calibration value */
;;;1771       RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
000696  486d              LDR      r0,|L1.2124|
000698  433e              ORRS     r6,r6,r7
00069a  380c              SUBS     r0,r0,#0xc
00069c  6006              STR      r6,[r0,#0]
;;;1772       /* Exit Initialization mode */
;;;1773       RTC_ExitInitMode();
00069e  f7fffffe          BL       RTC_ExitInitMode
;;;1774       
;;;1775       status = SUCCESS;
0006a2  2401              MOVS     r4,#1
                  |L1.1700|
;;;1776     } 
;;;1777   
;;;1778     /* Enable the write protection for RTC registers */
;;;1779     RTC->WPR = 0xFF; 
0006a4  20ff              MOVS     r0,#0xff
0006a6  6028              STR      r0,[r5,#0]
;;;1780     
;;;1781     return status;
0006a8  4620              MOV      r0,r4
;;;1782   }
0006aa  bdf0              POP      {r4-r7,pc}
;;;1783   
                          ENDP

                  RTC_CoarseCalibCmd PROC
;;;1791     */
;;;1792   ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
0006ac  b570              PUSH     {r4-r6,lr}
;;;1793   {
;;;1794     ErrorStatus status = ERROR;
;;;1795     
;;;1796     /* Check the parameters */
;;;1797     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1798   
;;;1799     /* Disable the write protection for RTC registers */
;;;1800     RTC->WPR = 0xCA;
0006ae  4e67              LDR      r6,|L1.2124|
0006b0  4605              MOV      r5,r0                 ;1793
0006b2  2400              MOVS     r4,#0                 ;1794
0006b4  20ca              MOVS     r0,#0xca
0006b6  6030              STR      r0,[r6,#0]
;;;1801     RTC->WPR = 0x53;
0006b8  2053              MOVS     r0,#0x53
0006ba  6030              STR      r0,[r6,#0]
;;;1802     
;;;1803     /* Set Initialization mode */
;;;1804     if (RTC_EnterInitMode() == ERROR)
0006bc  f7fffffe          BL       RTC_EnterInitMode
0006c0  b160              CBZ      r0,|L1.1756|
;;;1805     {
;;;1806       status =  ERROR;
;;;1807     }
;;;1808     else
;;;1809     {
;;;1810       if (NewState != DISABLE)
;;;1811       {
;;;1812         /* Enable the Coarse Calibration */
;;;1813         RTC->CR |= (uint32_t)RTC_CR_DCE;
0006c2  4862              LDR      r0,|L1.2124|
0006c4  381c              SUBS     r0,r0,#0x1c
;;;1814       }
;;;1815       else
;;;1816       { 
;;;1817         /* Disable the Coarse Calibration */
;;;1818         RTC->CR &= (uint32_t)~RTC_CR_DCE;
0006c6  6801              LDR      r1,[r0,#0]
0006c8  b115              CBZ      r5,|L1.1744|
0006ca  f0410180          ORR      r1,r1,#0x80           ;1813
0006ce  e001              B        |L1.1748|
                  |L1.1744|
0006d0  f0210180          BIC      r1,r1,#0x80
                  |L1.1748|
0006d4  6001              STR      r1,[r0,#0]
;;;1819       }
;;;1820       /* Exit Initialization mode */
;;;1821       RTC_ExitInitMode();
0006d6  f7fffffe          BL       RTC_ExitInitMode
;;;1822       
;;;1823       status = SUCCESS;
0006da  2401              MOVS     r4,#1
                  |L1.1756|
;;;1824     } 
;;;1825     
;;;1826     /* Enable the write protection for RTC registers */
;;;1827     RTC->WPR = 0xFF; 
0006dc  20ff              MOVS     r0,#0xff
0006de  6030              STR      r0,[r6,#0]
;;;1828     
;;;1829     return status;
0006e0  4620              MOV      r0,r4
;;;1830   }
0006e2  bd70              POP      {r4-r6,pc}
;;;1831   
                          ENDP

                  RTC_CalibOutputCmd PROC
;;;1837     */
;;;1838   void RTC_CalibOutputCmd(FunctionalState NewState)
0006e4  4a59              LDR      r2,|L1.2124|
;;;1839   {
;;;1840     /* Check the parameters */
;;;1841     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1842     
;;;1843     /* Disable the write protection for RTC registers */
;;;1844     RTC->WPR = 0xCA;
0006e6  21ca              MOVS     r1,#0xca
0006e8  6011              STR      r1,[r2,#0]
;;;1845     RTC->WPR = 0x53;
0006ea  2153              MOVS     r1,#0x53
0006ec  6011              STR      r1,[r2,#0]
;;;1846     
;;;1847     if (NewState != DISABLE)
;;;1848     {
;;;1849       /* Enable the RTC clock output */
;;;1850       RTC->CR |= (uint32_t)RTC_CR_COE;
0006ee  4957              LDR      r1,|L1.2124|
0006f0  391c              SUBS     r1,r1,#0x1c
0006f2  2800              CMP      r0,#0                 ;1847
;;;1851     }
;;;1852     else
;;;1853     { 
;;;1854       /* Disable the RTC clock output */
;;;1855       RTC->CR &= (uint32_t)~RTC_CR_COE;
0006f4  6808              LDR      r0,[r1,#0]
0006f6  d002              BEQ      |L1.1790|
0006f8  f4400000          ORR      r0,r0,#0x800000       ;1850
0006fc  e001              B        |L1.1794|
                  |L1.1790|
0006fe  f4200000          BIC      r0,r0,#0x800000
                  |L1.1794|
000702  6008              STR      r0,[r1,#0]
;;;1856     }
;;;1857     
;;;1858     /* Enable the write protection for RTC registers */
;;;1859     RTC->WPR = 0xFF; 
000704  20ff              MOVS     r0,#0xff
000706  6010              STR      r0,[r2,#0]
;;;1860   }
000708  4770              BX       lr
;;;1861   
                          ENDP

                  RTC_CalibOutputConfig PROC
;;;1869   */
;;;1870   void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
00070a  4a50              LDR      r2,|L1.2124|
;;;1871   {
;;;1872     /* Check the parameters */
;;;1873     assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
;;;1874   
;;;1875     /* Disable the write protection for RTC registers */
;;;1876     RTC->WPR = 0xCA;
00070c  21ca              MOVS     r1,#0xca
00070e  6011              STR      r1,[r2,#0]
;;;1877     RTC->WPR = 0x53;
000710  2153              MOVS     r1,#0x53
000712  6011              STR      r1,[r2,#0]
;;;1878     
;;;1879     /*clear flags before configuration */
;;;1880     RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
000714  494d              LDR      r1,|L1.2124|
000716  391c              SUBS     r1,r1,#0x1c
000718  680b              LDR      r3,[r1,#0]
00071a  f4232300          BIC      r3,r3,#0x80000
00071e  600b              STR      r3,[r1,#0]
;;;1881   
;;;1882     /* Configure the RTC_CR register */
;;;1883     RTC->CR |= (uint32_t)RTC_CalibOutput;
000720  680b              LDR      r3,[r1,#0]
000722  4303              ORRS     r3,r3,r0
000724  600b              STR      r3,[r1,#0]
;;;1884   
;;;1885     /* Enable the write protection for RTC registers */
;;;1886     RTC->WPR = 0xFF;
000726  20ff              MOVS     r0,#0xff
000728  6010              STR      r0,[r2,#0]
;;;1887   }
00072a  4770              BX       lr
;;;1888   
                          ENDP

                  RTC_SmoothCalibConfig PROC
;;;1905   */
;;;1906   ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
00072c  b5f0              PUSH     {r4-r7,lr}
;;;1907                                     uint32_t RTC_SmoothCalibPlusPulses,
;;;1908                                     uint32_t RTC_SmouthCalibMinusPulsesValue)
;;;1909   {
;;;1910     ErrorStatus status = ERROR;
;;;1911     uint32_t recalpfcount = 0;
;;;1912   
;;;1913     /* Check the parameters */
;;;1914     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
;;;1915     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
;;;1916     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
;;;1917   
;;;1918     /* Disable the write protection for RTC registers */
;;;1919     RTC->WPR = 0xCA;
00072e  4d47              LDR      r5,|L1.2124|
000730  2300              MOVS     r3,#0                 ;1911
000732  24ca              MOVS     r4,#0xca
000734  602c              STR      r4,[r5,#0]
;;;1920     RTC->WPR = 0x53;
000736  2453              MOVS     r4,#0x53
000738  602c              STR      r4,[r5,#0]
;;;1921     
;;;1922     /* check if a calibration is pending*/
;;;1923     if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
00073a  4c44              LDR      r4,|L1.2124|
00073c  3c18              SUBS     r4,r4,#0x18
00073e  6826              LDR      r6,[r4,#0]
000740  03f6              LSLS     r6,r6,#15
000742  d508              BPL      |L1.1878|
;;;1924     {
;;;1925       /* wait until the Calibration is completed*/
;;;1926       while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
000744  f44f3600          MOV      r6,#0x20000
                  |L1.1864|
000748  6827              LDR      r7,[r4,#0]
00074a  03ff              LSLS     r7,r7,#15
00074c  d503              BPL      |L1.1878|
00074e  42b3              CMP      r3,r6
000750  d001              BEQ      |L1.1878|
000752  1c5b              ADDS     r3,r3,#1
;;;1927       {
;;;1928         recalpfcount++;
000754  e7f8              B        |L1.1864|
                  |L1.1878|
;;;1929       }
;;;1930     }
;;;1931   
;;;1932     /* check if the calibration pending is completed or if there is no calibration operation at all*/
;;;1933     if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
000756  6823              LDR      r3,[r4,#0]
000758  03db              LSLS     r3,r3,#15
00075a  d406              BMI      |L1.1898|
;;;1934     {
;;;1935       /* Configure the Smooth calibration settings */
;;;1936       RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
00075c  4308              ORRS     r0,r0,r1
00075e  493b              LDR      r1,|L1.2124|
000760  4310              ORRS     r0,r0,r2
000762  3118              ADDS     r1,r1,#0x18
000764  6008              STR      r0,[r1,#0]
;;;1937   
;;;1938       status = SUCCESS;
000766  2001              MOVS     r0,#1
000768  e000              B        |L1.1900|
                  |L1.1898|
;;;1939     }
;;;1940     else
;;;1941     {
;;;1942       status = ERROR;
00076a  2000              MOVS     r0,#0
                  |L1.1900|
;;;1943     }
;;;1944   
;;;1945     /* Enable the write protection for RTC registers */
;;;1946     RTC->WPR = 0xFF;
00076c  21ff              MOVS     r1,#0xff
00076e  6029              STR      r1,[r5,#0]
;;;1947     
;;;1948     return (ErrorStatus)(status);
;;;1949   }
000770  bdf0              POP      {r4-r7,pc}
;;;1950   
                          ENDP

                  RTC_TimeStampCmd PROC
;;;1981     */
;;;1982   void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
000772  4b36              LDR      r3,|L1.2124|
;;;1983   {
000774  b510              PUSH     {r4,lr}
;;;1984     uint32_t tmpreg = 0;
;;;1985   
;;;1986     /* Check the parameters */
;;;1987     assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
;;;1988     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1989   
;;;1990     /* Get the RTC_CR register and clear the bits to be configured */
;;;1991     tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000776  3b1c              SUBS     r3,r3,#0x1c
000778  681a              LDR      r2,[r3,#0]
00077a  f6400408          MOV      r4,#0x808
00077e  43a2              BICS     r2,r2,r4
;;;1992   
;;;1993     /* Get the new configuration */
;;;1994     if (NewState != DISABLE)
;;;1995     {
;;;1996       tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
;;;1997     }
;;;1998     else
;;;1999     {
;;;2000       tmpreg |= (uint32_t)(RTC_TimeStampEdge);
000780  ea420200          ORR      r2,r2,r0
000784  b109              CBZ      r1,|L1.1930|
000786  f4426200          ORR      r2,r2,#0x800          ;1996
                  |L1.1930|
;;;2001     }
;;;2002   
;;;2003     /* Disable the write protection for RTC registers */
;;;2004     RTC->WPR = 0xCA;
00078a  4830              LDR      r0,|L1.2124|
00078c  21ca              MOVS     r1,#0xca
00078e  6001              STR      r1,[r0,#0]
;;;2005     RTC->WPR = 0x53;
000790  2153              MOVS     r1,#0x53
000792  6001              STR      r1,[r0,#0]
;;;2006   
;;;2007     /* Configure the Time Stamp TSEDGE and Enable bits */
;;;2008     RTC->CR = (uint32_t)tmpreg;
000794  601a              STR      r2,[r3,#0]
;;;2009   
;;;2010     /* Enable the write protection for RTC registers */
;;;2011     RTC->WPR = 0xFF; 
000796  21ff              MOVS     r1,#0xff
000798  6001              STR      r1,[r0,#0]
;;;2012   }
00079a  bd10              POP      {r4,pc}
;;;2013   
                          ENDP

                  RTC_GetTimeStamp PROC
;;;2025     */
;;;2026   void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
00079c  b570              PUSH     {r4-r6,lr}
;;;2027                                         RTC_DateTypeDef* RTC_StampDateStruct)
;;;2028   {
00079e  460d              MOV      r5,r1
;;;2029     uint32_t tmptime = 0, tmpdate = 0;
;;;2030   
;;;2031     /* Check the parameters */
;;;2032     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;2033   
;;;2034     /* Get the TimeStamp time and date registers values */
;;;2035     tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
0007a0  492a              LDR      r1,|L1.2124|
0007a2  4614              MOV      r4,r2                 ;2028
0007a4  310c              ADDS     r1,r1,#0xc
0007a6  6809              LDR      r1,[r1,#0]
0007a8  4a29              LDR      r2,|L1.2128|
0007aa  4011              ANDS     r1,r1,r2
;;;2036     tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
0007ac  4a27              LDR      r2,|L1.2124|
0007ae  3210              ADDS     r2,r2,#0x10
0007b0  6812              LDR      r2,[r2,#0]
0007b2  f64f733f          MOV      r3,#0xff3f
0007b6  401a              ANDS     r2,r2,r3
;;;2037   
;;;2038     /* Fill the Time structure fields with the read parameters */
;;;2039     RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
0007b8  f3c14305          UBFX     r3,r1,#16,#6
0007bc  702b              STRB     r3,[r5,#0]
;;;2040     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
0007be  f3c12306          UBFX     r3,r1,#8,#7
0007c2  706b              STRB     r3,[r5,#1]
;;;2041     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
0007c4  f001037f          AND      r3,r1,#0x7f
0007c8  70ab              STRB     r3,[r5,#2]
;;;2042     RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
0007ca  2340              MOVS     r3,#0x40
0007cc  ea034111          AND      r1,r3,r1,LSR #16
0007d0  70e9              STRB     r1,[r5,#3]
;;;2043   
;;;2044     /* Fill the Date structure fields with the read parameters */
;;;2045     RTC_StampDateStruct->RTC_Year = 0;
0007d2  2100              MOVS     r1,#0
0007d4  70e1              STRB     r1,[r4,#3]
;;;2046     RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
0007d6  f3c22104          UBFX     r1,r2,#8,#5
0007da  7061              STRB     r1,[r4,#1]
;;;2047     RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
0007dc  f002013f          AND      r1,r2,#0x3f
0007e0  70a1              STRB     r1,[r4,#2]
;;;2048     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
0007e2  f3c23142          UBFX     r1,r2,#13,#3
0007e6  7021              STRB     r1,[r4,#0]
0007e8  2800              CMP      r0,#0                 ;2028
0007ea  d117              BNE      |L1.2076|
;;;2049   
;;;2050     /* Check the input parameters format */
;;;2051     if (RTC_Format == RTC_Format_BIN)
;;;2052     {
;;;2053       /* Convert the Time structure parameters to Binary format */
;;;2054       RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
0007ec  7828              LDRB     r0,[r5,#0]
0007ee  f7fffffe          BL       RTC_Bcd2ToByte
0007f2  7028              STRB     r0,[r5,#0]
;;;2055       RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
0007f4  7868              LDRB     r0,[r5,#1]
0007f6  f7fffffe          BL       RTC_Bcd2ToByte
0007fa  7068              STRB     r0,[r5,#1]
;;;2056       RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
0007fc  78a8              LDRB     r0,[r5,#2]
0007fe  f7fffffe          BL       RTC_Bcd2ToByte
000802  70a8              STRB     r0,[r5,#2]
;;;2057   
;;;2058       /* Convert the Date structure parameters to Binary format */
;;;2059       RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
000804  7860              LDRB     r0,[r4,#1]
000806  f7fffffe          BL       RTC_Bcd2ToByte
00080a  7060              STRB     r0,[r4,#1]
;;;2060       RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
00080c  78a0              LDRB     r0,[r4,#2]
00080e  f7fffffe          BL       RTC_Bcd2ToByte
000812  70a0              STRB     r0,[r4,#2]
;;;2061       RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
000814  7820              LDRB     r0,[r4,#0]
000816  f7fffffe          BL       RTC_Bcd2ToByte
00081a  7020              STRB     r0,[r4,#0]
                  |L1.2076|
;;;2062     }
;;;2063   }
00081c  bd70              POP      {r4-r6,pc}
;;;2064   
                          ENDP

                  RTC_GetTimeStampSubSecond PROC
;;;2069     */
;;;2070   uint32_t RTC_GetTimeStampSubSecond(void)
00081e  480b              LDR      r0,|L1.2124|
;;;2071   {
;;;2072     /* Get timestamp sub seconds values from the correspondent registers */
;;;2073     return (uint32_t)(RTC->TSSSR);
000820  3014              ADDS     r0,r0,#0x14
000822  6800              LDR      r0,[r0,#0]
;;;2074   }
000824  4770              BX       lr
;;;2075   
                          ENDP

                  RTC_TamperTriggerConfig PROC
;;;2104     */
;;;2105   void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
000826  4a09              LDR      r2,|L1.2124|
;;;2106   {
;;;2107     /* Check the parameters */
;;;2108     assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
;;;2109     assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
;;;2110    
;;;2111     if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
;;;2112     {  
;;;2113       /* Configure the RTC_TAFCR register */
;;;2114       RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
000828  321c              ADDS     r2,r2,#0x1c
00082a  2900              CMP      r1,#0                 ;2111
;;;2115     }
;;;2116     else
;;;2117     { 
;;;2118       /* Configure the RTC_TAFCR register */
;;;2119       RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
00082c  6811              LDR      r1,[r2,#0]
00082e  d003              BEQ      |L1.2104|
000830  ea410040          ORR      r0,r1,r0,LSL #1
                  |L1.2100|
000834  6010              STR      r0,[r2,#0]            ;2114
;;;2120     }  
;;;2121   }
000836  4770              BX       lr
                  |L1.2104|
000838  ea210040          BIC      r0,r1,r0,LSL #1       ;2114
00083c  e7fa              B        |L1.2100|
;;;2122   
                          ENDP

                  RTC_TamperCmd PROC
;;;2130     */
;;;2131   void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
00083e  4a03              LDR      r2,|L1.2124|
;;;2132   {
;;;2133     /* Check the parameters */
;;;2134     assert_param(IS_RTC_TAMPER(RTC_Tamper));  
;;;2135     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2136     
;;;2137     if (NewState != DISABLE)
;;;2138     {
;;;2139       /* Enable the selected Tamper pin */
;;;2140       RTC->TAFCR |= (uint32_t)RTC_Tamper;
000840  321c              ADDS     r2,r2,#0x1c
000842  2900              CMP      r1,#0                 ;2137
;;;2141     }
;;;2142     else
;;;2143     {
;;;2144       /* Disable the selected Tamper pin */
;;;2145       RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
000844  6811              LDR      r1,[r2,#0]
000846  d005              BEQ      |L1.2132|
000848  4301              ORRS     r1,r1,r0              ;2140
00084a  e004              B        |L1.2134|
                  |L1.2124|
                          DCD      0x40002824
                  |L1.2128|
                          DCD      0x007f7f7f
                  |L1.2132|
000854  4381              BICS     r1,r1,r0
                  |L1.2134|
000856  6011              STR      r1,[r2,#0]            ;2140
;;;2146     }  
;;;2147   }
000858  4770              BX       lr
;;;2148   
                          ENDP

                  RTC_TamperFilterConfig PROC
;;;2161     */
;;;2162   void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
00085a  4979              LDR      r1,|L1.2624|
;;;2163   {
;;;2164     /* Check the parameters */
;;;2165     assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
;;;2166      
;;;2167     /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
;;;2168     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
00085c  680a              LDR      r2,[r1,#0]
00085e  f42252c0          BIC      r2,r2,#0x1800
000862  600a              STR      r2,[r1,#0]
;;;2169   
;;;2170     /* Configure the RTC_TAFCR register */
;;;2171     RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
000864  680a              LDR      r2,[r1,#0]
000866  4302              ORRS     r2,r2,r0
000868  600a              STR      r2,[r1,#0]
;;;2172   }
00086a  4770              BX       lr
;;;2173   
                          ENDP

                  RTC_TamperSamplingFreqConfig PROC
;;;2195     */
;;;2196   void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
00086c  4974              LDR      r1,|L1.2624|
;;;2197   {
;;;2198     /* Check the parameters */
;;;2199     assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
;;;2200    
;;;2201     /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
;;;2202     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
00086e  680a              LDR      r2,[r1,#0]
000870  f42262e0          BIC      r2,r2,#0x700
000874  600a              STR      r2,[r1,#0]
;;;2203   
;;;2204     /* Configure the RTC_TAFCR register */
;;;2205     RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
000876  680a              LDR      r2,[r1,#0]
000878  4302              ORRS     r2,r2,r0
00087a  600a              STR      r2,[r1,#0]
;;;2206   }
00087c  4770              BX       lr
;;;2207   
                          ENDP

                  RTC_TamperPinsPrechargeDuration PROC
;;;2218     */
;;;2219   void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
00087e  4970              LDR      r1,|L1.2624|
;;;2220   {
;;;2221     /* Check the parameters */
;;;2222     assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
;;;2223      
;;;2224     /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
;;;2225     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
000880  680a              LDR      r2,[r1,#0]
000882  f42242c0          BIC      r2,r2,#0x6000
000886  600a              STR      r2,[r1,#0]
;;;2226   
;;;2227     /* Configure the RTC_TAFCR register */
;;;2228     RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
000888  680a              LDR      r2,[r1,#0]
00088a  4302              ORRS     r2,r2,r0
00088c  600a              STR      r2,[r1,#0]
;;;2229   }
00088e  4770              BX       lr
;;;2230   
                          ENDP

                  RTC_TimeStampOnTamperDetectionCmd PROC
;;;2238     */
;;;2239   void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
000890  496b              LDR      r1,|L1.2624|
;;;2240   {
;;;2241     /* Check the parameters */
;;;2242     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2243      
;;;2244     if (NewState != DISABLE)
000892  2800              CMP      r0,#0
;;;2245     {
;;;2246       /* Save timestamp on tamper detection event */
;;;2247       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
;;;2248     }
;;;2249     else
;;;2250     {
;;;2251       /* Tamper detection does not cause a timestamp to be saved */
;;;2252       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
000894  6808              LDR      r0,[r1,#0]
000896  d002              BEQ      |L1.2206|
000898  f0400080          ORR      r0,r0,#0x80           ;2247
00089c  e001              B        |L1.2210|
                  |L1.2206|
00089e  f0200080          BIC      r0,r0,#0x80
                  |L1.2210|
0008a2  6008              STR      r0,[r1,#0]            ;2247
;;;2253     }
;;;2254   }
0008a4  4770              BX       lr
;;;2255   
                          ENDP

                  RTC_TamperPullUpCmd PROC
;;;2261     */
;;;2262   void RTC_TamperPullUpCmd(FunctionalState NewState)
0008a6  4966              LDR      r1,|L1.2624|
;;;2263   {
;;;2264     /* Check the parameters */
;;;2265     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2266     
;;;2267    if (NewState != DISABLE)
0008a8  2800              CMP      r0,#0
;;;2268     {
;;;2269       /* Enable precharge of the selected Tamper pin */
;;;2270       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
;;;2271     }
;;;2272     else
;;;2273     {
;;;2274       /* Disable precharge of the selected Tamper pin */
;;;2275       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
0008aa  6808              LDR      r0,[r1,#0]
0008ac  d002              BEQ      |L1.2228|
0008ae  f4204000          BIC      r0,r0,#0x8000         ;2270
0008b2  e001              B        |L1.2232|
                  |L1.2228|
0008b4  f4404000          ORR      r0,r0,#0x8000
                  |L1.2232|
0008b8  6008              STR      r0,[r1,#0]            ;2270
;;;2276     } 
;;;2277   }
0008ba  4770              BX       lr
;;;2278   
                          ENDP

                  RTC_WriteBackupRegister PROC
;;;2302     */
;;;2303   void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
0008bc  4a60              LDR      r2,|L1.2624|
;;;2304   {
0008be  b508              PUSH     {r3,lr}
;;;2305     __IO uint32_t tmp = 0;
;;;2306     
;;;2307     /* Check the parameters */
;;;2308     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2309   
;;;2310     tmp = RTC_BASE + 0x50;
0008c0  3210              ADDS     r2,r2,#0x10
;;;2311     tmp += (RTC_BKP_DR * 4);
0008c2  eb020080          ADD      r0,r2,r0,LSL #2
;;;2312   
;;;2313     /* Write the specified register */
;;;2314     *(__IO uint32_t *)tmp = (uint32_t)Data;
0008c6  9000              STR      r0,[sp,#0]
0008c8  6001              STR      r1,[r0,#0]
;;;2315   }
0008ca  bd08              POP      {r3,pc}
;;;2316   
                          ENDP

                  RTC_ReadBackupRegister PROC
;;;2323     */
;;;2324   uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
0008cc  495c              LDR      r1,|L1.2624|
;;;2325   {
0008ce  b508              PUSH     {r3,lr}
;;;2326     __IO uint32_t tmp = 0;
;;;2327     
;;;2328     /* Check the parameters */
;;;2329     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2330   
;;;2331     tmp = RTC_BASE + 0x50;
0008d0  3110              ADDS     r1,r1,#0x10
;;;2332     tmp += (RTC_BKP_DR * 4);
0008d2  eb010080          ADD      r0,r1,r0,LSL #2
;;;2333     
;;;2334     /* Read the specified register */
;;;2335     return (*(__IO uint32_t *)tmp);
0008d6  9000              STR      r0,[sp,#0]
0008d8  6800              LDR      r0,[r0,#0]
;;;2336   }
0008da  bd08              POP      {r3,pc}
;;;2337   
                          ENDP

                  RTC_TamperPinSelection PROC
;;;2362     */
;;;2363   void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
0008dc  4958              LDR      r1,|L1.2624|
;;;2364   {
;;;2365     /* Check the parameters */
;;;2366     assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
;;;2367     
;;;2368     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
0008de  680a              LDR      r2,[r1,#0]
0008e0  f4223280          BIC      r2,r2,#0x10000
0008e4  600a              STR      r2,[r1,#0]
;;;2369     RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
0008e6  680a              LDR      r2,[r1,#0]
0008e8  4302              ORRS     r2,r2,r0
0008ea  600a              STR      r2,[r1,#0]
;;;2370   }
0008ec  4770              BX       lr
;;;2371   
                          ENDP

                  RTC_TimeStampPinSelection PROC
;;;2379     */
;;;2380   void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
0008ee  4954              LDR      r1,|L1.2624|
;;;2381   {
;;;2382     /* Check the parameters */
;;;2383     assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;2384     
;;;2385     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
0008f0  680a              LDR      r2,[r1,#0]
0008f2  f4223200          BIC      r2,r2,#0x20000
0008f6  600a              STR      r2,[r1,#0]
;;;2386     RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
0008f8  680a              LDR      r2,[r1,#0]
0008fa  4302              ORRS     r2,r2,r0
0008fc  600a              STR      r2,[r1,#0]
;;;2387   }
0008fe  4770              BX       lr
;;;2388   
                          ENDP

                  RTC_OutputTypeConfig PROC
;;;2398     */
;;;2399   void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
000900  494f              LDR      r1,|L1.2624|
;;;2400   {
;;;2401     /* Check the parameters */
;;;2402     assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
;;;2403     
;;;2404     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
000902  680a              LDR      r2,[r1,#0]
000904  f4222280          BIC      r2,r2,#0x40000
000908  600a              STR      r2,[r1,#0]
;;;2405     RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
00090a  680a              LDR      r2,[r1,#0]
00090c  4302              ORRS     r2,r2,r0
00090e  600a              STR      r2,[r1,#0]
;;;2406   }
000910  4770              BX       lr
;;;2407   
                          ENDP

                  RTC_SynchroShiftConfig PROC
;;;2436   */
;;;2437   ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
000912  b570              PUSH     {r4-r6,lr}
;;;2438   {
;;;2439     ErrorStatus status = ERROR;
;;;2440     uint32_t shpfcount = 0;
;;;2441   
;;;2442     /* Check the parameters */
;;;2443     assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
;;;2444     assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
;;;2445   
;;;2446     /* Disable the write protection for RTC registers */
;;;2447     RTC->WPR = 0xCA;
000914  4c4a              LDR      r4,|L1.2624|
000916  2200              MOVS     r2,#0                 ;2440
000918  23ca              MOVS     r3,#0xca
00091a  3c1c              SUBS     r4,r4,#0x1c
00091c  6023              STR      r3,[r4,#0]
;;;2448     RTC->WPR = 0x53;
00091e  2353              MOVS     r3,#0x53
000920  6023              STR      r3,[r4,#0]
;;;2449     
;;;2450     /* Check if a Shift is pending*/
;;;2451     if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
000922  4b47              LDR      r3,|L1.2624|
000924  3b34              SUBS     r3,r3,#0x34
000926  681d              LDR      r5,[r3,#0]
000928  072d              LSLS     r5,r5,#28
00092a  d507              BPL      |L1.2364|
;;;2452     {
;;;2453       /* Wait until the shift is completed*/
;;;2454       while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
00092c  149e              ASRS     r6,r3,#18
                  |L1.2350|
00092e  681d              LDR      r5,[r3,#0]
000930  072d              LSLS     r5,r5,#28
000932  d503              BPL      |L1.2364|
000934  42b2              CMP      r2,r6
000936  d001              BEQ      |L1.2364|
000938  1c52              ADDS     r2,r2,#1
;;;2455       {
;;;2456         shpfcount++;
00093a  e7f8              B        |L1.2350|
                  |L1.2364|
;;;2457       }
;;;2458     }
;;;2459   
;;;2460     /* Check if the Shift pending is completed or if there is no Shift operation at all*/
;;;2461     if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
00093c  681a              LDR      r2,[r3,#0]
00093e  0712              LSLS     r2,r2,#28
000940  d40d              BMI      |L1.2398|
;;;2462     {
;;;2463       /* check if the reference clock detection is disabled */
;;;2464       if((RTC->CR & RTC_CR_REFCKON) == RESET)
000942  4a3f              LDR      r2,|L1.2624|
000944  3a38              SUBS     r2,r2,#0x38
000946  6812              LDR      r2,[r2,#0]
000948  06d2              LSLS     r2,r2,#27
00094a  d408              BMI      |L1.2398|
;;;2465       {
;;;2466         /* Configure the Shift settings */
;;;2467         RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
00094c  4301              ORRS     r1,r1,r0
00094e  483c              LDR      r0,|L1.2624|
000950  3814              SUBS     r0,r0,#0x14
000952  6001              STR      r1,[r0,#0]
;;;2468       
;;;2469         if(RTC_WaitForSynchro() == ERROR)
000954  f7fffffe          BL       RTC_WaitForSynchro
000958  b110              CBZ      r0,|L1.2400|
;;;2470         {
;;;2471           status = ERROR;
;;;2472         }
;;;2473         else
;;;2474         {
;;;2475           status = SUCCESS;
00095a  2001              MOVS     r0,#1
00095c  e000              B        |L1.2400|
                  |L1.2398|
;;;2476         }
;;;2477       }
;;;2478       else
;;;2479       {
;;;2480         status = ERROR;
00095e  2000              MOVS     r0,#0
                  |L1.2400|
;;;2481       }
;;;2482     }
;;;2483     else
;;;2484     {
;;;2485       status = ERROR;
;;;2486     }
;;;2487   
;;;2488     /* Enable the write protection for RTC registers */
;;;2489     RTC->WPR = 0xFF;
000960  21ff              MOVS     r1,#0xff
000962  6021              STR      r1,[r4,#0]
;;;2490     
;;;2491     return (ErrorStatus)(status);
;;;2492   }
000964  bd70              POP      {r4-r6,pc}
;;;2493   
                          ENDP

                  RTC_ITConfig PROC
;;;2556     */
;;;2557   void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
000966  b530              PUSH     {r4,r5,lr}
;;;2558   {
;;;2559     /* Check the parameters */
;;;2560     assert_param(IS_RTC_CONFIG_IT(RTC_IT));
;;;2561     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2562   
;;;2563     /* Disable the write protection for RTC registers */
;;;2564     RTC->WPR = 0xCA;
000968  4d35              LDR      r5,|L1.2624|
00096a  22ca              MOVS     r2,#0xca
00096c  3d1c              SUBS     r5,r5,#0x1c
00096e  602a              STR      r2,[r5,#0]
;;;2565     RTC->WPR = 0x53;
000970  2253              MOVS     r2,#0x53
000972  602a              STR      r2,[r5,#0]
;;;2566   
;;;2567     if (NewState != DISABLE)
;;;2568     {
;;;2569       /* Configure the Interrupts in the RTC_CR register */
;;;2570       RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
000974  4c32              LDR      r4,|L1.2624|
000976  f0200204          BIC      r2,r0,#4
00097a  3c38              SUBS     r4,r4,#0x38
00097c  2900              CMP      r1,#0                 ;2567
;;;2571       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2572       RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
00097e  4b30              LDR      r3,|L1.2624|
;;;2573     }
;;;2574     else
;;;2575     {
;;;2576       /* Configure the Interrupts in the RTC_CR register */
;;;2577       RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
000980  6821              LDR      r1,[r4,#0]
000982  f0000004          AND      r0,r0,#4              ;2572
000986  d004              BEQ      |L1.2450|
000988  4311              ORRS     r1,r1,r2              ;2570
00098a  6021              STR      r1,[r4,#0]            ;2570
00098c  6819              LDR      r1,[r3,#0]            ;2572
00098e  4301              ORRS     r1,r1,r0              ;2572
000990  e003              B        |L1.2458|
                  |L1.2450|
000992  4391              BICS     r1,r1,r2
000994  6021              STR      r1,[r4,#0]
;;;2578       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2579       RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
000996  6819              LDR      r1,[r3,#0]
000998  4381              BICS     r1,r1,r0
                  |L1.2458|
00099a  6019              STR      r1,[r3,#0]
;;;2580     }
;;;2581     /* Enable the write protection for RTC registers */
;;;2582     RTC->WPR = 0xFF; 
00099c  20ff              MOVS     r0,#0xff
00099e  6028              STR      r0,[r5,#0]
;;;2583   }
0009a0  bd30              POP      {r4,r5,pc}
;;;2584   
                          ENDP

                  RTC_GetFlagStatus PROC
;;;2604     */
;;;2605   FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
0009a2  4602              MOV      r2,r0
;;;2606   {
;;;2607     FlagStatus bitstatus = RESET;
;;;2608     uint32_t tmpreg = 0;
;;;2609     
;;;2610     /* Check the parameters */
;;;2611     assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
;;;2612     
;;;2613     /* Get all the flags */
;;;2614     tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
0009a4  4926              LDR      r1,|L1.2624|
0009a6  2000              MOVS     r0,#0                 ;2607
0009a8  3934              SUBS     r1,r1,#0x34
0009aa  6809              LDR      r1,[r1,#0]
0009ac  4b25              LDR      r3,|L1.2628|
0009ae  4019              ANDS     r1,r1,r3
;;;2615     
;;;2616     /* Return the status of the flag */
;;;2617     if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
0009b0  4211              TST      r1,r2
0009b2  d000              BEQ      |L1.2486|
;;;2618     {
;;;2619       bitstatus = SET;
0009b4  2001              MOVS     r0,#1
                  |L1.2486|
;;;2620     }
;;;2621     else
;;;2622     {
;;;2623       bitstatus = RESET;
;;;2624     }
;;;2625     return bitstatus;
;;;2626   }
0009b6  4770              BX       lr
;;;2627   
                          ENDP

                  RTC_ClearFlag PROC
;;;2640     */
;;;2641   void RTC_ClearFlag(uint32_t RTC_FLAG)
0009b8  b280              UXTH     r0,r0
;;;2642   {
;;;2643     /* Check the parameters */
;;;2644     assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
;;;2645   
;;;2646     /* Clear the Flags in the RTC_ISR register */
;;;2647     RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
0009ba  f0400080          ORR      r0,r0,#0x80
0009be  43c1              MVNS     r1,r0
0009c0  481f              LDR      r0,|L1.2624|
0009c2  3834              SUBS     r0,r0,#0x34
0009c4  6802              LDR      r2,[r0,#0]
0009c6  f0020280          AND      r2,r2,#0x80
0009ca  4311              ORRS     r1,r1,r2
0009cc  6001              STR      r1,[r0,#0]
;;;2648   }
0009ce  4770              BX       lr
;;;2649   
                          ENDP

                  RTC_GetITStatus PROC
;;;2660     */
;;;2661   ITStatus RTC_GetITStatus(uint32_t RTC_IT)
0009d0  4a1b              LDR      r2,|L1.2624|
;;;2662   {
;;;2663     ITStatus bitstatus = RESET;
0009d2  2100              MOVS     r1,#0
;;;2664     uint32_t tmpreg = 0, enablestatus = 0;
;;;2665    
;;;2666     /* Check the parameters */
;;;2667     assert_param(IS_RTC_GET_IT(RTC_IT));
;;;2668     
;;;2669     /* Get the TAMPER Interrupt enable bit and pending bit */
;;;2670     tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
0009d4  6812              LDR      r2,[r2,#0]
0009d6  f0020304          AND      r3,r2,#4
;;;2671    
;;;2672     /* Get the Interrupt enable Status */
;;;2673     enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
0009da  4a19              LDR      r2,|L1.2624|
0009dc  3a38              SUBS     r2,r2,#0x38
0009de  6812              LDR      r2,[r2,#0]
0009e0  ea0333d0          AND      r3,r3,r0,LSR #15
0009e4  4002              ANDS     r2,r2,r0
0009e6  431a              ORRS     r2,r2,r3
;;;2674     
;;;2675     /* Get the Interrupt pending bit */
;;;2676     tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
0009e8  4b17              LDR      r3,|L1.2632|
0009ea  681b              LDR      r3,[r3,#0]
0009ec  ea031010          AND      r0,r3,r0,LSR #4
0009f0  d003              BEQ      |L1.2554|
;;;2677     
;;;2678     /* Get the status of the Interrupt */
;;;2679     if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
0009f2  0400              LSLS     r0,r0,#16
0009f4  0c00              LSRS     r0,r0,#16
0009f6  d000              BEQ      |L1.2554|
;;;2680     {
;;;2681       bitstatus = SET;
0009f8  2101              MOVS     r1,#1
                  |L1.2554|
;;;2682     }
;;;2683     else
;;;2684     {
;;;2685       bitstatus = RESET;
;;;2686     }
;;;2687     return bitstatus;
0009fa  4608              MOV      r0,r1
;;;2688   }
0009fc  4770              BX       lr
;;;2689   
                          ENDP

                  RTC_ClearITPendingBit PROC
;;;2700     */
;;;2701   void RTC_ClearITPendingBit(uint32_t RTC_IT)
0009fe  f3c0100f          UBFX     r0,r0,#4,#16
;;;2702   {
;;;2703     uint32_t tmpreg = 0;
;;;2704   
;;;2705     /* Check the parameters */
;;;2706     assert_param(IS_RTC_CLEAR_IT(RTC_IT));
;;;2707   
;;;2708     /* Get the RTC_ISR Interrupt pending bits mask */
;;;2709     tmpreg = (uint32_t)(RTC_IT >> 4);
;;;2710   
;;;2711     /* Clear the interrupt pending bits in the RTC_ISR register */
;;;2712     RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
000a02  f0400080          ORR      r0,r0,#0x80
000a06  43c1              MVNS     r1,r0
000a08  480f              LDR      r0,|L1.2632|
000a0a  6802              LDR      r2,[r0,#0]
000a0c  f0020280          AND      r2,r2,#0x80
000a10  4311              ORRS     r1,r1,r2
000a12  6001              STR      r1,[r0,#0]
;;;2713   }
000a14  4770              BX       lr
;;;2714   
                          ENDP

                  RTC_ByteToBcd2 PROC
;;;2723     */
;;;2724   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000a16  2100              MOVS     r1,#0
;;;2725   {
000a18  e003              B        |L1.2594|
                  |L1.2586|
000a1a  1c49              ADDS     r1,r1,#1
;;;2726     uint8_t bcdhigh = 0;
;;;2727     
;;;2728     while (Value >= 10)
;;;2729     {
;;;2730       bcdhigh++;
000a1c  380a              SUBS     r0,r0,#0xa
000a1e  b2c9              UXTB     r1,r1
;;;2731       Value -= 10;
000a20  b2c0              UXTB     r0,r0
                  |L1.2594|
000a22  280a              CMP      r0,#0xa               ;2728
000a24  d2f9              BCS      |L1.2586|
;;;2732     }
;;;2733     
;;;2734     return  ((uint8_t)(bcdhigh << 4) | Value);
000a26  0709              LSLS     r1,r1,#28
000a28  ea406011          ORR      r0,r0,r1,LSR #24
;;;2735   }
000a2c  4770              BX       lr
;;;2736   
                          ENDP

                  RTC_Bcd2ToByte PROC
;;;2741     */
;;;2742   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000a2e  0901              LSRS     r1,r0,#4
;;;2743   {
;;;2744     uint8_t tmp = 0;
;;;2745     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
000a30  eb010181          ADD      r1,r1,r1,LSL #2
;;;2746     return (tmp + (Value & (uint8_t)0x0F));
000a34  f000000f          AND      r0,r0,#0xf
000a38  eb000041          ADD      r0,r0,r1,LSL #1
000a3c  b2c0              UXTB     r0,r0
;;;2747   }
000a3e  4770              BX       lr
;;;2748   
                          ENDP

                  |L1.2624|
                          DCD      0x40002840
                  |L1.2628|
                          DCD      0x00013f7f
                  |L1.2632|
                          DCD      0x4000280c

;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___15_stm32f4xx_rtc_c_81435638____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____REVSH|
#line 144
|__asm___15_stm32f4xx_rtc_c_81435638____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
