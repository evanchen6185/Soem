; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\ethercatbase.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\ethercatbase.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\FWLIB\STM32F4xx_StdPeriph_Driver\inc -I..\USER -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\ETHERNET -I..\HARDWARE\TIMER -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\RTC -I..\HARDWARE\ADC -I..\HARDWARE\SRAM -I..\HARDWARE\InterTemperate -I..\FWLIB\STM32F4x7_ETH_Driver\inc -I..\MALLOC -I..\USMART -I..\HARDWARE -I..\ETHERCAT -I.\RTE\_LWIP -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS --omf_browse=..\obj\ethercatbase.crf ..\ETHERCAT\ethercatbase.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ecx_setupdatagram PROC
;;;101     */
;;;102    int ecx_setupdatagram(ecx_portt *port, void *frame, uint8 com, uint8 idx, uint16 ADP, uint16 ADO, uint16 length, void *data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;103    {
000004  4694              MOV      r12,r2
000006  e9dd2507          LDRD     r2,r5,[sp,#0x1c]
00000a  4607              MOV      r7,r0
00000c  461e              MOV      r6,r3
;;;104       ec_comt *datagramP;
;;;105       uint8 *frameP;
;;;106    
;;;107       frameP = (uint8 *)frame;
;;;108       /* Ethernet header is preset and fixed in frame buffers
;;;109          EtherCAT header needs to be added after that */
;;;110       datagramP = (ec_comt*)&frameP[ETH_HEADERSIZE];
;;;111       datagramP->elength =EC_ECATTYPE + EC_HEADERSIZE + length;
00000e  f241000c          MOV      r0,#0x100c
000012  460c              MOV      r4,r1                 ;107
000014  4428              ADD      r0,r0,r5
000016  f8dde018          LDR      lr,[sp,#0x18]
00001a  9b09              LDR      r3,[sp,#0x24]
00001c  f8210f0e          STRH     r0,[r1,#0xe]!
;;;112       datagramP->command = com;
;;;113       datagramP->index = idx; 
;;;114       datagramP->ADP =ADP;
;;;115       datagramP->ADO =ADO;
;;;116       datagramP->dlength = length; 
;;;117       ecx_writedatagramdata(&frameP[ETH_HEADERSIZE + EC_HEADERSIZE], (ec_cmdtype)com, length, data);
000020  f104001a          ADD      r0,r4,#0x1a
000024  f881c002          STRB     r12,[r1,#2]           ;112
000028  70ce              STRB     r6,[r1,#3]            ;113
00002a  f8a1e004          STRH     lr,[r1,#4]            ;114
00002e  80ca              STRH     r2,[r1,#6]            ;115
000030  810d              STRH     r5,[r1,#8]            ;116
000032  462a              MOV      r2,r5
000034  4661              MOV      r1,r12
000036  f7fffffe          BL       ecx_writedatagramdata
;;;118       /* set WKC to zero */
;;;119       frameP[ETH_HEADERSIZE + EC_HEADERSIZE + length] = 0x00;
00003a  1960              ADDS     r0,r4,r5
00003c  2200              MOVS     r2,#0
00003e  7682              STRB     r2,[r0,#0x1a]
;;;120       frameP[ETH_HEADERSIZE + EC_HEADERSIZE + length + 1] = 0x00;
000040  76c2              STRB     r2,[r0,#0x1b]
;;;121       
;;;122       /* set size of frame in buffer array */
;;;123       port->txbuflength[idx] = ETH_HEADERSIZE + EC_HEADERSIZE + EC_WKCSIZE + length;
000042  eb070086          ADD      r0,r7,r6,LSL #2
000046  f5004040          ADD      r0,r0,#0xc000
00004a  351c              ADDS     r5,r5,#0x1c
;;;124       return 0;
00004c  f8c0544c          STR      r5,[r0,#0x44c]
000050  4610              MOV      r0,r2
;;;125    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;126    
                          ENDP

                  ecx_adddatagram PROC
;;;139     */
;;;140    int ecx_adddatagram(ecx_portt *port, void *frame, uint8 com, uint8 idx, boolean more, uint16 ADP, uint16 ADO, uint16 length, void *data)
000056  e92d5ff0          PUSH     {r4-r12,lr}
;;;141    {
;;;142       ec_comt *datagramP;
;;;143       uint8 *frameP;
;;;144       uint16 prevlength;
;;;145    
;;;146       frameP = (uint8 *)frame;
00005a  460c              MOV      r4,r1
00005c  e9dd950c          LDRD     r9,r5,[sp,#0x30]      ;141
;;;147       /* copy previous frame size */
;;;148       prevlength = port->txbuflength[idx]; 
000060  eb000783          ADD      r7,r0,r3,LSL #2
000064  4694              MOV      r12,r2                ;141
000066  e9ddba0a          LDRD     r11,r10,[sp,#0x28]    ;141
00006a  f5074740          ADD      r7,r7,#0xc000
;;;149       datagramP = (ec_comt*)&frameP[ETH_HEADERSIZE];
;;;150       /* add new datagram to ethernet frame size */
;;;151       datagramP->elength = htoes( etohs(datagramP->elength) + EC_HEADERSIZE + length );
00006e  f8318f0e          LDRH     r8,[r1,#0xe]!
000072  f105020c          ADD      r2,r5,#0xc
000076  f8dde038          LDR      lr,[sp,#0x38]         ;148
00007a  f8d7044c          LDR      r0,[r7,#0x44c]        ;148
00007e  4442              ADD      r2,r2,r8
000080  800a              STRH     r2,[r1,#0]
;;;152       /* add "datagram follows" flag to previous subframe dlength */
;;;153       datagramP->dlength = htoes( etohs(datagramP->dlength) | EC_DATAGRAMFOLLOWS );
000082  890a              LDRH     r2,[r1,#8]
000084  b286              UXTH     r6,r0                 ;148
000086  f4424200          ORR      r2,r2,#0x8000
00008a  810a              STRH     r2,[r1,#8]
;;;154       /* set new EtherCAT header position */
;;;155       datagramP = (ec_comt*)&frameP[prevlength - EC_ELENGTHSIZE];
;;;156       datagramP->command = com;
;;;157       datagramP->index = idx; 
;;;158       datagramP->ADP = htoes(ADP);
;;;159       datagramP->ADO = htoes(ADO);
;;;160       if (more)
;;;161       {
;;;162          /* this is not the last datagram to add */
;;;163          datagramP->dlength = htoes(length | EC_DATAGRAMFOLLOWS); 
;;;164       }
;;;165       else
;;;166       {
;;;167          /* this is the last datagram in the frame */
;;;168          datagramP->dlength = htoes(length); 
;;;169       }
;;;170       ecx_writedatagramdata(&frameP[prevlength + EC_HEADERSIZE - EC_ELENGTHSIZE], (ec_cmdtype)com, length, data);
;;;171       /* set WKC to zero */
;;;172       frameP[prevlength + EC_HEADERSIZE - EC_ELENGTHSIZE + length] = 0x00;
;;;173       frameP[prevlength + EC_HEADERSIZE - EC_ELENGTHSIZE + length + 1] = 0x00;
;;;174       /* set size of frame in buffer array */
;;;175       port->txbuflength[idx] = prevlength + EC_HEADERSIZE - EC_ELENGTHSIZE + EC_WKCSIZE + length;
;;;176    
;;;177       /* return offset to data in rx frame
;;;178          14 bytes smaller than tx frame due to stripping of ethernet header */
;;;179       return prevlength + EC_HEADERSIZE - EC_ELENGTHSIZE - ETH_HEADERSIZE;  
;;;180    }
00008c  fa14f080          UXTAH    r0,r4,r0
000090  f800c902          STRB     r12,[r0],#-2          ;156
000094  f1bb0f00          CMP      r11,#0                ;160
000098  70c3              STRB     r3,[r0,#3]            ;157
00009a  f8a0a004          STRH     r10,[r0,#4]           ;158
00009e  f8a09006          STRH     r9,[r0,#6]            ;159
0000a2  d003              BEQ      |L1.172|
0000a4  f4454100          ORR      r1,r5,#0x8000         ;163
0000a8  8101              STRH     r1,[r0,#8]            ;163
0000aa  e000              B        |L1.174|
                  |L1.172|
0000ac  8105              STRH     r5,[r0,#8]            ;168
                  |L1.174|
0000ae  19a0              ADDS     r0,r4,r6              ;170
0000b0  4673              MOV      r3,lr                 ;170
0000b2  462a              MOV      r2,r5                 ;170
0000b4  4661              MOV      r1,r12                ;170
0000b6  300a              ADDS     r0,r0,#0xa            ;170
0000b8  f7fffffe          BL       ecx_writedatagramdata
0000bc  1970              ADDS     r0,r6,r5              ;172
0000be  1901              ADDS     r1,r0,r4              ;172
0000c0  2200              MOVS     r2,#0                 ;172
0000c2  728a              STRB     r2,[r1,#0xa]          ;172
0000c4  72ca              STRB     r2,[r1,#0xb]          ;173
0000c6  300c              ADDS     r0,r0,#0xc            ;173
0000c8  f8c7044c          STR      r0,[r7,#0x44c]        ;179
0000cc  1f30              SUBS     r0,r6,#4              ;179
0000ce  e8bd9ff0          POP      {r4-r12,pc}
;;;181    
                          ENDP

                  ecx_BWR PROC
;;;191     */ 
;;;192    int ecx_BWR (ecx_portt *port, uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
0000d2  e92d47ff          PUSH     {r0-r10,lr}
;;;193    {
0000d6  4698              MOV      r8,r3
0000d8  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
0000dc  4617              MOV      r7,r2
0000de  460e              MOV      r6,r1
0000e0  4605              MOV      r5,r0
;;;194       uint8 idx;
;;;195       int wkc;
;;;196    
;;;197       /* get fresh index */
;;;198       idx = ecx_getindex (port);
0000e2  f7fffffe          BL       ecx_getindex
0000e6  b2c4              UXTB     r4,r0
;;;199       /* setup datagram */
;;;200       ecx_setupdatagram (port, &(port->txbuf[idx]), EC_CMD_BWR, idx, ADP, ADO, length, data);
0000e8  f24020f7          MOV      r0,#0x2f7
0000ec  fb14f000          SMULBB   r0,r4,r0
0000f0  e88d03c0          STM      sp,{r6-r9}
0000f4  eb050040          ADD      r0,r5,r0,LSL #1
0000f8  f246516c          MOV      r1,#0x656c
0000fc  4401              ADD      r1,r1,r0
0000fe  4623              MOV      r3,r4
000100  2208              MOVS     r2,#8
000102  4628              MOV      r0,r5
000104  f7fffffe          BL       ecx_setupdatagram
;;;201       /* send data and wait for answer */
;;;202       wkc = ecx_srconfirm (port, idx, timeout);
000108  4652              MOV      r2,r10
00010a  4621              MOV      r1,r4
00010c  4628              MOV      r0,r5
00010e  f7fffffe          BL       ecx_srconfirm
000112  4606              MOV      r6,r0
;;;203       /* clear buffer status */
;;;204       ecx_setbufstat (port, idx, EC_BUF_EMPTY);
000114  2200              MOVS     r2,#0
000116  4621              MOV      r1,r4
000118  4628              MOV      r0,r5
00011a  f7fffffe          BL       ecx_setbufstat
;;;205    
;;;206       return wkc;
00011e  4630              MOV      r0,r6
                  |L1.288|
;;;207    }   
000120  b004              ADD      sp,sp,#0x10
000122  e8bd87f0          POP      {r4-r10,pc}
;;;208    
                          ENDP

                  ecx_BRD PROC
;;;218     */ 
;;;219    int ecx_BRD(ecx_portt *port, uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
000126  e92d47ff          PUSH     {r0-r10,lr}
;;;220    {
00012a  461e              MOV      r6,r3
00012c  e9dd8a0c          LDRD     r8,r10,[sp,#0x30]
000130  4614              MOV      r4,r2
000132  460f              MOV      r7,r1
000134  4681              MOV      r9,r0
;;;221       uint8 idx;
;;;222       int wkc;
;;;223    
;;;224       /* get fresh index */
;;;225       idx = ecx_getindex(port);
000136  f7fffffe          BL       ecx_getindex
00013a  b2c5              UXTB     r5,r0
;;;226       /* setup datagram */
;;;227       ecx_setupdatagram(port, &(port->txbuf[idx]), EC_CMD_BRD, idx, ADP, ADO, length, data);
00013c  f24020f7          MOV      r0,#0x2f7
000140  fb15f100          SMULBB   r1,r5,r0
000144  aa01              ADD      r2,sp,#4
000146  9700              STR      r7,[sp,#0]
000148  e8820150          STM      r2,{r4,r6,r8}
00014c  eb090441          ADD      r4,r9,r1,LSL #1
000150  f246506c          MOV      r0,#0x656c
000154  1821              ADDS     r1,r4,r0
000156  462b              MOV      r3,r5
000158  2207              MOVS     r2,#7
00015a  4648              MOV      r0,r9
00015c  f7fffffe          BL       ecx_setupdatagram
;;;228       /* send data and wait for answer */
;;;229       wkc = ecx_srconfirm (port, idx, timeout);
000160  4652              MOV      r2,r10
000162  4629              MOV      r1,r5
000164  4648              MOV      r0,r9
000166  f7fffffe          BL       ecx_srconfirm
00016a  1e07              SUBS     r7,r0,#0
;;;230       if (wkc > 0)
00016c  dd05              BLE      |L1.378|
;;;231       {
;;;232          /* copy datagram to data buffer */
;;;233          memcpy(data, &(port->rxbuf[idx][EC_HEADERSIZE]), length);
00016e  f1040124          ADD      r1,r4,#0x24
000172  4632              MOV      r2,r6
000174  4640              MOV      r0,r8
000176  f7fffffe          BL       __aeabi_memcpy
                  |L1.378|
;;;234       }   
;;;235       /* clear buffer status */
;;;236       ecx_setbufstat(port, idx, EC_BUF_EMPTY);
00017a  2200              MOVS     r2,#0
00017c  4629              MOV      r1,r5
00017e  4648              MOV      r0,r9
000180  f7fffffe          BL       ecx_setbufstat
;;;237    
;;;238       return wkc;
000184  4638              MOV      r0,r7
;;;239    }   
000186  e7cb              B        |L1.288|
;;;240    
                          ENDP

                  ecx_APRD PROC
;;;250     */ 
;;;251    int ecx_APRD(ecx_portt *port, uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
000188  e92d47ff          PUSH     {r0-r10,lr}
;;;252    {
00018c  461e              MOV      r6,r3
00018e  e9dd8a0c          LDRD     r8,r10,[sp,#0x30]
000192  4614              MOV      r4,r2
000194  460f              MOV      r7,r1
000196  4681              MOV      r9,r0
;;;253       int wkc;
;;;254       uint8 idx;
;;;255    
;;;256       idx = ecx_getindex(port);
000198  f7fffffe          BL       ecx_getindex
00019c  b2c5              UXTB     r5,r0
;;;257       ecx_setupdatagram(port, &(port->txbuf[idx]), EC_CMD_APRD, idx, ADP, ADO, length, data);
00019e  f24020f7          MOV      r0,#0x2f7
0001a2  fb15f100          SMULBB   r1,r5,r0
0001a6  aa01              ADD      r2,sp,#4
0001a8  9700              STR      r7,[sp,#0]
0001aa  e8820150          STM      r2,{r4,r6,r8}
0001ae  eb090441          ADD      r4,r9,r1,LSL #1
0001b2  f246506c          MOV      r0,#0x656c
0001b6  1821              ADDS     r1,r4,r0
0001b8  462b              MOV      r3,r5
0001ba  2201              MOVS     r2,#1
0001bc  4648              MOV      r0,r9
0001be  f7fffffe          BL       ecx_setupdatagram
;;;258       wkc = ecx_srconfirm(port, idx, timeout);
0001c2  4652              MOV      r2,r10
0001c4  4629              MOV      r1,r5
0001c6  4648              MOV      r0,r9
0001c8  f7fffffe          BL       ecx_srconfirm
0001cc  1e07              SUBS     r7,r0,#0
;;;259       if (wkc > 0)
0001ce  dd05              BLE      |L1.476|
;;;260       {
;;;261          memcpy(data, &(port->rxbuf[idx][EC_HEADERSIZE]), length);
0001d0  f1040124          ADD      r1,r4,#0x24
0001d4  4632              MOV      r2,r6
0001d6  4640              MOV      r0,r8
0001d8  f7fffffe          BL       __aeabi_memcpy
                  |L1.476|
;;;262       }
;;;263       ecx_setbufstat(port, idx, EC_BUF_EMPTY);
0001dc  2200              MOVS     r2,#0
0001de  4629              MOV      r1,r5
0001e0  4648              MOV      r0,r9
0001e2  f7fffffe          BL       ecx_setbufstat
;;;264    
;;;265       return wkc;
0001e6  4638              MOV      r0,r7
;;;266    }
0001e8  e79a              B        |L1.288|
;;;267    
                          ENDP

                  ecx_ARMW PROC
;;;278     */ 
;;;279    int ecx_ARMW(ecx_portt *port, uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
0001ea  e92d47ff          PUSH     {r0-r10,lr}
;;;280    {
0001ee  461e              MOV      r6,r3
0001f0  e9dd8a0c          LDRD     r8,r10,[sp,#0x30]
0001f4  4614              MOV      r4,r2
0001f6  460f              MOV      r7,r1
0001f8  4681              MOV      r9,r0
;;;281       int wkc;
;;;282       uint8 idx;
;;;283    
;;;284       idx = ecx_getindex(port);
0001fa  f7fffffe          BL       ecx_getindex
0001fe  b2c5              UXTB     r5,r0
;;;285       ecx_setupdatagram(port, &(port->txbuf[idx]), EC_CMD_ARMW, idx, ADP, ADO, length, data);
000200  f24020f7          MOV      r0,#0x2f7
000204  fb15f100          SMULBB   r1,r5,r0
000208  aa01              ADD      r2,sp,#4
00020a  9700              STR      r7,[sp,#0]
00020c  e8820150          STM      r2,{r4,r6,r8}
000210  eb090441          ADD      r4,r9,r1,LSL #1
000214  f246506c          MOV      r0,#0x656c
000218  1821              ADDS     r1,r4,r0
00021a  462b              MOV      r3,r5
00021c  220d              MOVS     r2,#0xd
00021e  4648              MOV      r0,r9
000220  f7fffffe          BL       ecx_setupdatagram
;;;286       wkc = ecx_srconfirm(port, idx, timeout);
000224  4652              MOV      r2,r10
000226  4629              MOV      r1,r5
000228  4648              MOV      r0,r9
00022a  f7fffffe          BL       ecx_srconfirm
00022e  1e07              SUBS     r7,r0,#0
;;;287       if (wkc > 0)
000230  dd05              BLE      |L1.574|
;;;288       {
;;;289          memcpy(data, &(port->rxbuf[idx][EC_HEADERSIZE]), length);
000232  f1040124          ADD      r1,r4,#0x24
000236  4632              MOV      r2,r6
000238  4640              MOV      r0,r8
00023a  f7fffffe          BL       __aeabi_memcpy
                  |L1.574|
;;;290       }
;;;291       ecx_setbufstat(port, idx, EC_BUF_EMPTY);
00023e  2200              MOVS     r2,#0
000240  4629              MOV      r1,r5
000242  4648              MOV      r0,r9
000244  f7fffffe          BL       ecx_setbufstat
;;;292    
;;;293       return wkc;
000248  4638              MOV      r0,r7
;;;294    }
00024a  e769              B        |L1.288|
;;;295    
                          ENDP

                  ecx_FRMW PROC
;;;306     */ 
;;;307    int ecx_FRMW(ecx_portt *port, uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
00024c  e92d47ff          PUSH     {r0-r10,lr}
;;;308    {
000250  461e              MOV      r6,r3
000252  e9dd8a0c          LDRD     r8,r10,[sp,#0x30]
000256  4614              MOV      r4,r2
000258  460f              MOV      r7,r1
00025a  4681              MOV      r9,r0
;;;309       int wkc;
;;;310       uint8 idx;
;;;311    
;;;312       idx = ecx_getindex(port);
00025c  f7fffffe          BL       ecx_getindex
000260  b2c5              UXTB     r5,r0
;;;313       ecx_setupdatagram(port, &(port->txbuf[idx]), EC_CMD_FRMW, idx, ADP, ADO, length, data);
000262  f24020f7          MOV      r0,#0x2f7
000266  fb15f100          SMULBB   r1,r5,r0
00026a  aa01              ADD      r2,sp,#4
00026c  9700              STR      r7,[sp,#0]
00026e  e8820150          STM      r2,{r4,r6,r8}
000272  eb090441          ADD      r4,r9,r1,LSL #1
000276  f246506c          MOV      r0,#0x656c
00027a  1821              ADDS     r1,r4,r0
00027c  462b              MOV      r3,r5
00027e  220e              MOVS     r2,#0xe
000280  4648              MOV      r0,r9
000282  f7fffffe          BL       ecx_setupdatagram
;;;314       wkc = ecx_srconfirm(port, idx, timeout);
000286  4652              MOV      r2,r10
000288  4629              MOV      r1,r5
00028a  4648              MOV      r0,r9
00028c  f7fffffe          BL       ecx_srconfirm
000290  1e07              SUBS     r7,r0,#0
;;;315       if (wkc > 0)
000292  dd05              BLE      |L1.672|
;;;316       {
;;;317          memcpy(data, &(port->rxbuf[idx][EC_HEADERSIZE]), length);
000294  f1040124          ADD      r1,r4,#0x24
000298  4632              MOV      r2,r6
00029a  4640              MOV      r0,r8
00029c  f7fffffe          BL       __aeabi_memcpy
                  |L1.672|
;;;318       }
;;;319       ecx_setbufstat(port, idx, EC_BUF_EMPTY);
0002a0  2200              MOVS     r2,#0
0002a2  4629              MOV      r1,r5
0002a4  4648              MOV      r0,r9
0002a6  f7fffffe          BL       ecx_setbufstat
;;;320    
;;;321       return wkc;
0002aa  4638              MOV      r0,r7
;;;322    }
0002ac  e738              B        |L1.288|
;;;323    
                          ENDP

                  ecx_APRDw PROC
;;;331     */ 
;;;332    uint16 ecx_APRDw(ecx_portt *port, uint16 ADP, uint16 ADO, int timeout)
0002ae  b53e              PUSH     {r1-r5,lr}
;;;333    {
;;;334       uint16 w;
;;;335    
;;;336       w = 0;
0002b0  2400              MOVS     r4,#0
0002b2  f8ad4008          STRH     r4,[sp,#8]
;;;337       ecx_APRD(port, ADP, ADO, sizeof(w), &w, timeout);
0002b6  ac02              ADD      r4,sp,#8
0002b8  e9cd4300          STRD     r4,r3,[sp,#0]
0002bc  2302              MOVS     r3,#2
0002be  f7fffffe          BL       ecx_APRD
;;;338    
;;;339       return w;
0002c2  f8bd0008          LDRH     r0,[sp,#8]
;;;340    }
0002c6  bd3e              POP      {r1-r5,pc}
;;;341    
                          ENDP

                  ecx_FPRD PROC
;;;351     */ 
;;;352    int ecx_FPRD(ecx_portt *port, uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
0002c8  e92d47ff          PUSH     {r0-r10,lr}
;;;353    {
0002cc  461e              MOV      r6,r3
0002ce  e9dd8a0c          LDRD     r8,r10,[sp,#0x30]
0002d2  4614              MOV      r4,r2
0002d4  460f              MOV      r7,r1
0002d6  4681              MOV      r9,r0
;;;354       int wkc;
;;;355       uint8 idx;
;;;356    
;;;357       idx = ecx_getindex(port);
0002d8  f7fffffe          BL       ecx_getindex
0002dc  b2c5              UXTB     r5,r0
;;;358       ecx_setupdatagram(port, &(port->txbuf[idx]), EC_CMD_FPRD, idx, ADP, ADO, length, data);
0002de  f24020f7          MOV      r0,#0x2f7
0002e2  fb15f100          SMULBB   r1,r5,r0
0002e6  aa01              ADD      r2,sp,#4
0002e8  9700              STR      r7,[sp,#0]
0002ea  e8820150          STM      r2,{r4,r6,r8}
0002ee  eb090441          ADD      r4,r9,r1,LSL #1
0002f2  f246506c          MOV      r0,#0x656c
0002f6  1821              ADDS     r1,r4,r0
0002f8  462b              MOV      r3,r5
0002fa  2204              MOVS     r2,#4
0002fc  4648              MOV      r0,r9
0002fe  f7fffffe          BL       ecx_setupdatagram
;;;359       wkc = ecx_srconfirm(port, idx, timeout);
000302  4652              MOV      r2,r10
000304  4629              MOV      r1,r5
000306  4648              MOV      r0,r9
000308  f7fffffe          BL       ecx_srconfirm
00030c  1e07              SUBS     r7,r0,#0
;;;360       if (wkc > 0)
00030e  dd05              BLE      |L1.796|
;;;361       {
;;;362          memcpy(data, &(port->rxbuf[idx][EC_HEADERSIZE]), length);
000310  f1040124          ADD      r1,r4,#0x24
000314  4632              MOV      r2,r6
000316  4640              MOV      r0,r8
000318  f7fffffe          BL       __aeabi_memcpy
                  |L1.796|
;;;363       }
;;;364       ecx_setbufstat(port, idx, EC_BUF_EMPTY);
00031c  2200              MOVS     r2,#0
00031e  4629              MOV      r1,r5
000320  4648              MOV      r0,r9
000322  f7fffffe          BL       ecx_setbufstat
;;;365    
;;;366       return wkc;
000326  4638              MOV      r0,r7
;;;367    }
000328  e6fa              B        |L1.288|
;;;368    
                          ENDP

                  ecx_FPRDw PROC
;;;376     */ 
;;;377    uint16 ecx_FPRDw(ecx_portt *port, uint16 ADP, uint16 ADO, int timeout)
00032a  b53e              PUSH     {r1-r5,lr}
;;;378    {
;;;379       uint16 w;
;;;380    
;;;381       w = 0;
00032c  2400              MOVS     r4,#0
00032e  f8ad4008          STRH     r4,[sp,#8]
;;;382       ecx_FPRD(port, ADP, ADO, sizeof(w), &w, timeout);
000332  ac02              ADD      r4,sp,#8
000334  e9cd4300          STRD     r4,r3,[sp,#0]
000338  2302              MOVS     r3,#2
00033a  f7fffffe          BL       ecx_FPRD
;;;383       return w;
00033e  f8bd0008          LDRH     r0,[sp,#8]
;;;384    }
000342  bd3e              POP      {r1-r5,pc}
;;;385    
                          ENDP

                  ecx_APWR PROC
;;;395     */ 
;;;396    int ecx_APWR(ecx_portt *port, uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
000344  e92d47ff          PUSH     {r0-r10,lr}
;;;397    {
000348  4698              MOV      r8,r3
00034a  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
00034e  4617              MOV      r7,r2
000350  460e              MOV      r6,r1
000352  4605              MOV      r5,r0
;;;398       uint8 idx;
;;;399       int wkc;
;;;400    
;;;401       idx = ecx_getindex(port);
000354  f7fffffe          BL       ecx_getindex
000358  b2c4              UXTB     r4,r0
;;;402       ecx_setupdatagram(port, &(port->txbuf[idx]), EC_CMD_APWR, idx, ADP, ADO, length, data);
00035a  f24020f7          MOV      r0,#0x2f7
00035e  fb14f000          SMULBB   r0,r4,r0
000362  e88d03c0          STM      sp,{r6-r9}
000366  eb050040          ADD      r0,r5,r0,LSL #1
00036a  f246516c          MOV      r1,#0x656c
00036e  4401              ADD      r1,r1,r0
000370  4623              MOV      r3,r4
000372  2202              MOVS     r2,#2
000374  4628              MOV      r0,r5
000376  f7fffffe          BL       ecx_setupdatagram
;;;403       wkc = ecx_srconfirm(port, idx, timeout);
00037a  4652              MOV      r2,r10
00037c  4621              MOV      r1,r4
00037e  4628              MOV      r0,r5
000380  f7fffffe          BL       ecx_srconfirm
000384  4606              MOV      r6,r0
;;;404       ecx_setbufstat(port, idx, EC_BUF_EMPTY);
000386  2200              MOVS     r2,#0
000388  4621              MOV      r1,r4
00038a  4628              MOV      r0,r5
00038c  f7fffffe          BL       ecx_setbufstat
;;;405       
;;;406       return wkc;
000390  4630              MOV      r0,r6
;;;407    }
000392  e6c5              B        |L1.288|
;;;408    
                          ENDP

                  ecx_APWRw PROC
;;;417     */ 
;;;418    int ecx_APWRw(ecx_portt *port, uint16 ADP, uint16 ADO, uint16 data, int timeout)
000394  b51f              PUSH     {r0-r4,lr}
;;;419    {
000396  b082              SUB      sp,sp,#8
;;;420       return ecx_APWR(port, ADP, ADO, sizeof(data), &data, timeout);
000398  ab05              ADD      r3,sp,#0x14
00039a  9c08              LDR      r4,[sp,#0x20]
00039c  e9cd3400          STRD     r3,r4,[sp,#0]
0003a0  2302              MOVS     r3,#2
0003a2  f7fffffe          BL       ecx_APWR
                  |L1.934|
;;;421    }
0003a6  b006              ADD      sp,sp,#0x18
0003a8  bd10              POP      {r4,pc}
;;;422    
                          ENDP

                  ecx_FPWR PROC
;;;432     */ 
;;;433    int ecx_FPWR(ecx_portt *port, uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
0003aa  e92d47ff          PUSH     {r0-r10,lr}
;;;434    {
0003ae  4698              MOV      r8,r3
0003b0  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
0003b4  4617              MOV      r7,r2
0003b6  460e              MOV      r6,r1
0003b8  4605              MOV      r5,r0
;;;435       int wkc;
;;;436       uint8 idx;
;;;437    
;;;438       idx = ecx_getindex(port);
0003ba  f7fffffe          BL       ecx_getindex
0003be  b2c4              UXTB     r4,r0
;;;439       ecx_setupdatagram(port, &(port->txbuf[idx]), EC_CMD_FPWR, idx, ADP, ADO, length, data);
0003c0  f24020f7          MOV      r0,#0x2f7
0003c4  fb14f000          SMULBB   r0,r4,r0
0003c8  e88d03c0          STM      sp,{r6-r9}
0003cc  eb050040          ADD      r0,r5,r0,LSL #1
0003d0  f246516c          MOV      r1,#0x656c
0003d4  4401              ADD      r1,r1,r0
0003d6  4623              MOV      r3,r4
0003d8  2205              MOVS     r2,#5
0003da  4628              MOV      r0,r5
0003dc  f7fffffe          BL       ecx_setupdatagram
;;;440       wkc = ecx_srconfirm(port, idx, timeout);
0003e0  4652              MOV      r2,r10
0003e2  4621              MOV      r1,r4
0003e4  4628              MOV      r0,r5
0003e6  f7fffffe          BL       ecx_srconfirm
0003ea  4606              MOV      r6,r0
;;;441       ecx_setbufstat(port, idx, EC_BUF_EMPTY);
0003ec  2200              MOVS     r2,#0
0003ee  4621              MOV      r1,r4
0003f0  4628              MOV      r0,r5
0003f2  f7fffffe          BL       ecx_setbufstat
;;;442    
;;;443       return wkc;
0003f6  4630              MOV      r0,r6
;;;444    }
0003f8  e692              B        |L1.288|
;;;445    
                          ENDP

                  ecx_FPWRw PROC
;;;454     */ 
;;;455    int ecx_FPWRw(ecx_portt *port, uint16 ADP, uint16 ADO, uint16 data, int timeout)
0003fa  b51f              PUSH     {r0-r4,lr}
;;;456    {
0003fc  b082              SUB      sp,sp,#8
;;;457       return ecx_FPWR(port, ADP, ADO, sizeof(data), &data, timeout);
0003fe  ab05              ADD      r3,sp,#0x14
000400  9c08              LDR      r4,[sp,#0x20]
000402  e9cd3400          STRD     r3,r4,[sp,#0]
000406  2302              MOVS     r3,#2
000408  f7fffffe          BL       ecx_FPWR
;;;458    }
00040c  e7cb              B        |L1.934|
;;;459    
                          ENDP

                  ecx_LRW PROC
;;;468     */ 
;;;469    int ecx_LRW(ecx_portt *port, uint32 LogAdr, uint16 length, void *data, int timeout)
00040e  e92d47ff          PUSH     {r0-r10,lr}
;;;470    {
000412  461e              MOV      r6,r3
000414  4690              MOV      r8,r2
000416  460c              MOV      r4,r1
000418  4681              MOV      r9,r0
;;;471       uint8 idx;
;;;472       int wkc;
;;;473       idx = ecx_getindex(port);
00041a  9f0c              LDR      r7,[sp,#0x30]
00041c  f7fffffe          BL       ecx_getindex
;;;474       ecx_setupdatagram(port, &(port->txbuf[idx]), EC_CMD_LRW, idx, LO_WORD(LogAdr), HI_WORD(LogAdr), length, data);
000420  0c21              LSRS     r1,r4,#16
000422  b2a2              UXTH     r2,r4
000424  e9cd2100          STRD     r2,r1,[sp,#0]
000428  b2c5              UXTB     r5,r0                 ;473
00042a  f24020f7          MOV      r0,#0x2f7
00042e  fb15f100          SMULBB   r1,r5,r0
000432  eb090441          ADD      r4,r9,r1,LSL #1
000436  f246506c          MOV      r0,#0x656c
00043a  e9cd8602          STRD     r8,r6,[sp,#8]
00043e  1821              ADDS     r1,r4,r0
000440  462b              MOV      r3,r5
000442  220c              MOVS     r2,#0xc
000444  4648              MOV      r0,r9
000446  f7fffffe          BL       ecx_setupdatagram
;;;475    	 wkc = ecx_srconfirm(port, idx, timeout);
00044a  463a              MOV      r2,r7
00044c  4629              MOV      r1,r5
00044e  4648              MOV      r0,r9
000450  f7fffffe          BL       ecx_srconfirm
000454  1e07              SUBS     r7,r0,#0
;;;476       if ((wkc > 0) && (port->rxbuf[idx][EC_CMDOFFSET] == EC_CMD_LRW))
000456  dd08              BLE      |L1.1130|
000458  7ea0              LDRB     r0,[r4,#0x1a]
00045a  280c              CMP      r0,#0xc
00045c  d105              BNE      |L1.1130|
;;;477       {
;;;478          memcpy(data, &(port->rxbuf[idx][EC_HEADERSIZE]), length);
00045e  f1040124          ADD      r1,r4,#0x24
000462  4642              MOV      r2,r8
000464  4630              MOV      r0,r6
000466  f7fffffe          BL       __aeabi_memcpy
                  |L1.1130|
;;;479       }
;;;480       ecx_setbufstat(port, idx, EC_BUF_EMPTY);
00046a  2200              MOVS     r2,#0
00046c  4629              MOV      r1,r5
00046e  4648              MOV      r0,r9
000470  f7fffffe          BL       ecx_setbufstat
;;;481       return wkc;
000474  4638              MOV      r0,r7
;;;482    }
000476  e653              B        |L1.288|
;;;483    
                          ENDP

                  ecx_LRD PROC
;;;492     */ 
;;;493    int ecx_LRD(ecx_portt *port, uint32 LogAdr, uint16 length, void *data, int timeout)
000478  e92d47ff          PUSH     {r0-r10,lr}
;;;494    {
00047c  461e              MOV      r6,r3
00047e  4690              MOV      r8,r2
000480  460c              MOV      r4,r1
000482  4681              MOV      r9,r0
;;;495       uint8 idx;
;;;496       int wkc;
;;;497    
;;;498       idx = ecx_getindex(port);
000484  9f0c              LDR      r7,[sp,#0x30]
000486  f7fffffe          BL       ecx_getindex
;;;499       ecx_setupdatagram(port, &(port->txbuf[idx]), EC_CMD_LRD, idx, LO_WORD(LogAdr), HI_WORD(LogAdr), length, data);
00048a  0c21              LSRS     r1,r4,#16
00048c  b2a2              UXTH     r2,r4
00048e  e9cd2100          STRD     r2,r1,[sp,#0]
000492  b2c5              UXTB     r5,r0                 ;498
000494  f24020f7          MOV      r0,#0x2f7
000498  fb15f100          SMULBB   r1,r5,r0
00049c  eb090441          ADD      r4,r9,r1,LSL #1
0004a0  f246506c          MOV      r0,#0x656c
0004a4  e9cd8602          STRD     r8,r6,[sp,#8]
0004a8  1821              ADDS     r1,r4,r0
0004aa  462b              MOV      r3,r5
0004ac  220a              MOVS     r2,#0xa
0004ae  4648              MOV      r0,r9
0004b0  f7fffffe          BL       ecx_setupdatagram
;;;500       wkc = ecx_srconfirm(port, idx, timeout);
0004b4  463a              MOV      r2,r7
0004b6  4629              MOV      r1,r5
0004b8  4648              MOV      r0,r9
0004ba  f7fffffe          BL       ecx_srconfirm
0004be  1e07              SUBS     r7,r0,#0
;;;501       if ((wkc > 0) && (port->rxbuf[idx][EC_CMDOFFSET]==EC_CMD_LRD))
0004c0  dd08              BLE      |L1.1236|
0004c2  7ea0              LDRB     r0,[r4,#0x1a]
0004c4  280a              CMP      r0,#0xa
0004c6  d105              BNE      |L1.1236|
;;;502       {
;;;503          memcpy(data, &(port->rxbuf[idx][EC_HEADERSIZE]), length);
0004c8  f1040124          ADD      r1,r4,#0x24
0004cc  4642              MOV      r2,r8
0004ce  4630              MOV      r0,r6
0004d0  f7fffffe          BL       __aeabi_memcpy
                  |L1.1236|
;;;504       }
;;;505       ecx_setbufstat(port, idx, EC_BUF_EMPTY);
0004d4  2200              MOVS     r2,#0
0004d6  4629              MOV      r1,r5
0004d8  4648              MOV      r0,r9
0004da  f7fffffe          BL       ecx_setbufstat
;;;506    
;;;507       return wkc;
0004de  4638              MOV      r0,r7
;;;508    }
0004e0  e61e              B        |L1.288|
;;;509    
                          ENDP

                  ecx_LWR PROC
;;;518     */ 
;;;519    int ecx_LWR(ecx_portt *port, uint32 LogAdr, uint16 length, void *data, int timeout)
0004e2  e92d47ff          PUSH     {r0-r10,lr}
;;;520    {
0004e6  4698              MOV      r8,r3
0004e8  4617              MOV      r7,r2
0004ea  460d              MOV      r5,r1
0004ec  4606              MOV      r6,r0
;;;521       uint8 idx;
;;;522       int wkc;
;;;523    
;;;524       idx = ecx_getindex(port);
0004ee  f8dd9030          LDR      r9,[sp,#0x30]
0004f2  f7fffffe          BL       ecx_getindex
0004f6  b2c4              UXTB     r4,r0
;;;525       ecx_setupdatagram(port, &(port->txbuf[idx]), EC_CMD_LWR, idx, LO_WORD(LogAdr), HI_WORD(LogAdr), length, data);
0004f8  0c29              LSRS     r1,r5,#16
0004fa  b2aa              UXTH     r2,r5
0004fc  f24020f7          MOV      r0,#0x2f7
000500  fb14f000          SMULBB   r0,r4,r0
000504  e9cd2100          STRD     r2,r1,[sp,#0]
000508  eb060040          ADD      r0,r6,r0,LSL #1
00050c  f246516c          MOV      r1,#0x656c
000510  e9cd7802          STRD     r7,r8,[sp,#8]
000514  4401              ADD      r1,r1,r0
000516  4623              MOV      r3,r4
000518  220b              MOVS     r2,#0xb
00051a  4630              MOV      r0,r6
00051c  f7fffffe          BL       ecx_setupdatagram
;;;526       wkc = ecx_srconfirm(port, idx, timeout);
000520  464a              MOV      r2,r9
000522  4621              MOV      r1,r4
000524  4630              MOV      r0,r6
000526  f7fffffe          BL       ecx_srconfirm
00052a  4605              MOV      r5,r0
;;;527       ecx_setbufstat(port, idx, EC_BUF_EMPTY);
00052c  2200              MOVS     r2,#0
00052e  4621              MOV      r1,r4
000530  4630              MOV      r0,r6
000532  f7fffffe          BL       ecx_setbufstat
;;;528    
;;;529       return wkc;
000536  4628              MOV      r0,r5
;;;530    }
000538  e5f2              B        |L1.288|
;;;531    
                          ENDP

                  ecx_LRWDC PROC
;;;543     */ 
;;;544    int ecx_LRWDC(ecx_portt *port, uint32 LogAdr, uint16 length, void *data, uint16 DCrs, int64 *DCtime, int timeout)
00053a  e92d4ff0          PUSH     {r4-r11,lr}
;;;545    {
00053e  b089              SUB      sp,sp,#0x24
000540  4699              MOV      r9,r3
000542  e9ddb812          LDRD     r11,r8,[sp,#0x48]
000546  4616              MOV      r6,r2
000548  460c              MOV      r4,r1
00054a  4682              MOV      r10,r0
;;;546       uint16 DCtO;
;;;547       uint8 idx;
;;;548       int wkc;
;;;549       uint64 DCtE;
;;;550    
;;;551       idx = ecx_getindex(port);
00054c  f7fffffe          BL       ecx_getindex
;;;552       /* LRW in first datagram */
;;;553       ecx_setupdatagram(port, &(port->txbuf[idx]), EC_CMD_LRW, idx, LO_WORD(LogAdr), HI_WORD(LogAdr), length, data);
000550  b2a2              UXTH     r2,r4
000552  ab01              ADD      r3,sp,#4
000554  0c21              LSRS     r1,r4,#16
000556  9200              STR      r2,[sp,#0]
000558  e8830242          STM      r3,{r1,r6,r9}
00055c  b2c5              UXTB     r5,r0                 ;551
00055e  f24020f7          MOV      r0,#0x2f7
000562  fb15f100          SMULBB   r1,r5,r0
000566  eb0a0441          ADD      r4,r10,r1,LSL #1
00056a  f246506c          MOV      r0,#0x656c
00056e  1821              ADDS     r1,r4,r0
000570  460f              MOV      r7,r1
000572  462b              MOV      r3,r5
000574  220c              MOVS     r2,#0xc
000576  4650              MOV      r0,r10
000578  f7fffffe          BL       ecx_setupdatagram
;;;554       /* FPRMW in second datagram */
;;;555       DCtE = htoell(*DCtime);
00057c  e9d81000          LDRD     r1,r0,[r8,#0]
000580  e9cd1006          STRD     r1,r0,[sp,#0x18]
;;;556       DCtO = ecx_adddatagram(port, &(port->txbuf[idx]), EC_CMD_FRMW, idx, FALSE, DCrs, ECT_REG_DCSYSTIME, sizeof(DCtime), &DCtE);
000584  2000              MOVS     r0,#0
000586  9000              STR      r0,[sp,#0]
000588  a906              ADD      r1,sp,#0x18
00058a  2204              MOVS     r2,#4
00058c  e9cd2103          STRD     r2,r1,[sp,#0xc]
000590  f44f6311          MOV      r3,#0x910
000594  e9cdb301          STRD     r11,r3,[sp,#4]
000598  4639              MOV      r1,r7
00059a  462b              MOV      r3,r5
00059c  220e              MOVS     r2,#0xe
00059e  4650              MOV      r0,r10
0005a0  f7fffffe          BL       ecx_adddatagram
0005a4  b287              UXTH     r7,r0
;;;557       wkc = ecx_srconfirm(port, idx, timeout);
0005a6  4629              MOV      r1,r5
0005a8  4650              MOV      r0,r10
0005aa  9a14              LDR      r2,[sp,#0x50]
0005ac  f7fffffe          BL       ecx_srconfirm
;;;558       if ((wkc > 0) && (port->rxbuf[idx][EC_CMDOFFSET] == EC_CMD_LRW))
0005b0  9000              STR      r0,[sp,#0]
0005b2  2800              CMP      r0,#0
0005b4  dd14              BLE      |L1.1504|
0005b6  7ea0              LDRB     r0,[r4,#0x1a]
0005b8  280c              CMP      r0,#0xc
0005ba  d111              BNE      |L1.1504|
;;;559       {
;;;560          memcpy(data, &(port->rxbuf[idx][EC_HEADERSIZE]), length);
0005bc  f1040124          ADD      r1,r4,#0x24
0005c0  4632              MOV      r2,r6
0005c2  4648              MOV      r0,r9
0005c4  f7fffffe          BL       __aeabi_memcpy
;;;561          memcpy(&wkc, &(port->rxbuf[idx][EC_HEADERSIZE + length]), EC_WKCSIZE);
0005c8  19a0              ADDS     r0,r4,r6
0005ca  8c80              LDRH     r0,[r0,#0x24]
0005cc  f8ad0000          STRH     r0,[sp,#0]
;;;562          memcpy(&DCtE, &(port->rxbuf[idx][DCtO]), sizeof(*DCtime));
0005d0  19e0              ADDS     r0,r4,r7
0005d2  6981              LDR      r1,[r0,#0x18]
0005d4  9106              STR      r1,[sp,#0x18]
0005d6  69c0              LDR      r0,[r0,#0x1c]
;;;563          *DCtime = etohll(DCtE);
0005d8  460a              MOV      r2,r1
0005da  9007              STR      r0,[sp,#0x1c]
0005dc  e9c82000          STRD     r2,r0,[r8,#0]
                  |L1.1504|
;;;564       }
;;;565       ecx_setbufstat(port, idx, EC_BUF_EMPTY);
0005e0  2200              MOVS     r2,#0
0005e2  4629              MOV      r1,r5
0005e4  4650              MOV      r0,r10
0005e6  f7fffffe          BL       ecx_setbufstat
;;;566    
;;;567       return wkc;
0005ea  9800              LDR      r0,[sp,#0]
;;;568    }
0005ec  b009              ADD      sp,sp,#0x24
0005ee  e8bd8ff0          POP      {r4-r11,pc}
;;;569    
                          ENDP

                  ec_setupdatagram PROC
;;;570    #ifdef EC_VER1
;;;571    int ec_setupdatagram(void *frame, uint8 com, uint8 idx, uint16 ADP, uint16 ADO, uint16 length, void *data)
0005f2  b57f              PUSH     {r0-r6,lr}
;;;572    {
0005f4  f10d0c20          ADD      r12,sp,#0x20
0005f8  461c              MOV      r4,r3
0005fa  4615              MOV      r5,r2
0005fc  460e              MOV      r6,r1
0005fe  e89c000e          LDM      r12,{r1-r3}
;;;573       return ecx_setupdatagram (&ecx_port, frame, com, idx, ADP, ADO, length, data);
000602  f10d0c04          ADD      r12,sp,#4
000606  9400              STR      r4,[sp,#0]
000608  e88c000e          STM      r12,{r1-r3}
00060c  4601              MOV      r1,r0
00060e  462b              MOV      r3,r5
000610  4632              MOV      r2,r6
000612  4871              LDR      r0,|L1.2008|
000614  f7fffffe          BL       ecx_setupdatagram
;;;574    }
000618  b004              ADD      sp,sp,#0x10
00061a  bd70              POP      {r4-r6,pc}
;;;575    
                          ENDP

                  ec_adddatagram PROC
;;;576    int ec_adddatagram (void *frame, uint8 com, uint8 idx, boolean more, uint16 ADP, uint16 ADO, uint16 length, void *data)
00061c  b5f0              PUSH     {r4-r7,lr}
;;;577    {
00061e  b085              SUB      sp,sp,#0x14
000620  f10d0c28          ADD      r12,sp,#0x28
000624  461d              MOV      r5,r3
000626  4616              MOV      r6,r2
000628  460f              MOV      r7,r1
00062a  e89c001e          LDM      r12,{r1-r4}
;;;578       return ecx_adddatagram (&ecx_port, frame, com, idx, more, ADP, ADO, length, data);
00062e  f10d0c04          ADD      r12,sp,#4
000632  9500              STR      r5,[sp,#0]
000634  e88c001e          STM      r12,{r1-r4}
000638  4601              MOV      r1,r0
00063a  4633              MOV      r3,r6
00063c  463a              MOV      r2,r7
00063e  4866              LDR      r0,|L1.2008|
000640  f7fffffe          BL       ecx_adddatagram
;;;579    }
000644  b005              ADD      sp,sp,#0x14
000646  bdf0              POP      {r4-r7,pc}
;;;580    
                          ENDP

                  ec_BWR PROC
;;;581    int ec_BWR(uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
000648  b51c              PUSH     {r2-r4,lr}
;;;582    {
00064a  460c              MOV      r4,r1
00064c  9904              LDR      r1,[sp,#0x10]
00064e  e9cd3100          STRD     r3,r1,[sp,#0]
;;;583       return ecx_BWR (&ecx_port, ADP, ADO, length, data, timeout);
000652  4613              MOV      r3,r2
000654  4601              MOV      r1,r0
000656  4622              MOV      r2,r4
000658  485f              LDR      r0,|L1.2008|
00065a  f7fffffe          BL       ecx_BWR
;;;584    }
00065e  bd1c              POP      {r2-r4,pc}
;;;585    
                          ENDP

                  ec_BRD PROC
;;;586    int ec_BRD(uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
000660  b51c              PUSH     {r2-r4,lr}
;;;587    {
000662  460c              MOV      r4,r1
000664  9904              LDR      r1,[sp,#0x10]
000666  e9cd3100          STRD     r3,r1,[sp,#0]
;;;588       return ecx_BRD(&ecx_port, ADP, ADO, length, data, timeout);
00066a  4613              MOV      r3,r2
00066c  4601              MOV      r1,r0
00066e  4622              MOV      r2,r4
000670  4859              LDR      r0,|L1.2008|
000672  f7fffffe          BL       ecx_BRD
;;;589    }
000676  bd1c              POP      {r2-r4,pc}
;;;590    
                          ENDP

                  ec_APRD PROC
;;;591    int ec_APRD(uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
000678  b51c              PUSH     {r2-r4,lr}
;;;592    {
00067a  460c              MOV      r4,r1
00067c  9904              LDR      r1,[sp,#0x10]
00067e  e9cd3100          STRD     r3,r1,[sp,#0]
;;;593       return ecx_APRD(&ecx_port, ADP, ADO, length, data, timeout);
000682  4613              MOV      r3,r2
000684  4601              MOV      r1,r0
000686  4622              MOV      r2,r4
000688  4853              LDR      r0,|L1.2008|
00068a  f7fffffe          BL       ecx_APRD
;;;594    }
00068e  bd1c              POP      {r2-r4,pc}
;;;595    
                          ENDP

                  ec_ARMW PROC
;;;596    int ec_ARMW(uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
000690  b51c              PUSH     {r2-r4,lr}
;;;597    {
000692  460c              MOV      r4,r1
000694  9904              LDR      r1,[sp,#0x10]
000696  e9cd3100          STRD     r3,r1,[sp,#0]
;;;598       return ecx_ARMW(&ecx_port, ADP, ADO, length, data, timeout);
00069a  4613              MOV      r3,r2
00069c  4601              MOV      r1,r0
00069e  4622              MOV      r2,r4
0006a0  484d              LDR      r0,|L1.2008|
0006a2  f7fffffe          BL       ecx_ARMW
;;;599    }
0006a6  bd1c              POP      {r2-r4,pc}
;;;600    
                          ENDP

                  ec_FRMW PROC
;;;601    int ec_FRMW(uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
0006a8  b51c              PUSH     {r2-r4,lr}
;;;602    {
0006aa  460c              MOV      r4,r1
0006ac  9904              LDR      r1,[sp,#0x10]
0006ae  e9cd3100          STRD     r3,r1,[sp,#0]
;;;603       return ecx_FRMW(&ecx_port, ADP, ADO, length, data, timeout);
0006b2  4613              MOV      r3,r2
0006b4  4601              MOV      r1,r0
0006b6  4622              MOV      r2,r4
0006b8  4847              LDR      r0,|L1.2008|
0006ba  f7fffffe          BL       ecx_FRMW
;;;604    }
0006be  bd1c              POP      {r2-r4,pc}
;;;605    
                          ENDP

                  ec_APRDw PROC
;;;606    uint16 ec_APRDw(uint16 ADP, uint16 ADO, int timeout)
0006c0  b51c              PUSH     {r2-r4,lr}
;;;607    {
;;;608       uint16 w;
;;;609    
;;;610       w = 0;
0006c2  2300              MOVS     r3,#0
0006c4  f8ad3004          STRH     r3,[sp,#4]
;;;611       ec_APRD(ADP, ADO, sizeof(w), &w, timeout);
0006c8  9200              STR      r2,[sp,#0]
0006ca  ab01              ADD      r3,sp,#4
0006cc  2202              MOVS     r2,#2
0006ce  f7fffffe          BL       ec_APRD
;;;612    
;;;613       return w;
0006d2  f8bd0004          LDRH     r0,[sp,#4]
;;;614    }
0006d6  bd1c              POP      {r2-r4,pc}
;;;615    
                          ENDP

                  ec_FPRD PROC
;;;616    int ec_FPRD(uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
0006d8  b51c              PUSH     {r2-r4,lr}
;;;617    {
0006da  460c              MOV      r4,r1
0006dc  9904              LDR      r1,[sp,#0x10]
0006de  e9cd3100          STRD     r3,r1,[sp,#0]
;;;618       return ecx_FPRD(&ecx_port, ADP, ADO, length, data, timeout);
0006e2  4613              MOV      r3,r2
0006e4  4601              MOV      r1,r0
0006e6  4622              MOV      r2,r4
0006e8  483b              LDR      r0,|L1.2008|
0006ea  f7fffffe          BL       ecx_FPRD
;;;619    }
0006ee  bd1c              POP      {r2-r4,pc}
;;;620    
                          ENDP

                  ec_FPRDw PROC
;;;621    uint16 ec_FPRDw(uint16 ADP, uint16 ADO, int timeout)
0006f0  b51c              PUSH     {r2-r4,lr}
;;;622    {
;;;623       uint16 w;
;;;624    
;;;625       w = 0;
0006f2  2300              MOVS     r3,#0
0006f4  f8ad3004          STRH     r3,[sp,#4]
;;;626       ec_FPRD(ADP, ADO, sizeof(w), &w, timeout);
0006f8  9200              STR      r2,[sp,#0]
0006fa  ab01              ADD      r3,sp,#4
0006fc  2202              MOVS     r2,#2
0006fe  f7fffffe          BL       ec_FPRD
;;;627       return w;
000702  f8bd0004          LDRH     r0,[sp,#4]
;;;628    }
000706  bd1c              POP      {r2-r4,pc}
;;;629    
                          ENDP

                  ec_APWR PROC
;;;630    int ec_APWR(uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
000708  b51c              PUSH     {r2-r4,lr}
;;;631    {
00070a  460c              MOV      r4,r1
00070c  9904              LDR      r1,[sp,#0x10]
00070e  e9cd3100          STRD     r3,r1,[sp,#0]
;;;632       return ecx_APWR(&ecx_port, ADP, ADO, length, data, timeout);
000712  4613              MOV      r3,r2
000714  4601              MOV      r1,r0
000716  4622              MOV      r2,r4
000718  482f              LDR      r0,|L1.2008|
00071a  f7fffffe          BL       ecx_APWR
;;;633    }
00071e  bd1c              POP      {r2-r4,pc}
;;;634    
                          ENDP

                  ec_APWRw PROC
;;;635    int ec_APWRw(uint16 ADP, uint16 ADO, uint16 data, int timeout)
000720  b50f              PUSH     {r0-r3,lr}
;;;636    {
000722  b081              SUB      sp,sp,#4
;;;637       return ec_APWR(ADP, ADO, sizeof(data), &data, timeout);
000724  2202              MOVS     r2,#2
000726  9300              STR      r3,[sp,#0]
000728  ab03              ADD      r3,sp,#0xc
00072a  f7fffffe          BL       ec_APWR
                  |L1.1838|
;;;638    }
00072e  b005              ADD      sp,sp,#0x14
000730  bd00              POP      {pc}
;;;639    
                          ENDP

                  ec_FPWR PROC
;;;640    int ec_FPWR(uint16 ADP, uint16 ADO, uint16 length, void *data, int timeout)
000732  b51c              PUSH     {r2-r4,lr}
;;;641    {
000734  460c              MOV      r4,r1
000736  9904              LDR      r1,[sp,#0x10]
000738  e9cd3100          STRD     r3,r1,[sp,#0]
;;;642       return ecx_FPWR(&ecx_port, ADP, ADO, length, data, timeout);
00073c  4613              MOV      r3,r2
00073e  4601              MOV      r1,r0
000740  4622              MOV      r2,r4
000742  4825              LDR      r0,|L1.2008|
000744  f7fffffe          BL       ecx_FPWR
;;;643    }
000748  bd1c              POP      {r2-r4,pc}
;;;644    
                          ENDP

                  ec_FPWRw PROC
;;;645    int ec_FPWRw(uint16 ADP, uint16 ADO, uint16 data, int timeout)
00074a  b50f              PUSH     {r0-r3,lr}
;;;646    {
00074c  b081              SUB      sp,sp,#4
;;;647       return ec_FPWR(ADP, ADO, sizeof(data), &data, timeout);
00074e  2202              MOVS     r2,#2
000750  9300              STR      r3,[sp,#0]
000752  ab03              ADD      r3,sp,#0xc
000754  f7fffffe          BL       ec_FPWR
;;;648    }
000758  e7e9              B        |L1.1838|
;;;649    
                          ENDP

                  ec_LRW PROC
;;;650    int ec_LRW(uint32 LogAdr, uint16 length, void *data, int timeout)
00075a  b508              PUSH     {r3,lr}
;;;651    {
;;;652       return ecx_LRW(&ecx_port, LogAdr, length, data, timeout);
00075c  9300              STR      r3,[sp,#0]
00075e  4613              MOV      r3,r2
000760  460a              MOV      r2,r1
000762  4601              MOV      r1,r0
000764  481c              LDR      r0,|L1.2008|
000766  f7fffffe          BL       ecx_LRW
;;;653    }
00076a  bd08              POP      {r3,pc}
;;;654    
                          ENDP

                  ec_LRD PROC
;;;655    int ec_LRD(uint32 LogAdr, uint16 length, void *data, int timeout)
00076c  b508              PUSH     {r3,lr}
;;;656    {
;;;657       return ecx_LRD(&ecx_port, LogAdr, length, data, timeout);
00076e  9300              STR      r3,[sp,#0]
000770  4613              MOV      r3,r2
000772  460a              MOV      r2,r1
000774  4601              MOV      r1,r0
000776  4818              LDR      r0,|L1.2008|
000778  f7fffffe          BL       ecx_LRD
;;;658    }
00077c  bd08              POP      {r3,pc}
;;;659    
                          ENDP

                  ec_LWR PROC
;;;660    int ec_LWR(uint32 LogAdr, uint16 length, void *data, int timeout)
00077e  b508              PUSH     {r3,lr}
;;;661    {
;;;662       return ecx_LWR(&ecx_port, LogAdr, length, data, timeout);
000780  9300              STR      r3,[sp,#0]
000782  4613              MOV      r3,r2
000784  460a              MOV      r2,r1
000786  4601              MOV      r1,r0
000788  4813              LDR      r0,|L1.2008|
00078a  f7fffffe          BL       ecx_LWR
;;;663    }
00078e  bd08              POP      {r3,pc}
;;;664    
                          ENDP

                  ec_LRWDC PROC
;;;665    int ec_LRWDC(uint32 LogAdr, uint16 length, void *data, uint16 DCrs, int64 *DCtime, int timeout)
000790  b53e              PUSH     {r1-r5,lr}
;;;666    {
000792  4614              MOV      r4,r2
000794  460d              MOV      r5,r1
000796  e9dd1206          LDRD     r1,r2,[sp,#0x18]
;;;667       return ecx_LRWDC(&ecx_port, LogAdr, length, data, DCrs, DCtime, timeout);
00079a  e9cd3100          STRD     r3,r1,[sp,#0]
00079e  9202              STR      r2,[sp,#8]
0007a0  4601              MOV      r1,r0
0007a2  4623              MOV      r3,r4
0007a4  462a              MOV      r2,r5
0007a6  480c              LDR      r0,|L1.2008|
0007a8  f7fffffe          BL       ecx_LRWDC
;;;668    }
0007ac  bd3e              POP      {r1-r5,pc}
;;;669    #endif
                          ENDP

                  ecx_writedatagramdata PROC
;;;64      */
;;;65     static void ecx_writedatagramdata(void *datagramdata, ec_cmdtype com, uint16 length, const void * data)
0007ae  2a00              CMP      r2,#0
;;;66     {
0007b0  d010              BEQ      |L1.2004|
;;;67        if (length > 0)
;;;68        {
;;;69           switch (com)
0007b2  2904              CMP      r1,#4
0007b4  d00b              BEQ      |L1.1998|
0007b6  dc03              BGT      |L1.1984|
0007b8  b149              CBZ      r1,|L1.1998|
0007ba  2901              CMP      r1,#1
0007bc  d104              BNE      |L1.1992|
0007be  e006              B        |L1.1998|
                  |L1.1984|
0007c0  2907              CMP      r1,#7
0007c2  d004              BEQ      |L1.1998|
0007c4  290a              CMP      r1,#0xa
0007c6  d002              BEQ      |L1.1998|
                  |L1.1992|
;;;70           {
;;;71              case EC_CMD_NOP:
;;;72                 /* Fall-through */
;;;73              case EC_CMD_APRD:
;;;74                 /* Fall-through */
;;;75              case EC_CMD_FPRD:
;;;76                 /* Fall-through */
;;;77              case EC_CMD_BRD:
;;;78                 /* Fall-through */
;;;79              case EC_CMD_LRD:
;;;80                 /* no data to write. initialise data so frame is in a known state */
;;;81                 memset(datagramdata, 0, length);
;;;82                 break;
;;;83              default:
;;;84                 memcpy(datagramdata, data, length);
0007c8  4619              MOV      r1,r3
0007ca  f7ffbffe          B.W      __aeabi_memcpy
                  |L1.1998|
0007ce  4611              MOV      r1,r2                 ;81
0007d0  f7ffbffe          B.W      __aeabi_memclr
                  |L1.2004|
;;;85                 break;
;;;86           }
;;;87        }
;;;88     }
0007d4  4770              BX       lr
;;;89     
                          ENDP

0007d6  0000              DCW      0x0000
                  |L1.2008|
                          DCD      ecx_port
