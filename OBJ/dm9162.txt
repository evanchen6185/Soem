; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\dm9162.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\dm9162.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\FWLIB\STM32F4xx_StdPeriph_Driver\inc -I..\USER -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\ETHERNET -I..\HARDWARE\TIMER -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\RTC -I..\HARDWARE\ADC -I..\HARDWARE\SRAM -I..\HARDWARE\InterTemperate -I..\FWLIB\STM32F4x7_ETH_Driver\inc -I..\MALLOC -I..\USMART -I..\HARDWARE -I..\ETHERCAT -I.\RTE\_LWIP -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS --omf_browse=..\obj\dm9162.crf ..\HARDWARE\ETHERNET\DM9162.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ETH_MACDMA_Config PROC
;;;67     
;;;68     u8 ETH_MACDMA_Config(void)
000000  b500              PUSH     {lr}
;;;69     {
000002  b0af              SUB      sp,sp,#0xbc
;;;70     	u8 rval;
;;;71     	ETH_InitTypeDef ETH_InitStructure; 
;;;72     	
;;;73     	//使能以太网时钟
;;;74     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx |RCC_AHB1Periph_ETH_MAC_Rx, ENABLE);
000004  2101              MOVS     r1,#1
000006  f04f6060          MOV      r0,#0xe000000
00000a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;75                             
;;;76     	ETH_DeInit();  								//AHB总线重启以太网
00000e  f7fffffe          BL       ETH_DeInit
;;;77     	ETH_SoftwareReset();  						//软件重启网络
000012  f7fffffe          BL       ETH_SoftwareReset
                  |L1.22|
;;;78     	while (ETH_GetSoftwareResetStatus() == SET);//等待软件重启网络完成
000016  f7fffffe          BL       ETH_GetSoftwareResetStatus
00001a  2801              CMP      r0,#1
00001c  d0fb              BEQ      |L1.22|
;;;79     	
;;;80     	ETH_StructInit(&ETH_InitStructure); 	 	//初始化网络为默认值  
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       ETH_StructInit
;;;81     
;;;82     	///网络MAC参数设置 
;;;83     	ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;   			//开启网络自适应功能
000024  2001              MOVS     r0,#1
;;;84     	ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;					//关闭反馈
000026  9000              STR      r0,[sp,#0]
000028  2000              MOVS     r0,#0
;;;85     	ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable; 		//关闭重传功能
00002a  f44f7100          MOV      r1,#0x200
00002e  e9cd100a          STRD     r1,r0,[sp,#0x28]
;;;86     	ETH_InitStructure.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable; 	//关闭自动去除PDA/CRC功能 
;;;87     	ETH_InitStructure.ETH_ReceiveAll = ETH_ReceiveAll_Enable;						//关闭接收所有的帧
000032  0589              LSLS     r1,r1,#22
;;;88     	ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Enable;//允许接收所有广播帧
;;;89     	ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;			//关闭混合模式的地址过滤  
;;;90     	ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;//对于组播地址使用完美地址过滤   
000034  9013              STR      r0,[sp,#0x4c]
;;;91     	ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;	//对单播地址使用完美地址过滤 
;;;92     	ETH_InitStructure.ETH_ChecksumOffload = ETH_ChecksumOffload_Enable; 			//开启ipv4和TCP/UDP/ICMP的帧校验和卸载   
000036  910e              STR      r1,[sp,#0x38]
000038  0d49              LSRS     r1,r1,#21
;;;93     	//当我们使用帧校验和卸载功能的时候，一定要使能存储转发模式,存储转发模式中要保证整个帧存储在FIFO中,
;;;94     	//这样MAC能插入/识别出帧校验值,当真校验正确的时候DMA就可以处理帧,否则就丢弃掉该帧
;;;95     	ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; //开启丢弃TCP/IP错误帧
;;;96     	ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;     //开启接收数据的存储转发模式    
00003a  9109              STR      r1,[sp,#0x24]
00003c  03c9              LSLS     r1,r1,#15
00003e  9007              STR      r0,[sp,#0x1c]         ;85
000040  9011              STR      r0,[sp,#0x44]         ;89
;;;97     	ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;   //开启发送数据的存储转发模式  
000042  e9cd0120          STRD     r0,r1,[sp,#0x80]
000046  9014              STR      r0,[sp,#0x50]         ;91
000048  9015              STR      r0,[sp,#0x54]         ;92
00004a  110a              ASRS     r2,r1,#4
;;;98     
;;;99     	ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;     	//禁止转发错误帧  
;;;100    	ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;	//不转发过小的好帧 
00004c  9025              STR      r0,[sp,#0x94]
;;;101    	ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;  		//打开处理第二帧功能
00004e  9026              STR      r0,[sp,#0x98]
000050  9223              STR      r2,[sp,#0x8c]         ;97
000052  2004              MOVS     r0,#4
000054  e9cd0128          STRD     r0,r1,[sp,#0xa0]
;;;102    	ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;  	//开启DMA传输的地址对齐功能
;;;103    	ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;            			//开启固定突发功能    
000058  0380              LSLS     r0,r0,#14
;;;104    	ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;     		//DMA发送的最大突发长度为32个节拍   
00005a  902a              STR      r0,[sp,#0xa8]
00005c  0180              LSLS     r0,r0,#6
;;;105    	ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;			//DMA接收的最大突发长度为32个节拍
00005e  902b              STR      r0,[sp,#0xac]
000060  1240              ASRS     r0,r0,#9
;;;106    	ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;
000062  902c              STR      r0,[sp,#0xb0]
000064  0040              LSLS     r0,r0,#1
;;;107    
;;;108    	rval=ETH_Init(&ETH_InitStructure,DM9162_PHY_ADDRESS);		//配置ETH
000066  902e              STR      r0,[sp,#0xb8]
000068  2101              MOVS     r1,#1
00006a  4668              MOV      r0,sp
00006c  f7fffffe          BL       ETH_Init
;;;109    
;;;110    	EthStatus=rval;
000070  4993              LDR      r1,|L1.704|
000072  b2c0              UXTB     r0,r0                 ;108
000074  6008              STR      r0,[r1,#0]  ; EthStatus
;;;111    //	if(rval==ETH_SUCCESS)//配置成功
;;;112    //	{
;;;113    //		ETH_DMAITConfig(ETH_DMA_IT_NIS|ETH_DMA_IT_R,ENABLE);  	//使能以太网接收中断	
;;;114    //	}
;;;115    	return rval;
;;;116    }
000076  b02f              ADD      sp,sp,#0xbc
000078  bd00              POP      {pc}
;;;117    
                          ENDP

                  ETH_GPIO_Config_RMII PROC
;;;326      */
;;;327    static void ETH_GPIO_Config_RMII(void)
00007a  b57c              PUSH     {r2-r6,lr}
;;;328    {
;;;329    	GPIO_InitTypeDef GPIO_InitStructure;
;;;330    
;;;331    	/* 安富莱STM32-F4开发板网卡接口采用RMII
;;;332    		PA1/ETH_RMII_RX_CLK
;;;333    		PA2/ETH_MDIO
;;;334    		PA7/RMII_CRS_DV
;;;335    		PC1/ETH_MDC
;;;336    		PC4/ETH_RMII_RX_D0
;;;337    		PC5/ETH_RMII_RX_D1
;;;338    		PG11/ETH_RMII_TX_EN
;;;339    		PG13/FSMC_A24/ETH_RMII_TXD0
;;;340    		PG14/ETH_RMII_TXD1
;;;341    
;;;342    		PH6/MII_INT
;;;343    	*/
;;;344    	/* Enable GPIOs clocks */
;;;345    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOG |
00007c  2101              MOVS     r1,#1
00007e  20c5              MOVS     r0,#0xc5
000080  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;346    	                     RCC_AHB1Periph_GPIOH, ENABLE);
;;;347    
;;;348    	/* Enable SYSCFG clock */
;;;349    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
000084  2101              MOVS     r1,#1
000086  0388              LSLS     r0,r1,#14
000088  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;350    
;;;351    	SYSCFG_ETH_MediaInterfaceConfig(SYSCFG_ETH_MediaInterface_RMII);
00008c  2001              MOVS     r0,#1
00008e  f7fffffe          BL       SYSCFG_ETH_MediaInterfaceConfig
;;;352    
;;;353    	/* Configure PA1, PA2 and PA7 */
;;;354    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000092  2503              MOVS     r5,#3
000094  f88d5005          STRB     r5,[sp,#5]
;;;355    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000098  2002              MOVS     r0,#2
00009a  f88d0004          STRB     r0,[sp,#4]
;;;356    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00009e  2400              MOVS     r4,#0
;;;357    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;358    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_7;
0000a0  2086              MOVS     r0,#0x86
;;;359    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000a2  4e88              LDR      r6,|L1.708|
0000a4  f88d4006          STRB     r4,[sp,#6]            ;356
0000a8  9000              STR      r0,[sp,#0]
0000aa  f88d4007          STRB     r4,[sp,#7]            ;357
0000ae  4669              MOV      r1,sp
0000b0  4630              MOV      r0,r6
0000b2  f7fffffe          BL       GPIO_Init
;;;360    
;;;361    	GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_ETH);
0000b6  220b              MOVS     r2,#0xb
0000b8  2101              MOVS     r1,#1
0000ba  4630              MOV      r0,r6
0000bc  f7fffffe          BL       GPIO_PinAFConfig
;;;362    	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_ETH);
0000c0  220b              MOVS     r2,#0xb
0000c2  2102              MOVS     r1,#2
0000c4  4630              MOV      r0,r6
0000c6  f7fffffe          BL       GPIO_PinAFConfig
;;;363    	GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_ETH);
0000ca  220b              MOVS     r2,#0xb
0000cc  2107              MOVS     r1,#7
0000ce  4630              MOV      r0,r6
0000d0  f7fffffe          BL       GPIO_PinAFConfig
;;;364    
;;;365    	/* Configure PC1, PC4 and PC5 */
;;;366    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5;
0000d4  2032              MOVS     r0,#0x32
;;;367    	GPIO_Init(GPIOC, &GPIO_InitStructure);
0000d6  4e7c              LDR      r6,|L1.712|
0000d8  9000              STR      r0,[sp,#0]
0000da  4669              MOV      r1,sp
0000dc  4630              MOV      r0,r6
0000de  f7fffffe          BL       GPIO_Init
;;;368    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource1, GPIO_AF_ETH);
0000e2  220b              MOVS     r2,#0xb
0000e4  2101              MOVS     r1,#1
0000e6  4630              MOV      r0,r6
0000e8  f7fffffe          BL       GPIO_PinAFConfig
;;;369    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource4, GPIO_AF_ETH);
0000ec  220b              MOVS     r2,#0xb
0000ee  2104              MOVS     r1,#4
0000f0  4630              MOV      r0,r6
0000f2  f7fffffe          BL       GPIO_PinAFConfig
;;;370    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource5, GPIO_AF_ETH);
0000f6  220b              MOVS     r2,#0xb
0000f8  2105              MOVS     r1,#5
0000fa  4630              MOV      r0,r6
0000fc  f7fffffe          BL       GPIO_PinAFConfig
;;;371    
;;;372    	/* Configure PG11, PG14 and PG13 */
;;;373    	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11 | GPIO_Pin_13 | GPIO_Pin_14;
000100  f44f40d0          MOV      r0,#0x6800
;;;374    	GPIO_Init(GPIOG, &GPIO_InitStructure);
000104  4e71              LDR      r6,|L1.716|
000106  9000              STR      r0,[sp,#0]
000108  4669              MOV      r1,sp
00010a  4630              MOV      r0,r6
00010c  f7fffffe          BL       GPIO_Init
;;;375    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource11, GPIO_AF_ETH);
000110  220b              MOVS     r2,#0xb
000112  4611              MOV      r1,r2
000114  4630              MOV      r0,r6
000116  f7fffffe          BL       GPIO_PinAFConfig
;;;376    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource13, GPIO_AF_ETH);
00011a  220b              MOVS     r2,#0xb
00011c  210d              MOVS     r1,#0xd
00011e  4630              MOV      r0,r6
000120  f7fffffe          BL       GPIO_PinAFConfig
;;;377    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource14, GPIO_AF_ETH);
000124  220b              MOVS     r2,#0xb
000126  210e              MOVS     r1,#0xe
000128  4630              MOV      r0,r6
00012a  f7fffffe          BL       GPIO_PinAFConfig
;;;378    	
;;;379    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);
00012e  2101              MOVS     r1,#1
000130  2002              MOVS     r0,#2
000132  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;380    		/*dm9161复位硬引脚*/
;;;381    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; 		//PB10 推挽输出 
;;;382    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;//推挽输出
000136  2001              MOVS     r0,#1
000138  f88d0004          STRB     r0,[sp,#4]
;;;383    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
00013c  f88d5005          STRB     r5,[sp,#5]
;;;384    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000140  f88d4006          STRB     r4,[sp,#6]
;;;385    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000144  f88d4007          STRB     r4,[sp,#7]
;;;386    	GPIO_Init(GPIOB,&GPIO_InitStructure);
000148  4c61              LDR      r4,|L1.720|
00014a  1536              ASRS     r6,r6,#20             ;381
00014c  9600              STR      r6,[sp,#0]            ;382
00014e  4669              MOV      r1,sp
000150  4620              MOV      r0,r4
000152  f7fffffe          BL       GPIO_Init
;;;387    	
;;;388    	DM9161_RST;								//DM9000硬件复位
000156  4631              MOV      r1,r6
000158  4620              MOV      r0,r4
00015a  f7fffffe          BL       GPIO_ResetBits
;;;389    	Delay_ms(10);
00015e  200a              MOVS     r0,#0xa
000160  f7fffffe          BL       Delay_ms
;;;390    	DM9161_SET; 							//DM9000硬件复位结束
000164  4631              MOV      r1,r6
000166  4620              MOV      r0,r4
000168  f7fffffe          BL       GPIO_SetBits
;;;391    	Delay_ms(100);								
00016c  2064              MOVS     r0,#0x64
00016e  f7fffffe          BL       Delay_ms
;;;392    }
000172  bd7c              POP      {r2-r6,pc}
;;;393    
                          ENDP

                  DM9162_Init PROC
;;;19     //    其他,失败
;;;20     u8 DM9162_Init(void)
000174  b510              PUSH     {r4,lr}
;;;21     {
;;;22     	 u8 rval=0;
;;;23         ETH_GPIO_Config_RMII(); 
000176  f7fffffe          BL       ETH_GPIO_Config_RMII
;;;24     //	ETHERNET_NVICConfiguration();
;;;25     	  rval=ETH_MACDMA_Config();//此处需等待100ms，等待以太网配置完成；
00017a  f7fffffe          BL       ETH_MACDMA_Config
00017e  4604              MOV      r4,r0
;;;26     	  /* Read PHY status register: Get Ethernet link status */
;;;27     		if(ETH_ReadPHYRegister(DM9162_PHY_ADDRESS, PHY_SR) & 4)
000180  2111              MOVS     r1,#0x11
000182  2001              MOVS     r0,#1
000184  f7fffffe          BL       ETH_ReadPHYRegister
000188  0740              LSLS     r0,r0,#29
00018a  d504              BPL      |L1.406|
;;;28     		{
;;;29     			EthStatus |= ETH_LINK_FLAG;
00018c  484c              LDR      r0,|L1.704|
00018e  6801              LDR      r1,[r0,#0]  ; EthStatus
000190  f0410110          ORR      r1,r1,#0x10
000194  6001              STR      r1,[r0,#0]  ; EthStatus
                  |L1.406|
;;;30     		}
;;;31     //  /* Configure the PHY to generate an interrupt on change of link status */
;;;32     //  Eth_Link_PHYITConfig(DM9162_PHY_ADDRESS);
;;;33     //  /* Configure the EXTI for Ethernet link status. */
;;;34     //    Eth_Link_EXTIConfig();
;;;35     	  return !rval;					//ETH的规则为:0,失败;1,成功;所以要取反一下 
000196  b10c              CBZ      r4,|L1.412|
000198  2000              MOVS     r0,#0
;;;36     }
00019a  bd10              POP      {r4,pc}
                  |L1.412|
00019c  2001              MOVS     r0,#1                 ;35
00019e  bd10              POP      {r4,pc}
;;;37     //得到8720的速度模式
                          ENDP

                  MAC_Init PROC
;;;43     //其他:错误.
;;;44     void MAC_Init(void)
0001a0  b570              PUSH     {r4-r6,lr}
;;;45     {
;;;46         int i;
;;;47     
;;;48         /* initialize MAC address in ethernet MAC */
;;;49         ETH_MACAddressConfig(ETH_MAC_Address0, MyMacAddr);
0001a2  4947              LDR      r1,|L1.704|
0001a4  2000              MOVS     r0,#0
0001a6  1d09              ADDS     r1,r1,#4
0001a8  f7fffffe          BL       ETH_MACAddressConfig
;;;50         /* Initialize Tx Descriptors list: Chain Mode */
;;;51         ETH_DMATxDescChainInit(DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
0001ac  2205              MOVS     r2,#5
0001ae  4949              LDR      r1,|L1.724|
0001b0  4849              LDR      r0,|L1.728|
0001b2  f7fffffe          BL       ETH_DMATxDescChainInit
;;;52         /* Initialize Rx Descriptors list: Chain Mode  */
;;;53         ETH_DMARxDescChainInit(DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
0001b6  2205              MOVS     r2,#5
0001b8  4948              LDR      r1,|L1.732|
0001ba  4849              LDR      r0,|L1.736|
0001bc  f7fffffe          BL       ETH_DMARxDescChainInit
0001c0  4d45              LDR      r5,|L1.728|
;;;54      
;;;55         /* Enable the TCP, UDP and ICMP checksum insertion for the Tx frames */
;;;56         for(i = 0; i < ETH_TXBUFNB; i++) {
0001c2  2400              MOVS     r4,#0
;;;57             ETH_DMATxDescChecksumInsertionConfig(&DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull);
0001c4  f44f0640          MOV      r6,#0xc00000
                  |L1.456|
0001c8  eb051044          ADD      r0,r5,r4,LSL #5
0001cc  4631              MOV      r1,r6
0001ce  f7fffffe          BL       ETH_DMATxDescChecksumInsertionConfig
0001d2  1c64              ADDS     r4,r4,#1
0001d4  2c05              CMP      r4,#5                 ;56
0001d6  dbf7              BLT      |L1.456|
;;;58         }
;;;59         ETH_Start();
0001d8  e8bd4070          POP      {r4-r6,lr}
0001dc  f7ffbffe          B.W      ETH_Start
;;;60     }
;;;61     /////////////////////////////////////////////////////////////////////////////////////////////////
                          ENDP

                  ETH_Rx_Packet PROC
;;;129    //返回值:网络数据包帧结构体
;;;130    FrameTypeDef ETH_Rx_Packet(void)
0001e0  b530              PUSH     {r4,r5,lr}
;;;131    { 
;;;132    	uint32_t framelength = 0;
;;;133      FrameTypeDef frame = {0,0,0}; 
;;;134      
;;;135      /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
;;;136      framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
0001e2  4c40              LDR      r4,|L1.740|
0001e4  6821              LDR      r1,[r4,#0]  ; DMARxDescToGet
0001e6  680a              LDR      r2,[r1,#0]
0001e8  f3c2430d          UBFX     r3,r2,#16,#14
;;;137      frame.length = framelength;
;;;138      
;;;139      /* Get the address of the buffer start address */ 
;;;140      /* Check if more than one segment in the frame */
;;;141      if (DMA_RX_FRAME_infos->Seg_Count >1)
0001ec  4a3e              LDR      r2,|L1.744|
0001ee  6812              LDR      r2,[r2,#0]  ; DMA_RX_FRAME_infos
0001f0  6895              LDR      r5,[r2,#8]
0001f2  1f1b              SUBS     r3,r3,#4
0001f4  2d01              CMP      r5,#1
0001f6  d902              BLS      |L1.510|
;;;142      {
;;;143        frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
0001f8  6812              LDR      r2,[r2,#0]
0001fa  6892              LDR      r2,[r2,#8]
0001fc  e000              B        |L1.512|
                  |L1.510|
;;;144      }
;;;145      else 
;;;146      {
;;;147        frame.buffer = DMARxDescToGet->Buffer1Addr;
0001fe  688a              LDR      r2,[r1,#8]
                  |L1.512|
;;;148      }
;;;149    
;;;150      frame.descriptor = DMARxDescToGet;
;;;151      
;;;152      /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
;;;153      /* Chained Mode */    
;;;154      /* Selects the next DMA Rx descriptor list for next buffer to read */ 
;;;155      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
000200  68cd              LDR      r5,[r1,#0xc]
;;;156      
;;;157      /* Return Frame */
;;;158      return (frame);  
000202  6025              STR      r5,[r4,#0]  ; DMARxDescToGet
000204  6003              STR      r3,[r0,#0]
000206  e9c02101          STRD     r2,r1,[r0,#4]
;;;159    	
;;;160    	
;;;161    	
;;;162    //	u32 framelength=0;
;;;163    //	FrameTypeDef frame={0,0};   
;;;164    //	//检查当前描述符,是否属于ETHERNET DMA(设置的时候)/CPU(复位的时候)
;;;165    //	if((DMARxDescToGet->Status&ETH_DMARxDesc_OWN)!=(u32)RESET)
;;;166    //	{	
;;;167    //		frame.length=ETH_ERROR; 
;;;168    //		if ((ETH->DMASR&ETH_DMASR_RBUS)!=(u32)RESET)  
;;;169    //		{ 
;;;170    //			ETH->DMASR = ETH_DMASR_RBUS;//清除ETH DMA的RBUS位  
;;;171    //			ETH->DMARPDR=0;//恢复DMA接收
;;;172    //		}
;;;173    //		return frame;//错误,OWN位被设置了
;;;174    //	}  
;;;175    //	if(((DMARxDescToGet->Status&ETH_DMARxDesc_ES)==(u32)RESET)&& 
;;;176    //	((DMARxDescToGet->Status & ETH_DMARxDesc_LS)!=(u32)RESET)&&  
;;;177    //	((DMARxDescToGet->Status & ETH_DMARxDesc_FS)!=(u32)RESET))  
;;;178    //	{       
;;;179    //		framelength=((DMARxDescToGet->Status&ETH_DMARxDesc_FL)>>ETH_DMARxDesc_FrameLengthShift)-4;//得到接收包帧长度(不包含4字节CRC)
;;;180    // 		frame.buffer = DMARxDescToGet->Buffer1Addr;//得到包数据所在的位置
;;;181    //	}else framelength=ETH_ERROR;//错误  
;;;182    //	frame.length=framelength; 
;;;183    //	frame.descriptor=DMARxDescToGet;  
;;;184    //  asdjsdk.length=framelength;
;;;185    //	asdjsdk.descriptor=DMARxDescToGet;
;;;186    //	//更新ETH DMA全局Rx描述符为下一个Rx描述符
;;;187    //	//为下一次buffer读取设置下一个DMA Rx描述符
;;;188    //	DMARxDescToGet=(ETH_DMADESCTypeDef*)(DMARxDescToGet->Buffer2NextDescAddr); 
;;;189    //  sdfdfsf=(ETH_DMADESCTypeDef*)(DMARxDescToGet->Buffer2NextDescAddr);
;;;190    //	return frame;  
;;;191    }
00020a  bd30              POP      {r4,r5,pc}
;;;192    //发送一个网卡数据包
                          ENDP

                  ETH_Tx_Packet PROC
;;;195    //		ETH_SUCCESS,发送成功(1)
;;;196    u8 ETH_Tx_Packet(u16 FrameLength)
00020c  4a37              LDR      r2,|L1.748|
;;;197    {   
;;;198    	//检查当前描述符,是否属于ETHERNET DMA(设置的时候)/CPU(复位的时候)
;;;199    	if((DMATxDescToSet->Status&ETH_DMATxDesc_OWN)!=(u32)RESET)return ETH_ERROR;//错误,OWN位被设置了 
00020e  6811              LDR      r1,[r2,#0]  ; DMATxDescToSet
000210  680b              LDR      r3,[r1,#0]
000212  2b00              CMP      r3,#0
000214  da01              BGE      |L1.538|
000216  2000              MOVS     r0,#0
;;;200     	DMATxDescToSet->ControlBufferSize=(FrameLength&ETH_DMATxDesc_TBS1);//设置帧长度,bits[12:0]
;;;201    	DMATxDescToSet->Status|=ETH_DMATxDesc_LS|ETH_DMATxDesc_FS;//设置最后一个和第一个位段置位(1个描述符传输一帧)
;;;202      	DMATxDescToSet->Status|=ETH_DMATxDesc_OWN;//设置Tx描述符的OWN位,buffer重归ETH DMA
;;;203    	if((ETH->DMASR&ETH_DMASR_TBUS)!=(u32)RESET)//当Tx Buffer不可用位(TBUS)被设置的时候,重置它.恢复传输
;;;204    	{ 
;;;205    		ETH->DMASR=ETH_DMASR_TBUS;//重置ETH DMA TBUS位 
;;;206    		ETH->DMATPDR=0;//恢复DMA发送
;;;207    	} 
;;;208    	//更新ETH DMA全局Tx描述符为下一个Tx描述符
;;;209    	//为下一次buffer发送设置下一个DMA Tx描述符 
;;;210    	DMATxDescToSet=(ETH_DMADESCTypeDef*)(DMATxDescToSet->Buffer2NextDescAddr); 
;;;211    	return ETH_SUCCESS;   
;;;212    }
000218  4770              BX       lr
                  |L1.538|
00021a  f3c0000c          UBFX     r0,r0,#0,#13          ;200
00021e  6048              STR      r0,[r1,#4]            ;201
000220  6808              LDR      r0,[r1,#0]            ;201
000222  f0405040          ORR      r0,r0,#0x30000000     ;201
000226  6008              STR      r0,[r1,#0]            ;201
000228  6808              LDR      r0,[r1,#0]            ;202
00022a  f0404000          ORR      r0,r0,#0x80000000     ;202
00022e  6008              STR      r0,[r1,#0]            ;202
000230  482f              LDR      r0,|L1.752|
000232  6943              LDR      r3,[r0,#0x14]         ;203
000234  075b              LSLS     r3,r3,#29             ;203
000236  d503              BPL      |L1.576|
000238  2304              MOVS     r3,#4                 ;205
00023a  6143              STR      r3,[r0,#0x14]         ;205
00023c  2300              MOVS     r3,#0                 ;206
00023e  6043              STR      r3,[r0,#4]            ;206
                  |L1.576|
000240  68c8              LDR      r0,[r1,#0xc]          ;210
000242  6010              STR      r0,[r2,#0]            ;211  ; DMATxDescToSet
000244  2001              MOVS     r0,#1                 ;211
000246  4770              BX       lr
;;;213    //得到当前描述符的Tx buffer地址
                          ENDP

                  ETH_GetCurrentTxBuffer PROC
;;;214    //返回值:Tx buffer地址
;;;215    u32 ETH_GetCurrentTxBuffer(void)
000248  4828              LDR      r0,|L1.748|
;;;216    {  
;;;217      return DMATxDescToSet->Buffer1Addr;//返回Tx buffer地址  
00024a  6800              LDR      r0,[r0,#0]  ; DMATxDescToSet
00024c  6880              LDR      r0,[r0,#8]
;;;218    }
00024e  4770              BX       lr
;;;219    void lwip_pkt_handle(void)
                          ENDP

                  lwip_pkt_handle PROC
000250  b53e              PUSH     {r1-r5,lr}
;;;220    {
;;;221    //		 struct pbuf *p, *q;
;;;222    		u16 len;
;;;223    		int l =0;
;;;224    		FrameTypeDef frame;
;;;225    		u8 *buffer;
;;;226    		uint32_t i=0;
000252  2500              MOVS     r5,#0
;;;227    		__IO ETH_DMADESCTypeDef *DMARxNextDesc;
;;;228    		
;;;229    		
;;;230    //		p = NULL;
;;;231    		
;;;232    		/* get received frame */
;;;233    		frame = ETH_Get_Received_Frame();
000254  4668              MOV      r0,sp
000256  f7fffffe          BL       ETH_Get_Received_Frame
00025a  e89d0013          LDM      sp,{r0,r1,r4}
;;;234    		
;;;235    		/* Obtain the size of the packet and put it into the "len" variable. */
;;;236    		len = frame.length;
00025e  b282              UXTH     r2,r0
;;;237    		buffer = (u8 *)frame.buffer;
;;;238    		receiveLen=len;
000260  4824              LDR      r0,|L1.756|
000262  8002              STRH     r2,[r0,#0]
;;;239    	  memcpy((u8 *)receiveBuffer, (u8 *)buffer, len);
000264  4824              LDR      r0,|L1.760|
000266  f7fffffe          BL       __aeabi_memcpy
;;;240    		/* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
;;;241    //		p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
;;;242    		
;;;243    		/* copy received frame to pbuf chain */
;;;244    //		if (p != NULL)
;;;245    //		{
;;;246    //			for (q = p; q != NULL; q = q->next)
;;;247    //			{
;;;248    //				memcpy((u8_t*)q->payload, (u8_t*)&buffer[l], q->len);
;;;249    //				l = l + q->len;
;;;250    //			}    
;;;251    //		}
;;;252    		
;;;253    		/* Release descriptors to DMA */
;;;254    		/* Check if frame with multiple DMA buffer segments */
;;;255    		if (DMA_RX_FRAME_infos->Seg_Count > 1)
00026a  491f              LDR      r1,|L1.744|
00026c  6808              LDR      r0,[r1,#0]  ; DMA_RX_FRAME_infos
00026e  6882              LDR      r2,[r0,#8]
000270  2a01              CMP      r2,#1
000272  d900              BLS      |L1.630|
;;;256    		{
;;;257    			DMARxNextDesc = DMA_RX_FRAME_infos->FS_Rx_Desc;
000274  6804              LDR      r4,[r0,#0]
                  |L1.630|
;;;258    		}
;;;259    		else
;;;260    		{
;;;261    			DMARxNextDesc = frame.descriptor;
;;;262    		}
;;;263    		
;;;264    		/* Set Own bit in Rx descriptors: gives the buffers back to DMA */
;;;265    		for (i=0; i<DMA_RX_FRAME_infos->Seg_Count; i++)
;;;266    		{  
;;;267    			DMARxNextDesc->Status = ETH_DMARxDesc_OWN;
000276  f04f4000          MOV      r0,#0x80000000
00027a  e002              B        |L1.642|
                  |L1.636|
00027c  6020              STR      r0,[r4,#0]
;;;268    			DMARxNextDesc = (ETH_DMADESCTypeDef *)(DMARxNextDesc->Buffer2NextDescAddr);
00027e  68e4              LDR      r4,[r4,#0xc]
000280  1c6d              ADDS     r5,r5,#1
                  |L1.642|
000282  680a              LDR      r2,[r1,#0]            ;265  ; DMA_RX_FRAME_infos
000284  6892              LDR      r2,[r2,#8]            ;265
000286  42aa              CMP      r2,r5                 ;265
000288  d8f8              BHI      |L1.636|
;;;269    		}
;;;270    		
;;;271    		/* Clear Segment_Count */
;;;272    		DMA_RX_FRAME_infos->Seg_Count =0;
00028a  6808              LDR      r0,[r1,#0]  ; DMA_RX_FRAME_infos
00028c  2200              MOVS     r2,#0
00028e  6082              STR      r2,[r0,#8]
;;;273    		
;;;274    		/* When Rx Buffer unavailable flag is set: clear it and resume reception */
;;;275    		if ((ETH->DMASR & ETH_DMASR_RBUS) != (u32)RESET)  
000290  4817              LDR      r0,|L1.752|
000292  6941              LDR      r1,[r0,#0x14]
000294  0609              LSLS     r1,r1,#24
000296  d502              BPL      |L1.670|
;;;276    		{
;;;277    			/* Clear RBUS ETHERNET DMA flag */
;;;278    			ETH->DMASR = ETH_DMASR_RBUS;
000298  2180              MOVS     r1,#0x80
00029a  6141              STR      r1,[r0,#0x14]
;;;279    			/* Resume DMA reception */
;;;280    			ETH->DMARPDR = 0;
00029c  6082              STR      r2,[r0,#8]
                  |L1.670|
;;;281    		}
;;;282    		
;;;283    //	  uint32_t i=0;
;;;284    //    uint32_t *p32;
;;;285    //    FrameTypeDef frame;
;;;286    //	__IO ETH_DMADESCTypeDef *DMARxNextDesc;
;;;287    //    /* get received frame */
;;;288    ////	   receiveLen=0;   
;;;289    ////     memset(receiveBuffer, 0, sizeof(receiveBuffer));
;;;290    //     frame = ETH_Rx_Packet();
;;;291    //    /* Obtain the size of the packet and put it into the "len" variable. */
;;;292    //     receiveLen = frame.length;
;;;293    //	   memcpy((u8*)(receiveBuffer), (u8*)frame.buffer, receiveLen);
;;;294    //    /* Check if frame with multiple DMA buffer segments */
;;;295    //    if (DMA_RX_FRAME_infos->Seg_Count > 1) 
;;;296    //			{
;;;297    //        DMARxNextDesc = DMA_RX_FRAME_infos->FS_Rx_Desc;
;;;298    //       } 
;;;299    //		else 
;;;300    //			{
;;;301    //        DMARxNextDesc = frame.descriptor;
;;;302    //       }
;;;303    //    /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
;;;304    //    for (i = 0; i < DMA_RX_FRAME_infos->Seg_Count; i++) 
;;;305    //			 {
;;;306    //        DMARxNextDesc->Status = ETH_DMARxDesc_OWN;
;;;307    //        DMARxNextDesc = (ETH_DMADESCTypeDef *)(DMARxNextDesc->Buffer2NextDescAddr);
;;;308    //       }
;;;309    //    /* Clear Segment_Count */
;;;310    //    DMA_RX_FRAME_infos->Seg_Count = 0;
;;;311    // 
;;;312    //    /* When Rx Buffer unavailable flag is set: clear it and resume reception */
;;;313    //    if ((ETH->DMASR & ETH_DMASR_RBUS) != (u32)RESET)
;;;314    //			{
;;;315    //        /* Clear RBUS ETHERNET DMA flag */
;;;316    //        ETH->DMASR = ETH_DMASR_RBUS;
;;;317    //        /* Resume DMA reception */
;;;318    //        ETH->DMARPDR = 0;
;;;319    //      }
;;;320    }
00029e  bd3e              POP      {r1-r5,pc}
;;;321    
                          ENDP

                  Eth_Link_PHYITConfig PROC
;;;400      */
;;;401    uint32_t Eth_Link_PHYITConfig(uint16_t PHYAddress)
0002a0  b510              PUSH     {r4,lr}
;;;402    {
0002a2  4604              MOV      r4,r0
;;;403      uint32_t tmpreg = 0;
;;;404    	tmpreg = ETH_ReadPHYRegister(PHYAddress,21);
0002a4  2115              MOVS     r1,#0x15
0002a6  f7fffffe          BL       ETH_ReadPHYRegister
;;;405    	tmpreg &= ~(3<<8);
0002aa  f4207240          BIC      r2,r0,#0x300
;;;406    	if(!(ETH_WritePHYRegister(PHYAddress,21,tmpreg)))
0002ae  2115              MOVS     r1,#0x15
0002b0  4620              MOV      r0,r4
0002b2  f7fffffe          BL       ETH_WritePHYRegister
0002b6  2800              CMP      r0,#0
0002b8  d000              BEQ      |L1.700|
;;;407    	{
;;;408    			return ETH_ERROR;
;;;409    	}
;;;410    	return ETH_SUCCESS;
0002ba  2001              MOVS     r0,#1
                  |L1.700|
;;;411    }
0002bc  bd10              POP      {r4,pc}
;;;412    
                          ENDP

0002be  0000              DCW      0x0000
                  |L1.704|
                          DCD      ||.data||
                  |L1.708|
                          DCD      0x40020000
                  |L1.712|
                          DCD      0x40020800
                  |L1.716|
                          DCD      0x40021800
                  |L1.720|
                          DCD      0x40020400
                  |L1.724|
                          DCD      Tx_Buff
                  |L1.728|
                          DCD      DMATxDscrTab
                  |L1.732|
                          DCD      Rx_Buff
                  |L1.736|
                          DCD      DMARxDscrTab
                  |L1.740|
                          DCD      DMARxDescToGet
                  |L1.744|
                          DCD      DMA_RX_FRAME_infos
                  |L1.748|
                          DCD      DMATxDescToSet
                  |L1.752|
                          DCD      0x40029000
                  |L1.756|
                          DCD      receiveLen
                  |L1.760|
                          DCD      receiveBuffer

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ETH_InitStructure
                          %        188

                          AREA ||.data||, DATA, ALIGN=2

                  EthStatus
                          DCD      0x00000000
                  MyMacAddr
000004  08000600          DCB      0x08,0x00,0x06,0x00
000008  0009              DCB      0x00,0x09

;*** Start embedded assembler ***

#line 1 "..\\HARDWARE\\ETHERNET\\DM9162.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_DM9162_c_2f210e87____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___8_DM9162_c_2f210e87____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_DM9162_c_2f210e87____REVSH|
#line 144
|__asm___8_DM9162_c_2f210e87____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
