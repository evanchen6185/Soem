; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\ethercatdc.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\ethercatdc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\FWLIB\STM32F4xx_StdPeriph_Driver\inc -I..\USER -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\ETHERNET -I..\HARDWARE\TIMER -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\RTC -I..\HARDWARE\ADC -I..\HARDWARE\SRAM -I..\HARDWARE\InterTemperate -I..\FWLIB\STM32F4x7_ETH_Driver\inc -I..\MALLOC -I..\USMART -I..\HARDWARE -I..\ETHERCAT -I.\RTE\_LWIP -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS --omf_browse=..\obj\ethercatdc.crf ..\ETHERCAT\ethercatdc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ecx_dcsync0 PROC
;;;70      */
;;;71     void ecx_dcsync0(ecx_contextt *context, uint16 slave, boolean act, uint32 CyclTime, uint32 CyclShift)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;72     {
000004  4692              MOV      r10,r2
;;;73        uint8 h, RA;
;;;74        uint16 slaveh;
;;;75        int64 t, t1;
;;;76        int32 tc;
;;;77     
;;;78        slaveh = context->slavelist[slave].configadr;
000006  eb0102c1          ADD      r2,r1,r1,LSL #3
00000a  4604              MOV      r4,r0                 ;72
00000c  eb021181          ADD      r1,r2,r1,LSL #6
000010  6840              LDR      r0,[r0,#4]
000012  2204              MOVS     r2,#4
000014  eb020181          ADD      r1,r2,r1,LSL #2
000018  b089              SUB      sp,sp,#0x24           ;72
00001a  f830b001          LDRH     r11,[r0,r1]
;;;79        RA = 0;
00001e  2700              MOVS     r7,#0
000020  f88d7018          STRB     r7,[sp,#0x18]
;;;80     
;;;81        /* stop cyclic operation, ready for next trigger */
;;;82        (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCSYNCACT, sizeof(RA), &RA, EC_TIMEOUTRET);
000024  f44f68fa          MOV      r8,#0x7d0
000028  f10d0918          ADD      r9,sp,#0x18
00002c  e9cd9800          STRD     r9,r8,[sp,#0]
000030  461d              MOV      r5,r3                 ;72
000032  9e12              LDR      r6,[sp,#0x48]         ;78
000034  2301              MOVS     r3,#1
000036  f6401281          MOV      r2,#0x981
00003a  4659              MOV      r1,r11
00003c  6820              LDR      r0,[r4,#0]
00003e  f7fffffe          BL       ecx_FPWR
;;;83        if (act)
000042  f1ba0f00          CMP      r10,#0
000046  d002              BEQ      |L1.78|
;;;84        {
;;;85            RA = 1 + 2;    /* act cyclic operation and sync0, sync1 deactivated */
000048  2003              MOVS     r0,#3
00004a  f88d0018          STRB     r0,[sp,#0x18]
                  |L1.78|
;;;86        }
;;;87        h = 0;
;;;88        (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCCUC, sizeof(h), &h, EC_TIMEOUTRET); /* write access to ethercat */
00004e  a907              ADD      r1,sp,#0x1c
000050  e9cd1800          STRD     r1,r8,[sp,#0]
000054  f88d701c          STRB     r7,[sp,#0x1c]         ;87
000058  2301              MOVS     r3,#1
00005a  f44f6218          MOV      r2,#0x980
00005e  4659              MOV      r1,r11
000060  6820              LDR      r0,[r4,#0]
000062  f7fffffe          BL       ecx_FPWR
;;;89        t1 = 0;
;;;90        (void)ecx_FPRD(context->port, slaveh, ECT_REG_DCSYSTIME, sizeof(t1), &t1, EC_TIMEOUTRET); /* read local time of slave */
000066  a902              ADD      r1,sp,#8
000068  2000              MOVS     r0,#0                 ;88
00006a  e9cd1800          STRD     r1,r8,[sp,#0]
00006e  e9cd0002          STRD     r0,r0,[sp,#8]         ;88
000072  2308              MOVS     r3,#8
000074  f44f6211          MOV      r2,#0x910
000078  4659              MOV      r1,r11
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       ecx_FPRD
000080  e9dd1002          LDRD     r1,r0,[sp,#8]
;;;91        t1 = etohll(t1);
;;;92     
;;;93        /* Calculate first trigger time, always a whole multiple of CyclTime rounded up
;;;94        plus the shifttime (can be negative)
;;;95        This insures best sychronisation between slaves, slaves with the same CyclTime
;;;96        will sync at the same moment (you can use CyclShift to shift the sync) */
;;;97        if (CyclTime > 0)
000084  b1a5              CBZ      r5,|L1.176|
;;;98        {
;;;99            t = ((t1 + SyncDelay) / CyclTime) * CyclTime + CyclTime + CyclShift;
000086  4afb              LDR      r2,|L1.1140|
000088  2300              MOVS     r3,#0
00008a  eb110c02          ADDS     r12,r1,r2
00008e  f1400100          ADC      r1,r0,#0
000092  462a              MOV      r2,r5
000094  4660              MOV      r0,r12
000096  f7fffffe          BL       __aeabi_ldivmod
00009a  fba02305          UMULL    r2,r3,r0,r5
00009e  fb013105          MLA      r1,r1,r5,r3
0000a2  fb001007          MLA      r0,r0,r7,r1
0000a6  19a9              ADDS     r1,r5,r6
0000a8  417f              ADCS     r7,r7,r7
0000aa  1851              ADDS     r1,r2,r1
0000ac  4178              ADCS     r0,r0,r7
0000ae  e005              B        |L1.188|
                  |L1.176|
0000b0  1989              ADDS     r1,r1,r6
;;;100       }
;;;101       else
;;;102       {
;;;103          t = t1 + SyncDelay + CyclShift;
0000b2  4af0              LDR      r2,|L1.1140|
0000b4  4178              ADCS     r0,r0,r7              ;99
0000b6  1889              ADDS     r1,r1,r2
0000b8  f1400000          ADC      r0,r0,#0
                  |L1.188|
0000bc  e9cd1004          STRD     r1,r0,[sp,#0x10]
;;;104          /* first trigger at T1 + CyclTime + SyncDelay + CyclShift in ns */
;;;105       }
;;;106       t = htoell(t);
;;;107       (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCSTART0, sizeof(t), &t, EC_TIMEOUTRET); /* SYNC0 start time */
0000c0  a804              ADD      r0,sp,#0x10
0000c2  e9cd0800          STRD     r0,r8,[sp,#0]
0000c6  4646              MOV      r6,r8
0000c8  2308              MOVS     r3,#8
0000ca  f44f6219          MOV      r2,#0x990
0000ce  4659              MOV      r1,r11
0000d0  6820              LDR      r0,[r4,#0]
0000d2  f7fffffe          BL       ecx_FPWR
;;;108       tc = htoel(CyclTime);
;;;109       (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCCYCLE0, sizeof(tc), &tc, EC_TIMEOUTRET); /* SYNC0 cycle time */
0000d6  a808              ADD      r0,sp,#0x20
0000d8  e9cd0600          STRD     r0,r6,[sp,#0]
0000dc  9508              STR      r5,[sp,#0x20]
0000de  2304              MOVS     r3,#4
0000e0  f44f621a          MOV      r2,#0x9a0
0000e4  4659              MOV      r1,r11
0000e6  6820              LDR      r0,[r4,#0]
0000e8  f7fffffe          BL       ecx_FPWR
0000ec  e9cd9600          STRD     r9,r6,[sp,#0]
;;;110       (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCSYNCACT, sizeof(RA), &RA, EC_TIMEOUTRET); /* activate cyclic operation */
0000f0  2301              MOVS     r3,#1
0000f2  f6401281          MOV      r2,#0x981
0000f6  4659              MOV      r1,r11
0000f8  6820              LDR      r0,[r4,#0]
0000fa  f7fffffe          BL       ecx_FPWR
;;;111    }
0000fe  b009              ADD      sp,sp,#0x24
                  |L1.256|
000100  e8bd8ff0          POP      {r4-r11,pc}
;;;112    
                          ENDP

                  ecx_dcsync01 PROC
;;;124     */
;;;125    void ecx_dcsync01(ecx_contextt *context, uint16 slave, boolean act, uint32 CyclTime0, uint32 CyclTime1, uint32 CyclShift)
000104  e92d4fff          PUSH     {r0-r11,lr}
;;;126    {
000108  b08b              SUB      sp,sp,#0x2c
;;;127       uint8 h, RA;
;;;128       uint16 slaveh;
;;;129       int64 t, t1;
;;;130       int32 tc;
;;;131       uint32 TrueCyclTime;
;;;132      
;;;133       /* Sync1 can be used as a multiple of Sync0, use true cycle time */
;;;134       TrueCyclTime = ((CyclTime1 / CyclTime0) + 1) * CyclTime0;
;;;135    
;;;136       slaveh = context->slavelist[slave].configadr;
00010a  eb0102c1          ADD      r2,r1,r1,LSL #3
00010e  e9dd9818          LDRD     r9,r8,[sp,#0x60]      ;126
000112  4604              MOV      r4,r0                 ;126
000114  eb021181          ADD      r1,r2,r1,LSL #6
000118  6840              LDR      r0,[r0,#4]
00011a  2204              MOVS     r2,#4
00011c  461e              MOV      r6,r3                 ;126
00011e  eb020181          ADD      r1,r2,r1,LSL #2
000122  fbb9f5f6          UDIV     r5,r9,r6              ;134
000126  5a40              LDRH     r0,[r0,r1]
;;;137       RA = 0;
;;;138    
;;;139       /* stop cyclic operation, ready for next trigger */
;;;140       (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCSYNCACT, sizeof(RA), &RA, EC_TIMEOUTRET);
000128  f44f6afa          MOV      r10,#0x7d0
00012c  f10d0b0c          ADD      r11,sp,#0xc
000130  e9cdba00          STRD     r11,r10,[sp,#0]
000134  2700              MOVS     r7,#0                 ;137
000136  9002              STR      r0,[sp,#8]            ;137
000138  1c6d              ADDS     r5,r5,#1              ;134
00013a  f88d700c          STRB     r7,[sp,#0xc]          ;137
00013e  4375              MULS     r5,r6,r5              ;134
000140  2301              MOVS     r3,#1
000142  f6401281          MOV      r2,#0x981
000146  6820              LDR      r0,[r4,#0]
000148  9902              LDR      r1,[sp,#8]
00014a  f7fffffe          BL       ecx_FPWR
;;;141       if (act)
00014e  980d              LDR      r0,[sp,#0x34]
000150  b110              CBZ      r0,|L1.344|
;;;142       {
;;;143          RA = 1 + 2 + 4;    /* act cyclic operation and sync0 + sync1 */
000152  2007              MOVS     r0,#7
000154  f88d000c          STRB     r0,[sp,#0xc]
                  |L1.344|
;;;144       }
;;;145       h = 0;
;;;146       (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCCUC, sizeof(h), &h, EC_TIMEOUTRET); /* write access to ethercat */
000158  a909              ADD      r1,sp,#0x24
00015a  e9cd1a00          STRD     r1,r10,[sp,#0]
00015e  f88d7024          STRB     r7,[sp,#0x24]         ;145
000162  2301              MOVS     r3,#1
000164  f44f6218          MOV      r2,#0x980
000168  6820              LDR      r0,[r4,#0]
00016a  9902              LDR      r1,[sp,#8]
00016c  f7fffffe          BL       ecx_FPWR
000170  2000              MOVS     r0,#0
000172  e9cd0004          STRD     r0,r0,[sp,#0x10]
;;;147       t1 = 0;
;;;148       (void)ecx_FPRD(context->port, slaveh, ECT_REG_DCSYSTIME, sizeof(t1), &t1, EC_TIMEOUTRET); /* read local time of slave */
000176  a904              ADD      r1,sp,#0x10
000178  e9cd1a00          STRD     r1,r10,[sp,#0]
00017c  2308              MOVS     r3,#8
00017e  f44f6211          MOV      r2,#0x910
000182  6820              LDR      r0,[r4,#0]
000184  9902              LDR      r1,[sp,#8]
000186  f7fffffe          BL       ecx_FPRD
00018a  e9dd1004          LDRD     r1,r0,[sp,#0x10]
;;;149       t1 = etohll(t1);
;;;150    
;;;151       /* Calculate first trigger time, always a whole multiple of TrueCyclTime rounded up
;;;152       plus the shifttime (can be negative)
;;;153       This insures best sychronisation between slaves, slaves with the same CyclTime
;;;154       will sync at the same moment (you can use CyclShift to shift the sync) */
;;;155       if (CyclTime0 > 0)
00018e  b1ae              CBZ      r6,|L1.444|
;;;156       {
;;;157          t = ((t1 + SyncDelay) / TrueCyclTime) * TrueCyclTime + TrueCyclTime + CyclShift;
000190  4ab8              LDR      r2,|L1.1140|
000192  2300              MOVS     r3,#0
000194  eb110c02          ADDS     r12,r1,r2
000198  f1400100          ADC      r1,r0,#0
00019c  462a              MOV      r2,r5
00019e  4660              MOV      r0,r12
0001a0  f7fffffe          BL       __aeabi_ldivmod
0001a4  fba02305          UMULL    r2,r3,r0,r5
0001a8  fb013105          MLA      r1,r1,r5,r3
0001ac  fb001007          MLA      r0,r0,r7,r1
0001b0  eb150108          ADDS     r1,r5,r8
0001b4  417f              ADCS     r7,r7,r7
0001b6  1851              ADDS     r1,r2,r1
0001b8  4178              ADCS     r0,r0,r7
0001ba  e006              B        |L1.458|
                  |L1.444|
0001bc  eb110108          ADDS     r1,r1,r8
;;;158       }
;;;159       else
;;;160       {
;;;161          t = t1 + SyncDelay + CyclShift;
0001c0  4aac              LDR      r2,|L1.1140|
0001c2  4178              ADCS     r0,r0,r7              ;157
0001c4  1889              ADDS     r1,r1,r2
0001c6  f1400000          ADC      r0,r0,#0
                  |L1.458|
0001ca  e9cd1006          STRD     r1,r0,[sp,#0x18]
;;;162          /* first trigger at T1 + CyclTime + SyncDelay + CyclShift in ns */
;;;163       }
;;;164       t = htoell(t);
;;;165       (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCSTART0, sizeof(t), &t, EC_TIMEOUTRET); /* SYNC0 start time */
0001ce  a806              ADD      r0,sp,#0x18
0001d0  e9cd0a00          STRD     r0,r10,[sp,#0]
0001d4  4655              MOV      r5,r10
0001d6  2308              MOVS     r3,#8
0001d8  f44f6219          MOV      r2,#0x990
0001dc  6820              LDR      r0,[r4,#0]
0001de  9902              LDR      r1,[sp,#8]
0001e0  f7fffffe          BL       ecx_FPWR
;;;166       tc = htoel(CyclTime0);
;;;167       (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCCYCLE0, sizeof(tc), &tc, EC_TIMEOUTRET); /* SYNC0 cycle time */
0001e4  9608              STR      r6,[sp,#0x20]
0001e6  ae08              ADD      r6,sp,#0x20
0001e8  e9cd6500          STRD     r6,r5,[sp,#0]
0001ec  2304              MOVS     r3,#4
0001ee  f44f621a          MOV      r2,#0x9a0
0001f2  6820              LDR      r0,[r4,#0]
0001f4  9902              LDR      r1,[sp,#8]
0001f6  f7fffffe          BL       ecx_FPWR
;;;168       tc = htoel(CyclTime1);
0001fa  e9cd6500          STRD     r6,r5,[sp,#0]
0001fe  f8cd9020          STR      r9,[sp,#0x20]
;;;169       (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCCYCLE1, sizeof(tc), &tc, EC_TIMEOUTRET); /* SYNC1 cycle time */
000202  2304              MOVS     r3,#4
000204  f64012a4          MOV      r2,#0x9a4
000208  6820              LDR      r0,[r4,#0]
00020a  9902              LDR      r1,[sp,#8]
00020c  f7fffffe          BL       ecx_FPWR
000210  e9cdb500          STRD     r11,r5,[sp,#0]
;;;170       (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCSYNCACT, sizeof(RA), &RA, EC_TIMEOUTRET); /* activate cyclic operation */
000214  2301              MOVS     r3,#1
000216  f6401281          MOV      r2,#0x981
00021a  6820              LDR      r0,[r4,#0]
00021c  9902              LDR      r1,[sp,#8]
00021e  f7fffffe          BL       ecx_FPWR
                  |L1.546|
;;;171    }
000222  b00f              ADD      sp,sp,#0x3c
000224  e76c              B        |L1.256|
;;;172    
                          ENDP

                  ecx_porttime PROC
;;;173    /* latched port time of slave */
;;;174    static int32 ecx_porttime(ecx_contextt *context, uint16 slave, uint8 port)
000226  eb0103c1          ADD      r3,r1,r1,LSL #3
;;;175    {
;;;176       int32 ts;
;;;177       switch (port)
;;;178       {
;;;179          case 0:
;;;180             ts = context->slavelist[slave].DCrtA;
00022a  eb031181          ADD      r1,r3,r1,LSL #6
00022e  b13a              CBZ      r2,|L1.576|
000230  2a01              CMP      r2,#1                 ;177
000232  d008              BEQ      |L1.582|
000234  2a02              CMP      r2,#2                 ;177
000236  d009              BEQ      |L1.588|
000238  2a03              CMP      r2,#3                 ;177
00023a  d00a              BEQ      |L1.594|
;;;181             break;
;;;182          case 1:
;;;183             ts = context->slavelist[slave].DCrtB;
;;;184             break;
;;;185          case 2:
;;;186             ts = context->slavelist[slave].DCrtC;
;;;187             break;
;;;188          case 3:
;;;189             ts = context->slavelist[slave].DCrtD;
;;;190             break;
;;;191          default:
;;;192             ts = 0;
00023c  2000              MOVS     r0,#0
;;;193             break;
;;;194       }
;;;195       return ts;
;;;196    }
00023e  4770              BX       lr
                  |L1.576|
000240  6840              LDR      r0,[r0,#4]            ;180
000242  22d4              MOVS     r2,#0xd4              ;180
000244  e007              B        |L1.598|
                  |L1.582|
000246  6840              LDR      r0,[r0,#4]            ;183
000248  22d8              MOVS     r2,#0xd8              ;183
00024a  e004              B        |L1.598|
                  |L1.588|
00024c  6840              LDR      r0,[r0,#4]            ;186
00024e  22dc              MOVS     r2,#0xdc              ;186
000250  e001              B        |L1.598|
                  |L1.594|
000252  6840              LDR      r0,[r0,#4]            ;189
000254  22e0              MOVS     r2,#0xe0              ;189
                  |L1.598|
000256  eb020181          ADD      r1,r2,r1,LSL #2       ;189
00025a  5840              LDR      r0,[r0,r1]            ;189
00025c  4770              BX       lr
;;;197    
                          ENDP

                  ecx_prevport PROC
;;;198    /* calculate previous active port of a slave */
;;;199    static uint8 ecx_prevport(ecx_contextt *context, uint16 slave, uint8 port)
00025e  b510              PUSH     {r4,lr}
;;;200    {
000260  4603              MOV      r3,r0
;;;201       uint8 pport = port;
;;;202       uint8 aport = context->slavelist[slave].activeports;
000262  eb0104c1          ADD      r4,r1,r1,LSL #3
000266  eb041181          ADD      r1,r4,r1,LSL #6
00026a  685b              LDR      r3,[r3,#4]
00026c  f04f04ce          MOV      r4,#0xce
000270  eb040181          ADD      r1,r4,r1,LSL #2
000274  1e10              SUBS     r0,r2,#0              ;201
000276  5c59              LDRB     r1,[r3,r1]
000278  d008              BEQ      |L1.652|
;;;203       switch(port)
00027a  2a01              CMP      r2,#1
00027c  d012              BEQ      |L1.676|
00027e  2a02              CMP      r2,#2
000280  d019              BEQ      |L1.694|
000282  2803              CMP      r0,#3
000284  d105              BNE      |L1.658|
;;;204       {
;;;205          case 0:
;;;206             if(aport & PORTM2)
;;;207                pport = 2;
;;;208             else if (aport & PORTM1)
;;;209                pport = 1;
;;;210             else if (aport & PORTM3)
;;;211                pport = 3;
;;;212             break;
;;;213          case 1:
;;;214             if(aport & PORTM3)
;;;215                pport = 3;
;;;216             else if (aport & PORTM0)
;;;217                pport = 0;
;;;218             else if (aport & PORTM2)
;;;219                pport = 2;
;;;220             break;
;;;221          case 2:
;;;222             if(aport & PORTM1)
;;;223                pport = 1;
;;;224             else if (aport & PORTM3)
;;;225                pport = 3;
;;;226             else if (aport & PORTM0)
;;;227                pport = 0;
;;;228             break;
;;;229          case 3:
;;;230             if(aport & PORTM0)
000286  07ca              LSLS     r2,r1,#31
000288  d110              BNE      |L1.684|
00028a  e01b              B        |L1.708|
                  |L1.652|
00028c  074a              LSLS     r2,r1,#29             ;206
00028e  d501              BPL      |L1.660|
                  |L1.656|
000290  2002              MOVS     r0,#2                 ;207
                  |L1.658|
;;;231                pport = 0;
;;;232             else if (aport & PORTM2)
;;;233                pport = 2;
;;;234             else if (aport & PORTM1)
;;;235                pport = 1;
;;;236             break;
;;;237       }      
;;;238       return pport;
;;;239    }
000292  bd10              POP      {r4,pc}
                  |L1.660|
000294  078a              LSLS     r2,r1,#30             ;208
000296  d501              BPL      |L1.668|
                  |L1.664|
000298  2001              MOVS     r0,#1                 ;209
                  |L1.666|
00029a  bd10              POP      {r4,pc}
                  |L1.668|
00029c  0709              LSLS     r1,r1,#28             ;210
00029e  d5fc              BPL      |L1.666|
                  |L1.672|
0002a0  2003              MOVS     r0,#3                 ;211
0002a2  bd10              POP      {r4,pc}
                  |L1.676|
0002a4  070a              LSLS     r2,r1,#28             ;214
0002a6  d4fb              BMI      |L1.672|
0002a8  07ca              LSLS     r2,r1,#31             ;216
0002aa  d001              BEQ      |L1.688|
                  |L1.684|
0002ac  2000              MOVS     r0,#0                 ;217
0002ae  bd10              POP      {r4,pc}
                  |L1.688|
0002b0  0749              LSLS     r1,r1,#29             ;218
0002b2  d4ed              BMI      |L1.656|
0002b4  bd10              POP      {r4,pc}
                  |L1.694|
0002b6  078a              LSLS     r2,r1,#30             ;222
0002b8  d4ee              BMI      |L1.664|
0002ba  070a              LSLS     r2,r1,#28             ;224
0002bc  d4f0              BMI      |L1.672|
0002be  07c9              LSLS     r1,r1,#31             ;226
0002c0  d1f4              BNE      |L1.684|
0002c2  bd10              POP      {r4,pc}
                  |L1.708|
0002c4  074a              LSLS     r2,r1,#29             ;232
0002c6  d4e3              BMI      |L1.656|
0002c8  0789              LSLS     r1,r1,#30             ;234
0002ca  d4e5              BMI      |L1.664|
0002cc  bd10              POP      {r4,pc}
;;;240    
                          ENDP

                  ecx_parentport PROC
;;;241    /* search unconsumed ports in parent, consume and return first open port */
;;;242    static uint8 ecx_parentport(ecx_contextt *context, uint16 parent)
0002ce  b510              PUSH     {r4,lr}
;;;243    {
0002d0  4602              MOV      r2,r0
;;;244       uint8 parentport = 0;
0002d2  2000              MOVS     r0,#0
;;;245       uint8 b;
;;;246       /* search order is important, here 3 - 1 - 2 - 0 */
;;;247       b = context->slavelist[parent].consumedports;
0002d4  6853              LDR      r3,[r2,#4]
0002d6  eb0102c1          ADD      r2,r1,r1,LSL #3
0002da  eb021281          ADD      r2,r2,r1,LSL #6
0002de  21cf              MOVS     r1,#0xcf
0002e0  eb010282          ADD      r2,r1,r2,LSL #2
0002e4  5c99              LDRB     r1,[r3,r2]
;;;248       if (b & PORTM3)
0002e6  070c              LSLS     r4,r1,#28
0002e8  d503              BPL      |L1.754|
;;;249       {
;;;250          parentport = 3;
0002ea  2003              MOVS     r0,#3
;;;251          b &= (uint8)~PORTM3;
0002ec  f00101f7          AND      r1,r1,#0xf7
0002f0  e00f              B        |L1.786|
                  |L1.754|
;;;252       }
;;;253       else if (b & PORTM1)
0002f2  078c              LSLS     r4,r1,#30
0002f4  d503              BPL      |L1.766|
;;;254       {
;;;255          parentport = 1;
0002f6  2001              MOVS     r0,#1
;;;256          b &= (uint8)~PORTM1;
0002f8  f00101fd          AND      r1,r1,#0xfd
0002fc  e009              B        |L1.786|
                  |L1.766|
;;;257       }
;;;258       else if (b & PORTM2)
0002fe  074c              LSLS     r4,r1,#29
000300  d503              BPL      |L1.778|
;;;259       {
;;;260          parentport = 2;
000302  2002              MOVS     r0,#2
;;;261          b &= (uint8)~PORTM2;
000304  f00101fb          AND      r1,r1,#0xfb
000308  e003              B        |L1.786|
                  |L1.778|
;;;262       }
;;;263       else if (b & PORTM0)
00030a  07cc              LSLS     r4,r1,#31
00030c  d001              BEQ      |L1.786|
;;;264       {
;;;265          parentport = 0;
;;;266          b &= (uint8)~PORTM0;
00030e  f00101fe          AND      r1,r1,#0xfe
                  |L1.786|
;;;267       }
;;;268       context->slavelist[parent].consumedports = b;
000312  5499              STRB     r1,[r3,r2]
;;;269       return parentport;
;;;270    }
000314  bd10              POP      {r4,pc}
;;;271    
                          ENDP

                  ecx_configdc PROC
;;;277     */
;;;278    boolean ecx_configdc(ecx_contextt *context)
000316  e92d4ff0          PUSH     {r4-r11,lr}
;;;279    {
00031a  b08f              SUB      sp,sp,#0x3c
00031c  4604              MOV      r4,r0
;;;280       uint16 i, slaveh, parent, child;
;;;281       uint16 parenthold = 0;
00031e  2000              MOVS     r0,#0
;;;282       uint16 prevDCslave = 0;
000320  9008              STR      r0,[sp,#0x20]
;;;283       int32 ht, dt1, dt2, dt3;
;;;284       int64 hrt;
;;;285       uint8 entryport;
;;;286       int8 nlist;
;;;287       int8 plist[4];
;;;288       int32 tlist[4];
;;;289    
;;;290       context->slavelist[0].hasdc = FALSE;
000322  900c              STR      r0,[sp,#0x30]
000324  6861              LDR      r1,[r4,#4]
;;;291       context->grouplist[0].hasdc = FALSE;
;;;292       ht = 0;
;;;293    //   mastertime = osal_current_time();
;;;294       ecx_BWR(context->port, 0, ECT_REG_DCTIME0, sizeof(ht), &ht, EC_TIMEOUTRET);  /* latch DCrecvTimeA of all slaves */
000326  2304              MOVS     r3,#4
000328  f44f6210          MOV      r2,#0x900
00032c  f88100cb          STRB     r0,[r1,#0xcb]         ;290
000330  6921              LDR      r1,[r4,#0x10]         ;291
000332  7508              STRB     r0,[r1,#0x14]         ;291
000334  9006              STR      r0,[sp,#0x18]
000336  f44f61fa          MOV      r1,#0x7d0
00033a  a806              ADD      r0,sp,#0x18
00033c  e9cd0100          STRD     r0,r1,[sp,#0]
000340  2100              MOVS     r1,#0
000342  6820              LDR      r0,[r4,#0]
000344  f7fffffe          BL       ecx_BWR
;;;295       for (i = 1; i <= *(context->slavecount); i++)
000348  2001              MOVS     r0,#1
00034a  e1e4              B        |L1.1814|
                  |L1.844|
;;;296       {
;;;297          context->slavelist[i].consumedports = context->slavelist[i].activeports;
00034c  eb0002c0          ADD      r2,r0,r0,LSL #3
000350  eb021588          ADD      r5,r2,r8,LSL #6
000354  20ce              MOVS     r0,#0xce
000356  6861              LDR      r1,[r4,#4]
000358  eb000085          ADD      r0,r0,r5,LSL #2
00035c  900d              STR      r0,[sp,#0x34]
00035e  5c0a              LDRB     r2,[r1,r0]
000360  20cf              MOVS     r0,#0xcf
000362  eb000985          ADD      r9,r0,r5,LSL #2
000366  f8012009          STRB     r2,[r1,r9]
;;;298          if (context->slavelist[i].hasdc)
00036a  21cb              MOVS     r1,#0xcb
00036c  6860              LDR      r0,[r4,#4]
00036e  eb010185          ADD      r1,r1,r5,LSL #2
000372  5c41              LDRB     r1,[r0,r1]
000374  2900              CMP      r1,#0
000376  d07f              BEQ      |L1.1144|
;;;299          {
;;;300             if (!context->slavelist[0].hasdc)
000378  f89010cb          LDRB     r1,[r0,#0xcb]
00037c  2900              CMP      r1,#0
00037e  d07c              BEQ      |L1.1146|
;;;301             {
;;;302                context->slavelist[0].hasdc = TRUE;
;;;303                context->slavelist[0].DCnext = i;
;;;304                context->slavelist[i].DCprevious = 0;
;;;305                context->grouplist[0].hasdc = TRUE;
;;;306                context->grouplist[0].DCnext = i;
;;;307             }
;;;308             else
;;;309             {
;;;310                context->slavelist[prevDCslave].DCnext = i;
000380  990c              LDR      r1,[sp,#0x30]
000382  eb0103c1          ADD      r3,r1,r1,LSL #3
000386  eb031381          ADD      r3,r3,r1,LSL #6
00038a  21e8              MOVS     r1,#0xe8
00038c  eb010183          ADD      r1,r1,r3,LSL #2
000390  f8208001          STRH     r8,[r0,r1]
;;;311                context->slavelist[i].DCprevious = prevDCslave;
000394  6862              LDR      r2,[r4,#4]
000396  21ea              MOVS     r1,#0xea
000398  980c              LDR      r0,[sp,#0x30]
00039a  eb010185          ADD      r1,r1,r5,LSL #2
00039e  5250              STRH     r0,[r2,r1]
                  |L1.928|
;;;312             }
;;;313             /* this branch has DC slave so remove parenthold */
;;;314             parenthold = 0;
0003a0  2000              MOVS     r0,#0
;;;315             prevDCslave = i;
;;;316             slaveh = context->slavelist[i].configadr;
0003a2  f8cd8030          STR      r8,[sp,#0x30]
0003a6  9008              STR      r0,[sp,#0x20]
0003a8  6860              LDR      r0,[r4,#4]
0003aa  2104              MOVS     r1,#4
0003ac  eb010185          ADD      r1,r1,r5,LSL #2
0003b0  5a40              LDRH     r0,[r0,r1]
;;;317             (void)ecx_FPRD(context->port, slaveh, ECT_REG_DCTIME0, sizeof(ht), &ht, EC_TIMEOUTRET);
0003b2  f44f67fa          MOV      r7,#0x7d0
0003b6  f10d0a18          ADD      r10,sp,#0x18
0003ba  e9cda700          STRD     r10,r7,[sp,#0]
0003be  9007              STR      r0,[sp,#0x1c]
0003c0  2304              MOVS     r3,#4
0003c2  f44f6210          MOV      r2,#0x900
0003c6  6820              LDR      r0,[r4,#0]
0003c8  9907              LDR      r1,[sp,#0x1c]
0003ca  f7fffffe          BL       ecx_FPRD
;;;318             context->slavelist[i].DCrtA = etohl(ht);
0003ce  20d4              MOVS     r0,#0xd4
0003d0  6862              LDR      r2,[r4,#4]
0003d2  eb000685          ADD      r6,r0,r5,LSL #2
0003d6  9906              LDR      r1,[sp,#0x18]
0003d8  5191              STR      r1,[r2,r6]
;;;319             /* 64bit latched DCrecvTimeA of each specific slave */
;;;320             (void)ecx_FPRD(context->port, slaveh, ECT_REG_DCSOF, sizeof(hrt), &hrt, EC_TIMEOUTRET);
0003da  f10d0b28          ADD      r11,sp,#0x28
0003de  e9cdb700          STRD     r11,r7,[sp,#0]
0003e2  2308              MOVS     r3,#8
0003e4  f6401218          MOV      r2,#0x918
0003e8  6820              LDR      r0,[r4,#0]
0003ea  9907              LDR      r1,[sp,#0x1c]
0003ec  f7fffffe          BL       ecx_FPRD
;;;321             /* use it as offset in order to set local time around 0 + mastertime */
;;;322             hrt = htoell(-etohll(hrt));
0003f0  e9dd210a          LDRD     r2,r1,[sp,#0x28]
0003f4  2000              MOVS     r0,#0
0003f6  4252              RSBS     r2,r2,#0
0003f8  eb600001          SBC      r0,r0,r1
0003fc  e9cd200a          STRD     r2,r0,[sp,#0x28]
000400  e9cdb700          STRD     r11,r7,[sp,#0]
;;;323             /* save it in the offset register */
;;;324             (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCSYSOFFSET, sizeof(hrt), &hrt, EC_TIMEOUTRET);
000404  2308              MOVS     r3,#8
000406  f44f6212          MOV      r2,#0x920
00040a  6820              LDR      r0,[r4,#0]
00040c  9907              LDR      r1,[sp,#0x1c]
00040e  f7fffffe          BL       ecx_FPWR
000412  e9cda700          STRD     r10,r7,[sp,#0]
;;;325             (void)ecx_FPRD(context->port, slaveh, ECT_REG_DCTIME1, sizeof(ht), &ht, EC_TIMEOUTRET);
000416  2304              MOVS     r3,#4
000418  f6401204          MOV      r2,#0x904
00041c  6820              LDR      r0,[r4,#0]
00041e  9907              LDR      r1,[sp,#0x1c]
000420  f7fffffe          BL       ecx_FPRD
;;;326             context->slavelist[i].DCrtB = etohl(ht);
000424  20d8              MOVS     r0,#0xd8
000426  6862              LDR      r2,[r4,#4]
000428  eb000b85          ADD      r11,r0,r5,LSL #2
00042c  9906              LDR      r1,[sp,#0x18]
00042e  f842100b          STR      r1,[r2,r11]
000432  e9cda700          STRD     r10,r7,[sp,#0]
;;;327             (void)ecx_FPRD(context->port, slaveh, ECT_REG_DCTIME2, sizeof(ht), &ht, EC_TIMEOUTRET);
000436  2304              MOVS     r3,#4
000438  f6401208          MOV      r2,#0x908
00043c  6820              LDR      r0,[r4,#0]
00043e  9907              LDR      r1,[sp,#0x1c]
000440  f7fffffe          BL       ecx_FPRD
;;;328             context->slavelist[i].DCrtC = etohl(ht);
000444  20dc              MOVS     r0,#0xdc
000446  6862              LDR      r2,[r4,#4]
000448  eb000085          ADD      r0,r0,r5,LSL #2
00044c  9906              LDR      r1,[sp,#0x18]
00044e  900e              STR      r0,[sp,#0x38]
000450  5011              STR      r1,[r2,r0]
000452  e9cda700          STRD     r10,r7,[sp,#0]
;;;329             (void)ecx_FPRD(context->port, slaveh, ECT_REG_DCTIME3, sizeof(ht), &ht, EC_TIMEOUTRET);
000456  2304              MOVS     r3,#4
000458  f640120c          MOV      r2,#0x90c
00045c  6820              LDR      r0,[r4,#0]
00045e  9907              LDR      r1,[sp,#0x1c]
000460  f7fffffe          BL       ecx_FPRD
;;;330             context->slavelist[i].DCrtD = etohl(ht);
000464  20e0              MOVS     r0,#0xe0
000466  6861              LDR      r1,[r4,#4]
000468  eb000085          ADD      r0,r0,r5,LSL #2
00046c  9b06              LDR      r3,[sp,#0x18]
00046e  500b              STR      r3,[r1,r0]
;;;331    
;;;332             /* make list of active ports and their time stamps */
;;;333             nlist = 0;
000470  2000              MOVS     r0,#0
;;;334             if (context->slavelist[i].activeports & PORTM0) 
000472  e003              B        |L1.1148|
                  |L1.1140|
                          DCD      0x05f5e100
                  |L1.1144|
000478  e116              B        |L1.1704|
                  |L1.1146|
00047a  e080              B        |L1.1406|
                  |L1.1148|
00047c  6862              LDR      r2,[r4,#4]
00047e  990d              LDR      r1,[sp,#0x34]
000480  5c51              LDRB     r1,[r2,r1]
000482  07cf              LSLS     r7,r1,#31
000484  d004              BEQ      |L1.1168|
;;;335             {
;;;336                plist[nlist] = 0;
000486  f88d0024          STRB     r0,[sp,#0x24]
;;;337                tlist[nlist] = context->slavelist[i].DCrtA;
00048a  5990              LDR      r0,[r2,r6]
;;;338                nlist++;
00048c  9002              STR      r0,[sp,#8]
00048e  2001              MOVS     r0,#1
                  |L1.1168|
;;;339             }
;;;340             if (context->slavelist[i].activeports & PORTM3) 
000490  070e              LSLS     r6,r1,#28
000492  d506              BPL      |L1.1186|
;;;341             {
;;;342                plist[nlist] = 3;
000494  ae09              ADD      r6,sp,#0x24
000496  2703              MOVS     r7,#3
000498  5437              STRB     r7,[r6,r0]
;;;343                tlist[nlist] = context->slavelist[i].DCrtD;
00049a  ae02              ADD      r6,sp,#8
00049c  f8463020          STR      r3,[r6,r0,LSL #2]
0004a0  1c40              ADDS     r0,r0,#1
                  |L1.1186|
;;;344                nlist++;
;;;345             }
;;;346             if (context->slavelist[i].activeports & PORTM1) 
0004a2  078b              LSLS     r3,r1,#30
0004a4  d508              BPL      |L1.1208|
;;;347             {
;;;348                plist[nlist] = 1;
0004a6  ae09              ADD      r6,sp,#0x24
0004a8  2301              MOVS     r3,#1
0004aa  5433              STRB     r3,[r6,r0]
;;;349                tlist[nlist] = context->slavelist[i].DCrtB;
0004ac  ab02              ADD      r3,sp,#8
0004ae  f852600b          LDR      r6,[r2,r11]
0004b2  f8436020          STR      r6,[r3,r0,LSL #2]
0004b6  1c40              ADDS     r0,r0,#1
                  |L1.1208|
;;;350                nlist++;
;;;351             }
;;;352             if (context->slavelist[i].activeports & PORTM2) 
0004b8  0749              LSLS     r1,r1,#29
0004ba  d508              BPL      |L1.1230|
;;;353             {
;;;354                plist[nlist] = 2;
0004bc  a909              ADD      r1,sp,#0x24
0004be  2302              MOVS     r3,#2
0004c0  540b              STRB     r3,[r1,r0]
;;;355                tlist[nlist] = context->slavelist[i].DCrtC;
0004c2  990e              LDR      r1,[sp,#0x38]
0004c4  5853              LDR      r3,[r2,r1]
0004c6  a902              ADD      r1,sp,#8
0004c8  f8413020          STR      r3,[r1,r0,LSL #2]
0004cc  1c40              ADDS     r0,r0,#1
                  |L1.1230|
;;;356                nlist++;
;;;357             }
;;;358             /* entryport is port with the lowest timestamp */
;;;359             entryport = 0;
0004ce  2100              MOVS     r1,#0
;;;360             if((nlist > 1) && (tlist[1] < tlist[entryport]))
0004d0  2801              CMP      r0,#1
0004d2  dd04              BLE      |L1.1246|
0004d4  e9dd3602          LDRD     r3,r6,[sp,#8]
0004d8  429e              CMP      r6,r3
0004da  da00              BGE      |L1.1246|
;;;361             {
;;;362                entryport = 1;
0004dc  2101              MOVS     r1,#1
                  |L1.1246|
;;;363             }         
;;;364             if((nlist > 2) && (tlist[2] < tlist[entryport]))
0004de  2802              CMP      r0,#2
0004e0  dd06              BLE      |L1.1264|
0004e2  ab02              ADD      r3,sp,#8
0004e4  9e04              LDR      r6,[sp,#0x10]
0004e6  f8533021          LDR      r3,[r3,r1,LSL #2]
0004ea  429e              CMP      r6,r3
0004ec  da00              BGE      |L1.1264|
;;;365             {
;;;366                entryport = 2;
0004ee  2102              MOVS     r1,#2
                  |L1.1264|
;;;367             }
;;;368             if((nlist > 3) && (tlist[3] < tlist[entryport]))
0004f0  2803              CMP      r0,#3
0004f2  dd06              BLE      |L1.1282|
0004f4  a802              ADD      r0,sp,#8
0004f6  9b05              LDR      r3,[sp,#0x14]
0004f8  f8500021          LDR      r0,[r0,r1,LSL #2]
0004fc  4283              CMP      r3,r0
0004fe  da00              BGE      |L1.1282|
;;;369             {
;;;370                entryport = 3;
000500  2103              MOVS     r1,#3
                  |L1.1282|
;;;371             }
;;;372             entryport = plist[entryport];
000502  a809              ADD      r0,sp,#0x24
;;;373             context->slavelist[i].entryport = entryport;
;;;374             /* consume entryport from activeports */
;;;375             context->slavelist[i].consumedports &= (uint8)~(1 << entryport);
;;;376    
;;;377             /* finding DC parent of current */
;;;378             parent = i;
000504  4646              MOV      r6,r8
000506  5c40              LDRB     r0,[r0,r1]            ;372
000508  21d3              MOVS     r1,#0xd3              ;373
00050a  eb010185          ADD      r1,r1,r5,LSL #2       ;373
00050e  9101              STR      r1,[sp,#4]            ;373
000510  5450              STRB     r0,[r2,r1]            ;373
000512  6861              LDR      r1,[r4,#4]            ;375
000514  2201              MOVS     r2,#1                 ;375
000516  4082              LSLS     r2,r2,r0              ;375
000518  f8113009          LDRB     r3,[r1,r9]            ;375
00051c  4393              BICS     r3,r3,r2              ;375
00051e  f8013009          STRB     r3,[r1,r9]            ;375
000522  21cb              MOVS     r1,#0xcb              ;298
000524  6860              LDR      r0,[r4,#4]            ;290
;;;379             do
;;;380             {
;;;381                child = parent;
;;;382                parent = context->slavelist[parent].parent;
000526  22d0              MOVS     r2,#0xd0
                  |L1.1320|
000528  eb0603c6          ADD      r3,r6,r6,LSL #3
00052c  eb031386          ADD      r3,r3,r6,LSL #6
000530  eb020383          ADD      r3,r2,r3,LSL #2
000534  960e              STR      r6,[sp,#0x38]
000536  5ac6              LDRH     r6,[r0,r3]
;;;383             }
;;;384             while (!((parent == 0) || (context->slavelist[parent].hasdc)));
000538  2e00              CMP      r6,#0
00053a  d07d              BEQ      |L1.1592|
00053c  eb0603c6          ADD      r3,r6,r6,LSL #3
000540  eb031386          ADD      r3,r3,r6,LSL #6
000544  eb010383          ADD      r3,r1,r3,LSL #2
000548  5cc3              LDRB     r3,[r0,r3]
00054a  2b00              CMP      r3,#0
00054c  d0ec              BEQ      |L1.1320|
;;;385             /* only calculate propagation delay if slave is not the first */
;;;386             if (parent > 0)
;;;387             {
;;;388                /* find port on parent this slave is connected to */
;;;389                context->slavelist[i].parentport = ecx_parentport(context, parent);
00054e  4631              MOV      r1,r6
000550  4620              MOV      r0,r4
000552  f7fffffe          BL       ecx_parentport
000556  4601              MOV      r1,r0
000558  20d2              MOVS     r0,#0xd2
00055a  6862              LDR      r2,[r4,#4]
00055c  eb000b85          ADD      r11,r0,r5,LSL #2
000560  f802100b          STRB     r1,[r2,r11]
;;;390                if (context->slavelist[parent].topology == 1)
000564  eb0601c6          ADD      r1,r6,r6,LSL #3
000568  eb011186          ADD      r1,r1,r6,LSL #6
00056c  6860              LDR      r0,[r4,#4]
00056e  22cd              MOVS     r2,#0xcd
000570  9100              STR      r1,[sp,#0]
000572  eb020181          ADD      r1,r2,r1,LSL #2
000576  5c41              LDRB     r1,[r0,r1]
000578  2901              CMP      r1,#1
00057a  d012              BEQ      |L1.1442|
00057c  e018              B        |L1.1456|
                  |L1.1406|
00057e  2101              MOVS     r1,#1                 ;302
000580  f88010cb          STRB     r1,[r0,#0xcb]         ;302
000584  6862              LDR      r2,[r4,#4]            ;303
000586  f8a280e8          STRH     r8,[r2,#0xe8]         ;303
00058a  2200              MOVS     r2,#0                 ;304
00058c  6863              LDR      r3,[r4,#4]            ;304
00058e  20ea              MOVS     r0,#0xea              ;304
000590  eb000085          ADD      r0,r0,r5,LSL #2       ;304
000594  521a              STRH     r2,[r3,r0]            ;304
000596  6920              LDR      r0,[r4,#0x10]         ;305
000598  7501              STRB     r1,[r0,#0x14]         ;305
00059a  6921              LDR      r1,[r4,#0x10]         ;306
00059c  f8a18016          STRH     r8,[r1,#0x16]         ;306
0005a0  e6fe              B        |L1.928|
                  |L1.1442|
;;;391                {
;;;392                   context->slavelist[i].parentport = context->slavelist[parent].entryport;
0005a2  9900              LDR      r1,[sp,#0]
0005a4  22d3              MOVS     r2,#0xd3
0005a6  eb020181          ADD      r1,r2,r1,LSL #2
0005aa  5c42              LDRB     r2,[r0,r1]
0005ac  f800200b          STRB     r2,[r0,r11]
                  |L1.1456|
;;;393                }
;;;394    
;;;395                dt1 = 0;
;;;396                dt2 = 0;
;;;397                /* delta time of (parentport - 1) - parentport */
;;;398                /* note: order of ports is 0 - 3 - 1 -2 */
;;;399                /* non active ports are skipped */
;;;400                dt3 = ecx_porttime(context, parent, context->slavelist[i].parentport) -
0005b0  6861              LDR      r1,[r4,#4]
0005b2  f04f0a00          MOV      r10,#0                ;395
0005b6  46d1              MOV      r9,r10                ;396
0005b8  f811200b          LDRB     r2,[r1,r11]
0005bc  4631              MOV      r1,r6
0005be  4620              MOV      r0,r4
0005c0  f7fffffe          BL       ecx_porttime
0005c4  6861              LDR      r1,[r4,#4]
0005c6  4607              MOV      r7,r0
0005c8  4620              MOV      r0,r4
0005ca  f811200b          LDRB     r2,[r1,r11]
0005ce  4631              MOV      r1,r6
0005d0  f7fffffe          BL       ecx_prevport
0005d4  4602              MOV      r2,r0
0005d6  4631              MOV      r1,r6
0005d8  4620              MOV      r0,r4
0005da  f7fffffe          BL       ecx_porttime
0005de  1a38              SUBS     r0,r7,r0
;;;401                      ecx_porttime(context, parent, 
;;;402                        ecx_prevport(context, parent, context->slavelist[i].parentport));
;;;403                /* current slave has children */
;;;404                /* those childrens delays need to be substacted */
;;;405                if (context->slavelist[i].topology > 1)
0005e0  900d              STR      r0,[sp,#0x34]
0005e2  21cd              MOVS     r1,#0xcd
0005e4  6860              LDR      r0,[r4,#4]
0005e6  eb010185          ADD      r1,r1,r5,LSL #2
0005ea  5c41              LDRB     r1,[r0,r1]
0005ec  2901              CMP      r1,#1
0005ee  d914              BLS      |L1.1562|
;;;406                {
;;;407                   dt1 = ecx_porttime(context, i, 
0005f0  9901              LDR      r1,[sp,#4]
0005f2  5c42              LDRB     r2,[r0,r1]
0005f4  4641              MOV      r1,r8
0005f6  4620              MOV      r0,r4
0005f8  f7fffffe          BL       ecx_prevport
0005fc  4602              MOV      r2,r0
0005fe  4641              MOV      r1,r8
000600  4620              MOV      r0,r4
000602  f7fffffe          BL       ecx_porttime
000606  4607              MOV      r7,r0
000608  6861              LDR      r1,[r4,#4]
00060a  9801              LDR      r0,[sp,#4]
00060c  5c0a              LDRB     r2,[r1,r0]
00060e  4641              MOV      r1,r8
000610  4620              MOV      r0,r4
000612  f7fffffe          BL       ecx_porttime
000616  eba70a00          SUB      r10,r7,r0
                  |L1.1562|
;;;408                            ecx_prevport(context, i, context->slavelist[i].entryport)) -
;;;409                         ecx_porttime(context, i, context->slavelist[i].entryport);
;;;410                }
;;;411                /* we are only interrested in positive diference */
;;;412                if (dt1 > dt3) dt1 = -dt1;
00061a  990d              LDR      r1,[sp,#0x34]
00061c  458a              CMP      r10,r1
00061e  dd01              BLE      |L1.1572|
000620  f1ca0a00          RSB      r10,r10,#0
                  |L1.1572|
;;;413                /* current slave is not the first child of parent */
;;;414                /* previous childs delays need to be added */
;;;415                if ((child - parent) > 1)
000624  980e              LDR      r0,[sp,#0x38]
000626  1b80              SUBS     r0,r0,r6
000628  2801              CMP      r0,#1
00062a  dd1e              BLE      |L1.1642|
;;;416                {
;;;417                   dt2 = ecx_porttime(context, parent, 
00062c  6861              LDR      r1,[r4,#4]
00062e  4620              MOV      r0,r4
000630  f811200b          LDRB     r2,[r1,r11]
000634  4631              MOV      r1,r6
000636  e000              B        |L1.1594|
                  |L1.1592|
000638  e06a              B        |L1.1808|
                  |L1.1594|
00063a  f7fffffe          BL       ecx_prevport
00063e  4602              MOV      r2,r0
000640  4631              MOV      r1,r6
000642  4620              MOV      r0,r4
000644  f7fffffe          BL       ecx_porttime
000648  4607              MOV      r7,r0
00064a  9800              LDR      r0,[sp,#0]
00064c  6862              LDR      r2,[r4,#4]
00064e  21d3              MOVS     r1,#0xd3
000650  eb010080          ADD      r0,r1,r0,LSL #2
000654  4631              MOV      r1,r6
000656  5c12              LDRB     r2,[r2,r0]
000658  4620              MOV      r0,r4
00065a  f7fffffe          BL       ecx_porttime
00065e  1a38              SUBS     r0,r7,r0
000660  ea5f0900          MOVS     r9,r0
000664  d501              BPL      |L1.1642|
;;;418                            ecx_prevport(context, parent, context->slavelist[i].parentport)) -
;;;419                         ecx_porttime(context, parent, context->slavelist[parent].entryport);
;;;420                }
;;;421                if (dt2 < 0) dt2 = -dt2;
000666  f1c90900          RSB      r9,r9,#0
                  |L1.1642|
;;;422    
;;;423                /* calculate current slave delay from delta times */
;;;424                /* assumption : forward delay equals return delay */
;;;425                context->slavelist[i].pdelay = ((dt3 - dt1) / 2) + dt2 +
00066a  980d              LDR      r0,[sp,#0x34]
00066c  9b00              LDR      r3,[sp,#0]
00066e  eba0010a          SUB      r1,r0,r10
000672  6860              LDR      r0,[r4,#4]
000674  22e4              MOVS     r2,#0xe4
000676  eb020383          ADD      r3,r2,r3,LSL #2
00067a  eb0176d1          ADD      r6,r1,r1,LSR #31
00067e  58c3              LDR      r3,[r0,r3]
000680  eb090166          ADD      r1,r9,r6,ASR #1
000684  4419              ADD      r1,r1,r3
000686  eb020285          ADD      r2,r2,r5,LSL #2
;;;426                   context->slavelist[parent].pdelay;
;;;427                ht = htoel(context->slavelist[i].pdelay);
;;;428                /* write propagation delay*/
;;;429                (void)ecx_FPWR(context->port, slaveh, ECT_REG_DCSYSDELAY, sizeof(ht), &ht, EC_TIMEOUTRET);
00068a  2304              MOVS     r3,#4
00068c  5081              STR      r1,[r0,r2]            ;425
00068e  9106              STR      r1,[sp,#0x18]
000690  f44f61fa          MOV      r1,#0x7d0
000694  a806              ADD      r0,sp,#0x18
000696  e9cd0100          STRD     r0,r1,[sp,#0]
00069a  f6401228          MOV      r2,#0x928
00069e  6820              LDR      r0,[r4,#0]
0006a0  9907              LDR      r1,[sp,#0x1c]
0006a2  f7fffffe          BL       ecx_FPWR
0006a6  e033              B        |L1.1808|
                  |L1.1704|
;;;430             }
;;;431          }
;;;432          else
;;;433          {
;;;434             context->slavelist[i].DCrtA = 0;
0006a8  22d4              MOVS     r2,#0xd4
0006aa  eb020285          ADD      r2,r2,r5,LSL #2
0006ae  2100              MOVS     r1,#0
0006b0  5081              STR      r1,[r0,r2]
;;;435             context->slavelist[i].DCrtB = 0;
0006b2  20d8              MOVS     r0,#0xd8
0006b4  6862              LDR      r2,[r4,#4]
0006b6  eb000085          ADD      r0,r0,r5,LSL #2
0006ba  5011              STR      r1,[r2,r0]
;;;436             context->slavelist[i].DCrtC = 0;
0006bc  20dc              MOVS     r0,#0xdc
0006be  6862              LDR      r2,[r4,#4]
0006c0  eb000085          ADD      r0,r0,r5,LSL #2
0006c4  5011              STR      r1,[r2,r0]
;;;437             context->slavelist[i].DCrtD = 0;
0006c6  22e0              MOVS     r2,#0xe0
0006c8  6860              LDR      r0,[r4,#4]
0006ca  eb020285          ADD      r2,r2,r5,LSL #2
0006ce  5081              STR      r1,[r0,r2]
;;;438             parent = context->slavelist[i].parent;
0006d0  6861              LDR      r1,[r4,#4]
0006d2  20d0              MOVS     r0,#0xd0
0006d4  eb000085          ADD      r0,r0,r5,LSL #2
0006d8  5a08              LDRH     r0,[r1,r0]
;;;439             /* if non DC slave found on first position on branch hold root parent */
;;;440             if ( (parent > 0) && (context->slavelist[parent].topology > 2))
0006da  b158              CBZ      r0,|L1.1780|
0006dc  eb0002c0          ADD      r2,r0,r0,LSL #3
0006e0  eb021280          ADD      r2,r2,r0,LSL #6
0006e4  23cd              MOVS     r3,#0xcd
0006e6  eb030282          ADD      r2,r3,r2,LSL #2
0006ea  5c8a              LDRB     r2,[r1,r2]
0006ec  2a02              CMP      r2,#2
0006ee  d901              BLS      |L1.1780|
;;;441                parenthold = parent;
0006f0  9008              STR      r0,[sp,#0x20]
0006f2  e001              B        |L1.1784|
                  |L1.1780|
;;;442             /* if branch has no DC slaves consume port on root parent */
;;;443             if ( parenthold && (context->slavelist[i].topology == 1))
0006f4  9808              LDR      r0,[sp,#0x20]
0006f6  b158              CBZ      r0,|L1.1808|
                  |L1.1784|
0006f8  20cd              MOVS     r0,#0xcd
0006fa  eb000085          ADD      r0,r0,r5,LSL #2
0006fe  5c08              LDRB     r0,[r1,r0]
000700  2801              CMP      r0,#1
000702  d105              BNE      |L1.1808|
;;;444             {
;;;445                ecx_parentport(context, parenthold);
000704  4620              MOV      r0,r4
000706  9908              LDR      r1,[sp,#0x20]
000708  f7fffffe          BL       ecx_parentport
;;;446                parenthold = 0;
00070c  2000              MOVS     r0,#0
00070e  9008              STR      r0,[sp,#0x20]
                  |L1.1808|
000710  f1080001          ADD      r0,r8,#1              ;295
000714  b280              UXTH     r0,r0                 ;295
                  |L1.1814|
000716  4680              MOV      r8,r0                 ;295
000718  68a0              LDR      r0,[r4,#8]            ;295
00071a  6801              LDR      r1,[r0,#0]            ;295
00071c  4640              MOV      r0,r8                 ;295
00071e  4541              CMP      r1,r8                 ;295
000720  f6bfae14          BGE      |L1.844|
;;;447             }
;;;448          }
;;;449       }
;;;450    
;;;451       return context->slavelist[0].hasdc;
000724  6860              LDR      r0,[r4,#4]
000726  f89000cb          LDRB     r0,[r0,#0xcb]
;;;452    }
00072a  e57a              B        |L1.546|
;;;453    
                          ENDP

                  ec_dcsync0 PROC
;;;454    #ifdef EC_VER1
;;;455    void ec_dcsync0(uint16 slave, boolean act, uint32 CyclTime, uint32 CyclShift)
00072c  b538              PUSH     {r3-r5,lr}
;;;456    {
00072e  460c              MOV      r4,r1
;;;457       ecx_dcsync0(&ecx_context, slave, act, CyclTime* 1000, CyclShift);
000730  f44f717a          MOV      r1,#0x3e8
000734  9300              STR      r3,[sp,#0]
000736  fb02f301          MUL      r3,r2,r1
00073a  4601              MOV      r1,r0
00073c  4622              MOV      r2,r4
00073e  4809              LDR      r0,|L1.1892|
000740  f7fffffe          BL       ecx_dcsync0
;;;458    }
000744  bd38              POP      {r3-r5,pc}
;;;459    
                          ENDP

                  ec_dcsync01 PROC
;;;460    void ec_dcsync01(uint16 slave, boolean act, uint32 CyclTime0, uint32 CyclTime1, uint32 CyclShift)
000746  b51c              PUSH     {r2-r4,lr}
;;;461    {
000748  460c              MOV      r4,r1
00074a  9904              LDR      r1,[sp,#0x10]
00074c  e9cd3100          STRD     r3,r1,[sp,#0]
;;;462       ecx_dcsync01(&ecx_context, slave, act, CyclTime0, CyclTime1, CyclShift);
000750  4613              MOV      r3,r2
000752  4601              MOV      r1,r0
000754  4622              MOV      r2,r4
000756  4803              LDR      r0,|L1.1892|
000758  f7fffffe          BL       ecx_dcsync01
;;;463    }
00075c  bd1c              POP      {r2-r4,pc}
;;;464    
                          ENDP

                  ec_configdc PROC
;;;465    boolean ec_configdc(void)
00075e  4801              LDR      r0,|L1.1892|
;;;466    {
;;;467       return ecx_configdc(&ecx_context);
000760  e7fe              B        ecx_configdc
;;;468    }
;;;469    #endif
                          ENDP

000762  0000              DCW      0x0000
                  |L1.1892|
                          DCD      ecx_context
