; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\ethercatconfig.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\ethercatconfig.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\FWLIB\STM32F4xx_StdPeriph_Driver\inc -I..\USER -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\ETHERNET -I..\HARDWARE\TIMER -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\RTC -I..\HARDWARE\ADC -I..\HARDWARE\SRAM -I..\HARDWARE\InterTemperate -I..\FWLIB\STM32F4x7_ETH_Driver\inc -I..\MALLOC -I..\USMART -I..\HARDWARE -I..\ETHERCAT -I.\RTE\_LWIP -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS --omf_browse=..\obj\ethercatconfig.crf ..\ETHERCAT\ethercatconfig.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_p
                  ec_findconfig PROC
;;;142     */
;;;143    int ec_findconfig( uint32 man, uint32 id)
000000  b570              PUSH     {r4-r6,lr}
;;;144    {
000002  4605              MOV      r5,r0
;;;145       int i = 0;
;;;146    
;;;147       do 
;;;148       {
;;;149          i++;
;;;150       } while ( (ec_configlist[i].man != EC_CONFIGEND) && 
000004  4cfe              LDR      r4,|L1.1024|
000006  2000              MOVS     r0,#0                 ;145
                  |L1.8|
000008  1c40              ADDS     r0,r0,#1
00000a  eb000280          ADD      r2,r0,r0,LSL #2
00000e  eb0203c0          ADD      r3,r2,r0,LSL #3
000012  f8542023          LDR      r2,[r4,r3,LSL #2]
000016  1c56              ADDS     r6,r2,#1
000018  d007              BEQ      |L1.42|
;;;151               ((ec_configlist[i].man != man) || (ec_configlist[i].id != id)) );
00001a  42aa              CMP      r2,r5
00001c  d1f4              BNE      |L1.8|
00001e  eb040283          ADD      r2,r4,r3,LSL #2
000022  6852              LDR      r2,[r2,#4]
000024  428a              CMP      r2,r1
000026  d1ef              BNE      |L1.8|
;;;152       if (ec_configlist[i].man == EC_CONFIGEND)
;;;153       {
;;;154          i = 0;
;;;155       }
;;;156       return i;
;;;157    }
000028  bd70              POP      {r4-r6,pc}
                  |L1.42|
00002a  2000              MOVS     r0,#0                 ;154
00002c  bd70              POP      {r4-r6,pc}
;;;158    #endif
                          ENDP

                  ecx_init_context PROC
;;;159    void ecx_init_context(ecx_contextt *context)
00002e  b510              PUSH     {r4,lr}
;;;160    {
000030  4604              MOV      r4,r0
;;;161       int lp;
;;;162       *(context->slavecount) = 0;
000032  2000              MOVS     r0,#0
000034  68a1              LDR      r1,[r4,#8]
;;;163       /* clean ec_slave array */
;;;164       memset(context->slavelist, 0x00, sizeof(ec_slavet) * context->maxslave);
000036  6008              STR      r0,[r1,#0]
000038  68e1              LDR      r1,[r4,#0xc]
00003a  f44f7092          MOV      r0,#0x124
00003e  4341              MULS     r1,r0,r1
000040  6860              LDR      r0,[r4,#4]
000042  f7fffffe          BL       __aeabi_memclr4
;;;165       memset(context->grouplist, 0x00, sizeof(ec_groupt) * context->maxgroup);
000046  6961              LDR      r1,[r4,#0x14]
000048  f44f7094          MOV      r0,#0x128
00004c  4341              MULS     r1,r0,r1
00004e  6920              LDR      r0,[r4,#0x10]
000050  f7fffffe          BL       __aeabi_memclr4
;;;166       /* clear slave eeprom cache, does not actually read any eeprom */
;;;167       ecx_siigetbyte(context, 0, EC_MAXEEPBUF);
000054  f44f5280          MOV      r2,#0x1000
000058  2100              MOVS     r1,#0
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       ecx_siigetbyte
;;;168       for(lp = 0; lp < context->maxgroup; lp++)
000060  2100              MOVS     r1,#0
000062  e008              B        |L1.118|
                  |L1.100|
;;;169       {
;;;170          context->grouplist[lp].logstartaddr = lp << 16; /* default start address per group entry */
000064  eb010381          ADD      r3,r1,r1,LSL #2
000068  6922              LDR      r2,[r4,#0x10]
00006a  0408              LSLS     r0,r1,#16
00006c  eb031341          ADD      r3,r3,r1,LSL #5
000070  1c49              ADDS     r1,r1,#1
000072  f8420033          STR      r0,[r2,r3,LSL #3]
                  |L1.118|
000076  6960              LDR      r0,[r4,#0x14]         ;168
000078  4288              CMP      r0,r1                 ;168
00007a  dcf3              BGT      |L1.100|
;;;171       }
;;;172    }
00007c  bd10              POP      {r4,pc}
;;;173    int ecx_detect_slaves(ecx_contextt *context)
                          ENDP

                  ecx_detect_slaves PROC
00007e  e92d41ff          PUSH     {r0-r8,lr}
;;;174    {
;;;175       uint8  b;
;;;176       uint16 w;
;;;177       int    wkc;
;;;178      
;;;179    	 wkc=EC_NOFRAME;
;;;180       /* make special pre-init register writes to enable MAC[1] local administered bit *
;;;181        * setting for old netX100 slaves */
;;;182       b = 0x00;
;;;183       ecx_BWR(context->port, 0x0000, ECT_REG_DLALIAS, sizeof(b), &b, EC_TIMEOUTRET3);     /* Ignore Alias register */
000082  f2417570          MOV      r5,#0x1770
000086  ae02              ADD      r6,sp,#8
000088  4604              MOV      r4,r0                 ;174
00008a  e9cd6500          STRD     r6,r5,[sp,#0]
00008e  2000              MOVS     r0,#0                 ;182
000090  f88d0008          STRB     r0,[sp,#8]            ;182
000094  2301              MOVS     r3,#1
000096  f2401203          MOV      r2,#0x103
00009a  2100              MOVS     r1,#0
00009c  6820              LDR      r0,[r4,#0]
00009e  f7fffffe          BL       ecx_BWR
;;;184       b = EC_STATE_INIT | EC_STATE_ACK;
0000a2  e9cd6500          STRD     r6,r5,[sp,#0]
0000a6  2011              MOVS     r0,#0x11
0000a8  f88d0008          STRB     r0,[sp,#8]
;;;185       ecx_BWR(context->port, 0x0000, ECT_REG_ALCTL, sizeof(b), &b, EC_TIMEOUTRET3);       /* Reset all slaves to Init */
0000ac  f44f7790          MOV      r7,#0x120
0000b0  2301              MOVS     r3,#1
0000b2  463a              MOV      r2,r7
0000b4  2100              MOVS     r1,#0
0000b6  6820              LDR      r0,[r4,#0]
0000b8  f7fffffe          BL       ecx_BWR
0000bc  e9cd6500          STRD     r6,r5,[sp,#0]
;;;186       /* netX100 should now be happy */
;;;187       ecx_BWR(context->port, 0x0000, ECT_REG_ALCTL, sizeof(b), &b, EC_TIMEOUTRET3);       /* Reset all slaves to Init */
0000c0  2301              MOVS     r3,#1
0000c2  463a              MOV      r2,r7
0000c4  2100              MOVS     r1,#0
0000c6  6820              LDR      r0,[r4,#0]
0000c8  f7fffffe          BL       ecx_BWR
;;;188    	 wkc = ecx_BRD(context->port, 0x0000, ECT_REG_TYPE, sizeof(w), &w, EC_TIMEOUTSAFE);  /* detect number of slaves */
0000cc  f6446120          MOV      r1,#0x4e20
0000d0  a803              ADD      r0,sp,#0xc
0000d2  e9cd0100          STRD     r0,r1,[sp,#0]
0000d6  2200              MOVS     r2,#0
0000d8  2302              MOVS     r3,#2
0000da  4611              MOV      r1,r2
0000dc  6820              LDR      r0,[r4,#0]
0000de  f7fffffe          BL       ecx_BRD
;;;189    	if (wkc > 0)
0000e2  2800              CMP      r0,#0
0000e4  dd03              BLE      |L1.238|
;;;190       {
;;;191          if (wkc < EC_MAXSLAVE)
0000e6  2814              CMP      r0,#0x14
0000e8  da04              BGE      |L1.244|
;;;192          {
;;;193             *(context->slavecount) = wkc;
0000ea  68a1              LDR      r1,[r4,#8]
0000ec  6008              STR      r0,[r1,#0]
                  |L1.238|
;;;194          }
;;;195          else
;;;196          {
;;;197             EC_PRINT("Error: too many slaves on network: num_slaves=%d, EC_MAXSLAVE=%d\n",
;;;198                   wkc, EC_MAXSLAVE);
;;;199             return -4;/** return value too many slaves */
;;;200          }
;;;201       }
;;;202       return wkc;
;;;203    }
0000ee  b004              ADD      sp,sp,#0x10
                  |L1.240|
0000f0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.244|
0000f4  4601              MOV      r1,r0                 ;197
0000f6  2214              MOVS     r2,#0x14              ;197
0000f8  48c2              LDR      r0,|L1.1028|
0000fa  f7fffffe          BL       __2printf
0000fe  f06f0003          MVN      r0,#3                 ;199
000102  e7f4              B        |L1.238|
;;;204    
                          ENDP

                  ecx_set_slaves_to_default PROC
;;;205    static void ecx_set_slaves_to_default(ecx_contextt *context)
000104  e92d43f0          PUSH     {r4-r9,lr}
;;;206    {
000108  b095              SUB      sp,sp,#0x54
00010a  4604              MOV      r4,r0
;;;207       uint8 b;
;;;208       uint16 w;
;;;209       uint8 zbuf[64];
;;;210       memset(&zbuf, 0x00, sizeof(zbuf));
00010c  2140              MOVS     r1,#0x40
00010e  a802              ADD      r0,sp,#8
000110  f7fffffe          BL       __aeabi_memclr4
;;;211       b = 0x00;
;;;212       ecx_BWR(context->port, 0x0000, ECT_REG_DLPORT      , sizeof(b) , &b, EC_TIMEOUTRET3);     /* deact loop manual */
000114  f2417570          MOV      r5,#0x1770
000118  ae12              ADD      r6,sp,#0x48
00011a  f04f0900          MOV      r9,#0                 ;211
00011e  e9cd6500          STRD     r6,r5,[sp,#0]
000122  f88d9048          STRB     r9,[sp,#0x48]         ;211
000126  2301              MOVS     r3,#1
000128  f2401201          MOV      r2,#0x101
00012c  4649              MOV      r1,r9
00012e  6820              LDR      r0,[r4,#0]
000130  f7fffffe          BL       ecx_BWR
;;;213    	  w = htoes(0x0004);
;;;214       ecx_BWR(context->port, 0x0000, ECT_REG_IRQMASK     , sizeof(w) , &w, EC_TIMEOUTRET3);     /* set IRQ mask */
000134  f10d084c          ADD      r8,sp,#0x4c
000138  e9cd8500          STRD     r8,r5,[sp,#0]
00013c  2004              MOVS     r0,#4                 ;213
00013e  f8ad004c          STRH     r0,[sp,#0x4c]         ;213
000142  2302              MOVS     r3,#2
000144  021a              LSLS     r2,r3,#8
000146  2100              MOVS     r1,#0
000148  6820              LDR      r0,[r4,#0]
00014a  f7fffffe          BL       ecx_BWR
;;;215       ecx_BWR(context->port, 0x0000, ECT_REG_RXERR       , 8         , &zbuf, EC_TIMEOUTRET3);  /* reset CRC counters */
00014e  af02              ADD      r7,sp,#8
000150  e9cd7500          STRD     r7,r5,[sp,#0]
000154  2308              MOVS     r3,#8
000156  f44f7240          MOV      r2,#0x300
00015a  2100              MOVS     r1,#0
00015c  6820              LDR      r0,[r4,#0]
00015e  f7fffffe          BL       ecx_BWR
000162  e9cd7500          STRD     r7,r5,[sp,#0]
;;;216       ecx_BWR(context->port, 0x0000, ECT_REG_FMMU0       , 16 * 3    , &zbuf, EC_TIMEOUTRET3);  /* reset FMMU's */
000166  2330              MOVS     r3,#0x30
000168  015a              LSLS     r2,r3,#5
00016a  2100              MOVS     r1,#0
00016c  6820              LDR      r0,[r4,#0]
00016e  f7fffffe          BL       ecx_BWR
000172  e9cd7500          STRD     r7,r5,[sp,#0]
;;;217       ecx_BWR(context->port, 0x0000, ECT_REG_SM0         , 8 * 4     , &zbuf, EC_TIMEOUTRET3);  /* reset SyncM */
000176  2320              MOVS     r3,#0x20
000178  019a              LSLS     r2,r3,#6
00017a  2100              MOVS     r1,#0
00017c  6820              LDR      r0,[r4,#0]
00017e  f7fffffe          BL       ecx_BWR
000182  e9cd7500          STRD     r7,r5,[sp,#0]
;;;218    //   b = 0x00;
;;;219    //   ecx_BWR(context->port, 0x0000, ECT_REG_DCSYNCACT   , sizeof(b) , &b   , EC_TIMEOUTRET3);  /* disable DC */
;;;220       ecx_BWR(context->port, 0x0000, ECT_REG_DCSYSTIME   , 4         , &zbuf, EC_TIMEOUTRET3);  /* reset system time+ofs */
000186  2304              MOVS     r3,#4
000188  f44f6211          MOV      r2,#0x910
00018c  2100              MOVS     r1,#0
00018e  6820              LDR      r0,[r4,#0]
000190  f7fffffe          BL       ecx_BWR
;;;221       w = htoes(0x1000);
000194  e9cd8500          STRD     r8,r5,[sp,#0]
000198  f44f5080          MOV      r0,#0x1000
00019c  f8ad004c          STRH     r0,[sp,#0x4c]
;;;222       ecx_BWR(context->port, 0x0000, ECT_REG_DCSPEEDCNT  , sizeof(w) , &w, EC_TIMEOUTRET3);     /* DC speedstart */
0001a0  2302              MOVS     r3,#2
0001a2  f44f6213          MOV      r2,#0x930
0001a6  2100              MOVS     r1,#0
0001a8  6820              LDR      r0,[r4,#0]
0001aa  f7fffffe          BL       ecx_BWR
;;;223       w = htoes(0x0c00);
0001ae  e9cd8500          STRD     r8,r5,[sp,#0]
0001b2  f44f6040          MOV      r0,#0xc00
0001b6  f8ad004c          STRH     r0,[sp,#0x4c]
;;;224       ecx_BWR(context->port, 0x0000, ECT_REG_DCTIMEFILT  , sizeof(w) , &w, EC_TIMEOUTRET3);     /* DC filt expr */
0001ba  2302              MOVS     r3,#2
0001bc  f6401234          MOV      r2,#0x934
0001c0  2100              MOVS     r1,#0
0001c2  6820              LDR      r0,[r4,#0]
0001c4  f7fffffe          BL       ecx_BWR
;;;225       b = 0x00;
0001c8  e9cd6500          STRD     r6,r5,[sp,#0]
0001cc  f88d9048          STRB     r9,[sp,#0x48]
;;;226       ecx_BWR(context->port, 0x0000, ECT_REG_DLALIAS     , sizeof(b) , &b, EC_TIMEOUTRET3);     /* Ignore Alias register */
0001d0  2301              MOVS     r3,#1
0001d2  f2401203          MOV      r2,#0x103
0001d6  2100              MOVS     r1,#0
0001d8  6820              LDR      r0,[r4,#0]
0001da  f7fffffe          BL       ecx_BWR
;;;227       b = EC_STATE_INIT | EC_STATE_ACK;
0001de  e9cd6500          STRD     r6,r5,[sp,#0]
0001e2  2011              MOVS     r0,#0x11
0001e4  f88d0048          STRB     r0,[sp,#0x48]
;;;228       ecx_BWR(context->port, 0x0000, ECT_REG_ALCTL       , sizeof(b) , &b, EC_TIMEOUTRET3);     /* Reset all slaves to Init */
0001e8  2301              MOVS     r3,#1
0001ea  f44f7290          MOV      r2,#0x120
0001ee  2100              MOVS     r1,#0
0001f0  6820              LDR      r0,[r4,#0]
0001f2  f7fffffe          BL       ecx_BWR
;;;229       b = 2;
0001f6  e9cd6500          STRD     r6,r5,[sp,#0]
0001fa  2002              MOVS     r0,#2
0001fc  f88d0048          STRB     r0,[sp,#0x48]
;;;230       ecx_BWR(context->port, 0x0000, ECT_REG_EEPCFG      , sizeof(b) , &b, EC_TIMEOUTRET3);     /* force ECAT access to Eeprom from PDI */
000200  f44f67a0          MOV      r7,#0x500
000204  2301              MOVS     r3,#1
000206  463a              MOV      r2,r7
000208  2100              MOVS     r1,#0
00020a  6820              LDR      r0,[r4,#0]
00020c  f7fffffe          BL       ecx_BWR
;;;231       b = 0;
000210  e9cd6500          STRD     r6,r5,[sp,#0]
000214  f88d9048          STRB     r9,[sp,#0x48]
;;;232       ecx_BWR(context->port, 0x0000, ECT_REG_EEPCFG      , sizeof(b) , &b, EC_TIMEOUTRET3);     /* set Eeprom to master */
000218  2301              MOVS     r3,#1
00021a  463a              MOV      r2,r7
00021c  2100              MOVS     r1,#0
00021e  6820              LDR      r0,[r4,#0]
000220  f7fffffe          BL       ecx_BWR
;;;233    }
000224  b015              ADD      sp,sp,#0x54
000226  e8bd83f0          POP      {r4-r9,pc}
;;;234    #ifdef EC_VER1
                          ENDP

                  ecx_config_from_table PROC
;;;235    static int ecx_config_from_table(ecx_contextt *context, uint16 slave)
00022a  e92d41f0          PUSH     {r4-r8,lr}
;;;236    {
;;;237       int cindex;
;;;238       ec_slavet *csl;
;;;239       
;;;240       csl = &(context->slavelist[slave]);
00022e  6840              LDR      r0,[r0,#4]
000230  eb0102c1          ADD      r2,r1,r1,LSL #3
000234  eb021181          ADD      r1,r2,r1,LSL #6
000238  eb000481          ADD      r4,r0,r1,LSL #2
00023c  e9d40102          LDRD     r0,r1,[r4,#8]
;;;241       cindex = ec_findconfig( csl->eep_man, csl->eep_id );
000240  f7fffffe          BL       ec_findconfig
000244  4606              MOV      r6,r0
;;;242       csl->configindex= cindex;
000246  f8a400f6          STRH     r0,[r4,#0xf6]
;;;243       /* slave found in configuration table ? */
;;;244       if (cindex)
00024a  0030              MOVS     r0,r6
00024c  d041              BEQ      |L1.722|
;;;245       {
;;;246          csl->Dtype = ec_configlist[cindex].Dtype;            
00024e  eb060086          ADD      r0,r6,r6,LSL #2
000252  eb0001c6          ADD      r1,r0,r6,LSL #3
000256  486a              LDR      r0,|L1.1024|
000258  eb000581          ADD      r5,r0,r1,LSL #2
;;;247          strcpy(csl->name ,ec_configlist[cindex].name);
00025c  f1050108          ADD      r1,r5,#8
000260  7f68              LDRB     r0,[r5,#0x1d]         ;246
000262  82e0              STRH     r0,[r4,#0x16]         ;246
000264  f5047086          ADD      r0,r4,#0x10c
000268  f7fffffe          BL       strcpy
;;;248          csl->Ibits = ec_configlist[cindex].Ibits;
00026c  8be8              LDRH     r0,[r5,#0x1e]
00026e  84e0              STRH     r0,[r4,#0x26]
;;;249          csl->Obits = ec_configlist[cindex].Obits;
000270  8c29              LDRH     r1,[r5,#0x20]
000272  8321              STRH     r1,[r4,#0x18]
;;;250          if (csl->Obits)
;;;251          {
;;;252             csl->FMMU0func = 1;
000274  2301              MOVS     r3,#1
000276  b109              CBZ      r1,|L1.636|
000278  f88430bc          STRB     r3,[r4,#0xbc]
                  |L1.636|
;;;253          }
;;;254          if (csl->Ibits)
;;;255          {
;;;256             csl->FMMU1func = 2;
00027c  2702              MOVS     r7,#2
00027e  b108              CBZ      r0,|L1.644|
000280  f88470bd          STRB     r7,[r4,#0xbd]
                  |L1.644|
;;;257          }
;;;258          csl->FMMU[0].FMMUactive = ec_configlist[cindex].FM0ac;
000284  f8952030          LDRB     r2,[r5,#0x30]
000288  f8842088          STRB     r2,[r4,#0x88]
;;;259          csl->FMMU[1].FMMUactive = ec_configlist[cindex].FM1ac;
00028c  f8952031          LDRB     r2,[r5,#0x31]
000290  f8842098          STRB     r2,[r4,#0x98]
;;;260          csl->SM[2].StartAddr = htoes(ec_configlist[cindex].SM2a);
000294  8c6a              LDRH     r2,[r5,#0x22]
000296  f8a42044          STRH     r2,[r4,#0x44]
;;;261          csl->SM[2].SMflags = htoel(ec_configlist[cindex].SM2f);
00029a  f8d5c024          LDR      r12,[r5,#0x24]
;;;262          /* simple (no mailbox) output slave found ? */
;;;263          if (csl->Obits && !csl->SM[2].StartAddr)
;;;264          {
;;;265             csl->SM[0].StartAddr = htoes(0x0f00);
;;;266             csl->SM[0].SMlength = htoes((csl->Obits + 7) / 8);
;;;267             csl->SM[0].SMflags = htoel(EC_DEFAULTDOSM0);         
;;;268             csl->FMMU[0].FMMUactive = 1;
;;;269             csl->FMMU[0].FMMUtype = 2;
;;;270             csl->SMtype[0] = 3;
00029e  f8c4c048          STR      r12,[r4,#0x48]
0002a2  f04f0c03          MOV      r12,#3
0002a6  b101              CBZ      r1,|L1.682|
0002a8  b1aa              CBZ      r2,|L1.726|
                  |L1.682|
0002aa  1dc9              ADDS     r1,r1,#7              ;263
;;;271          }
;;;272          /* complex output slave */
;;;273          else
;;;274          {
;;;275             csl->SM[2].SMlength = htoes((csl->Obits + 7) / 8);
0002ac  08c9              LSRS     r1,r1,#3
0002ae  f8a41046          STRH     r1,[r4,#0x46]
;;;276             csl->SMtype[2] = 3;
0002b2  f884c076          STRB     r12,[r4,#0x76]
                  |L1.694|
;;;277          }   
;;;278          csl->SM[3].StartAddr = htoes(ec_configlist[cindex].SM3a);
0002b6  8d29              LDRH     r1,[r5,#0x28]
0002b8  f8a4104c          STRH     r1,[r4,#0x4c]
;;;279          csl->SM[3].SMflags = htoel(ec_configlist[cindex].SM3f);
0002bc  6aea              LDR      r2,[r5,#0x2c]
;;;280          /* simple (no mailbox) input slave found ? */
;;;281          if (csl->Ibits && !csl->SM[3].StartAddr)
;;;282          {
;;;283             csl->SM[1].StartAddr = htoes(0x1000);
;;;284             csl->SM[1].SMlength = htoes((csl->Ibits + 7) / 8);
;;;285             csl->SM[1].SMflags = htoel(0x00000000);         
;;;286             csl->FMMU[1].FMMUactive = 1;
;;;287             csl->FMMU[1].FMMUtype = 1;
;;;288             csl->SMtype[1] = 4;
0002be  6522              STR      r2,[r4,#0x50]
0002c0  2204              MOVS     r2,#4
0002c2  b100              CBZ      r0,|L1.710|
0002c4  b1b1              CBZ      r1,|L1.756|
                  |L1.710|
0002c6  1dc0              ADDS     r0,r0,#7              ;281
;;;289          }
;;;290          /* complex input slave */
;;;291          else
;;;292          {
;;;293             csl->SM[3].SMlength = htoes((csl->Ibits + 7) / 8);
0002c8  08c0              LSRS     r0,r0,#3
0002ca  f8a4004e          STRH     r0,[r4,#0x4e]
;;;294             csl->SMtype[3] = 4;
0002ce  f8842077          STRB     r2,[r4,#0x77]
                  |L1.722|
;;;295          }   
;;;296       }
;;;297       return cindex;
0002d2  4630              MOV      r0,r6
;;;298    }
0002d4  e70c              B        |L1.240|
                  |L1.726|
0002d6  f44f6270          MOV      r2,#0xf00             ;265
0002da  1dc9              ADDS     r1,r1,#7              ;265
0002dc  86a2              STRH     r2,[r4,#0x34]         ;265
0002de  08c9              LSRS     r1,r1,#3              ;266
0002e0  86e1              STRH     r1,[r4,#0x36]         ;266
0002e2  4949              LDR      r1,|L1.1032|
0002e4  63a1              STR      r1,[r4,#0x38]         ;268
0002e6  f8843088          STRB     r3,[r4,#0x88]         ;268
0002ea  f8847087          STRB     r7,[r4,#0x87]         ;269
0002ee  f884c074          STRB     r12,[r4,#0x74]        ;270
0002f2  e7e0              B        |L1.694|
                  |L1.756|
0002f4  f44f5180          MOV      r1,#0x1000            ;283
0002f8  1dc0              ADDS     r0,r0,#7              ;283
0002fa  87a1              STRH     r1,[r4,#0x3c]         ;283
0002fc  08c0              LSRS     r0,r0,#3              ;284
0002fe  87e0              STRH     r0,[r4,#0x3e]         ;284
000300  2000              MOVS     r0,#0                 ;285
000302  6420              STR      r0,[r4,#0x40]         ;286
000304  f8843098          STRB     r3,[r4,#0x98]         ;286
000308  f8843097          STRB     r3,[r4,#0x97]         ;287
00030c  f8842075          STRB     r2,[r4,#0x75]         ;288
000310  e7df              B        |L1.722|
;;;299    #else
                          ENDP

                  ecx_lookup_prev_sii PROC
;;;307     */
;;;308    static int ecx_lookup_prev_sii(ecx_contextt *context, uint16 slave)
000312  e92d47f0          PUSH     {r4-r10,lr}
;;;309    {
000316  4689              MOV      r9,r1
000318  4606              MOV      r6,r0
;;;310       int i, nSM;
;;;311       if ((slave > 1) && (*(context->slavecount) > 0))
00031a  2901              CMP      r1,#1
00031c  d976              BLS      |L1.1036|
00031e  68b0              LDR      r0,[r6,#8]
000320  6800              LDR      r0,[r0,#0]
000322  2800              CMP      r0,#0
000324  dd72              BLE      |L1.1036|
;;;312       {
;;;313          i = 1;
;;;314          while(((context->slavelist[i].eep_man != context->slavelist[slave].eep_man) ||
000326  eb0901c9          ADD      r1,r9,r9,LSL #3
00032a  eb011489          ADD      r4,r1,r9,LSL #6
00032e  f04f0c08          MOV      r12,#8
000332  6870              LDR      r0,[r6,#4]
000334  eb0c0184          ADD      r1,r12,r4,LSL #2
000338  2701              MOVS     r7,#1                 ;313
00033a  5842              LDR      r2,[r0,r1]
00033c  e000              B        |L1.832|
                  |L1.830|
00033e  1c7f              ADDS     r7,r7,#1
                  |L1.832|
000340  eb0701c7          ADD      r1,r7,r7,LSL #3
000344  eb011587          ADD      r5,r1,r7,LSL #6
000348  eb0c0185          ADD      r1,r12,r5,LSL #2
00034c  5841              LDR      r1,[r0,r1]
00034e  4291              CMP      r1,r2
000350  d111              BNE      |L1.886|
;;;315                 (context->slavelist[i].eep_id  != context->slavelist[slave].eep_id ) ||
000352  210c              MOVS     r1,#0xc
000354  eb010385          ADD      r3,r1,r5,LSL #2
000358  eb010184          ADD      r1,r1,r4,LSL #2
00035c  58c3              LDR      r3,[r0,r3]
00035e  5841              LDR      r1,[r0,r1]
000360  428b              CMP      r3,r1
000362  d108              BNE      |L1.886|
;;;316                 (context->slavelist[i].eep_rev != context->slavelist[slave].eep_rev)) &&
000364  2110              MOVS     r1,#0x10
000366  eb010385          ADD      r3,r1,r5,LSL #2
00036a  eb010184          ADD      r1,r1,r4,LSL #2
00036e  58c3              LDR      r3,[r0,r3]
000370  5841              LDR      r1,[r0,r1]
000372  428b              CMP      r3,r1
000374  d001              BEQ      |L1.890|
                  |L1.886|
;;;317                (i < slave))
000376  454f              CMP      r7,r9
000378  dbe1              BLT      |L1.830|
                  |L1.890|
;;;318          {
;;;319             i++;
;;;320          }
;;;321          if(i < slave)
00037a  454f              CMP      r7,r9
00037c  da46              BGE      |L1.1036|
;;;322          {
;;;323             context->slavelist[slave].CoEdetails = context->slavelist[i].CoEdetails;
00037e  eb0701c7          ADD      r1,r7,r7,LSL #3
000382  eb011287          ADD      r2,r1,r7,LSL #6
000386  21fc              MOVS     r1,#0xfc
000388  eb010282          ADD      r2,r1,r2,LSL #2
00038c  eb010184          ADD      r1,r1,r4,LSL #2
000390  5c82              LDRB     r2,[r0,r2]
000392  5442              STRB     r2,[r0,r1]
;;;324             context->slavelist[slave].FoEdetails = context->slavelist[i].FoEdetails;
000394  21fd              MOVS     r1,#0xfd
000396  6870              LDR      r0,[r6,#4]
000398  eb010285          ADD      r2,r1,r5,LSL #2
00039c  eb010184          ADD      r1,r1,r4,LSL #2
0003a0  5c82              LDRB     r2,[r0,r2]
0003a2  5442              STRB     r2,[r0,r1]
;;;325             context->slavelist[slave].EoEdetails = context->slavelist[i].EoEdetails;
0003a4  21fe              MOVS     r1,#0xfe
0003a6  6870              LDR      r0,[r6,#4]
0003a8  eb010285          ADD      r2,r1,r5,LSL #2
0003ac  eb010184          ADD      r1,r1,r4,LSL #2
0003b0  5c82              LDRB     r2,[r0,r2]
0003b2  5442              STRB     r2,[r0,r1]
;;;326             context->slavelist[slave].SoEdetails = context->slavelist[i].SoEdetails;
0003b4  21ff              MOVS     r1,#0xff
0003b6  6870              LDR      r0,[r6,#4]
0003b8  eb010285          ADD      r2,r1,r5,LSL #2
0003bc  eb010184          ADD      r1,r1,r4,LSL #2
0003c0  5c82              LDRB     r2,[r0,r2]
0003c2  5442              STRB     r2,[r0,r1]
;;;327             if(context->slavelist[i].blockLRW > 0)
0003c4  f44f7181          MOV      r1,#0x102
0003c8  6870              LDR      r0,[r6,#4]
0003ca  eb010285          ADD      r2,r1,r5,LSL #2
0003ce  5c82              LDRB     r2,[r0,r2]
0003d0  b14a              CBZ      r2,|L1.998|
;;;328             {
;;;329                context->slavelist[slave].blockLRW = 1;
0003d2  eb010184          ADD      r1,r1,r4,LSL #2
0003d6  2201              MOVS     r2,#1
0003d8  5442              STRB     r2,[r0,r1]
;;;330                context->slavelist[0].blockLRW++;                  
0003da  6870              LDR      r0,[r6,#4]
0003dc  f8901102          LDRB     r1,[r0,#0x102]
0003e0  1c49              ADDS     r1,r1,#1
0003e2  f8801102          STRB     r1,[r0,#0x102]
                  |L1.998|
;;;331             }   
;;;332             context->slavelist[slave].Ebuscurrent = context->slavelist[i].Ebuscurrent;
0003e6  f44f7280          MOV      r2,#0x100
0003ea  6870              LDR      r0,[r6,#4]
0003ec  eb020185          ADD      r1,r2,r5,LSL #2
0003f0  eb020284          ADD      r2,r2,r4,LSL #2
0003f4  5a41              LDRH     r1,[r0,r1]
0003f6  5281              STRH     r1,[r0,r2]
;;;333             context->slavelist[0].Ebuscurrent += context->slavelist[slave].Ebuscurrent;
0003f8  6870              LDR      r0,[r6,#4]
0003fa  f8b02100          LDRH     r2,[r0,#0x100]
0003fe  e006              B        |L1.1038|
                  |L1.1024|
                          DCD      ||.constdata||
                  |L1.1028|
                          DCD      ||.conststring||
                  |L1.1032|
                          DCD      0x00010044
                  |L1.1036|
00040c  e05b              B        |L1.1222|
                  |L1.1038|
00040e  4411              ADD      r1,r1,r2
000410  f8a01100          STRH     r1,[r0,#0x100]
;;;334             memcpy(context->slavelist[slave].name, context->slavelist[i].name, EC_MAXNAME + 1);
000414  f44f7286          MOV      r2,#0x10c
000418  eb020185          ADD      r1,r2,r5,LSL #2
00041c  6870              LDR      r0,[r6,#4]
00041e  eb020284          ADD      r2,r2,r4,LSL #2
000422  4401              ADD      r1,r1,r0
000424  4410              ADD      r0,r0,r2
000426  2215              MOVS     r2,#0x15
000428  f7fffffe          BL       __aeabi_memcpy4
;;;335             for( nSM=0 ; nSM < EC_MAXSM ; nSM++ )
00042c  2000              MOVS     r0,#0
;;;336             {
;;;337                context->slavelist[slave].SM[nSM].StartAddr = context->slavelist[i].SM[nSM].StartAddr; 
00042e  f04f0c34          MOV      r12,#0x34
;;;338                context->slavelist[slave].SM[nSM].SMlength  = context->slavelist[i].SM[nSM].SMlength; 
000432  f04f0a36          MOV      r10,#0x36
;;;339                context->slavelist[slave].SM[nSM].SMflags   = context->slavelist[i].SM[nSM].SMflags;  
000436  f04f0838          MOV      r8,#0x38
                  |L1.1082|
00043a  6872              LDR      r2,[r6,#4]            ;337
00043c  eb0c01c0          ADD      r1,r12,r0,LSL #3      ;337
000440  eb020385          ADD      r3,r2,r5,LSL #2       ;337
000444  eb020284          ADD      r2,r2,r4,LSL #2       ;337
000448  5a5b              LDRH     r3,[r3,r1]            ;337
00044a  5253              STRH     r3,[r2,r1]            ;337
00044c  6871              LDR      r1,[r6,#4]            ;338
00044e  eb0a02c0          ADD      r2,r10,r0,LSL #3      ;338
000452  eb010385          ADD      r3,r1,r5,LSL #2       ;338
000456  eb010184          ADD      r1,r1,r4,LSL #2       ;338
00045a  5a9b              LDRH     r3,[r3,r2]            ;338
00045c  528b              STRH     r3,[r1,r2]            ;338
00045e  6872              LDR      r2,[r6,#4]
000460  eb0801c0          ADD      r1,r8,r0,LSL #3
000464  eb020385          ADD      r3,r2,r5,LSL #2
000468  eb020284          ADD      r2,r2,r4,LSL #2
00046c  585b              LDR      r3,[r3,r1]
00046e  1c40              ADDS     r0,r0,#1
000470  5053              STR      r3,[r2,r1]
000472  2808              CMP      r0,#8                 ;335
000474  dbe1              BLT      |L1.1082|
;;;340             }                                           
;;;341             context->slavelist[slave].FMMU0func = context->slavelist[i].FMMU0func;
000476  21bc              MOVS     r1,#0xbc
000478  6870              LDR      r0,[r6,#4]
00047a  eb010285          ADD      r2,r1,r5,LSL #2
00047e  eb010184          ADD      r1,r1,r4,LSL #2
000482  5c82              LDRB     r2,[r0,r2]
000484  5442              STRB     r2,[r0,r1]
;;;342             context->slavelist[slave].FMMU1func = context->slavelist[i].FMMU1func;
000486  21bd              MOVS     r1,#0xbd
000488  6870              LDR      r0,[r6,#4]
00048a  eb010285          ADD      r2,r1,r5,LSL #2
00048e  eb010184          ADD      r1,r1,r4,LSL #2
000492  5c82              LDRB     r2,[r0,r2]
000494  5442              STRB     r2,[r0,r1]
;;;343             context->slavelist[slave].FMMU2func = context->slavelist[i].FMMU2func;
000496  21be              MOVS     r1,#0xbe
000498  6870              LDR      r0,[r6,#4]
00049a  eb010285          ADD      r2,r1,r5,LSL #2
00049e  eb010184          ADD      r1,r1,r4,LSL #2
0004a2  5c82              LDRB     r2,[r0,r2]
0004a4  5442              STRB     r2,[r0,r1]
;;;344             context->slavelist[slave].FMMU3func = context->slavelist[i].FMMU3func;
0004a6  21bf              MOVS     r1,#0xbf
0004a8  6870              LDR      r0,[r6,#4]
0004aa  eb010285          ADD      r2,r1,r5,LSL #2
0004ae  eb010184          ADD      r1,r1,r4,LSL #2
0004b2  5c82              LDRB     r2,[r0,r2]
0004b4  5442              STRB     r2,[r0,r1]
;;;345             EC_PRINT("Copy SII slave %d from %d.\n", slave, i);
0004b6  463a              MOV      r2,r7
0004b8  4649              MOV      r1,r9
0004ba  a0fe              ADR      r0,|L1.2228|
0004bc  f7fffffe          BL       __2printf
;;;346             return 1;
0004c0  2001              MOVS     r0,#1
                  |L1.1218|
;;;347          }
;;;348       }
;;;349       return 0;
;;;350    }
0004c2  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1222|
0004c6  2000              MOVS     r0,#0                 ;349
0004c8  e7fb              B        |L1.1218|
;;;351                      
                          ENDP

                  ecx_config_init PROC
;;;358    
;;;359    int ecx_config_init(ecx_contextt *context, uint8 usetable)
0004ca  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;360    {
0004ce  b087              SUB      sp,sp,#0x1c
0004d0  4604              MOV      r4,r0
;;;361       uint16 slave, ADPh, configadr, ssigen;
;;;362       uint16 topology, estat;
;;;363       int16 topoc, slavec, aliasadr;
;;;364       uint8 b,h;
;;;365       uint8 SMc;
;;;366    	 uint16 w;
;;;367       uint32 eedat;
;;;368       int wkc, cindex, nSM;
;;;369    	 uint8 i;
;;;370    	
;;;371       ecx_init_context(context);       /* 初始化变量 */
0004d2  f7fffffe          BL       ecx_init_context
;;;372    	wkc = ecx_detect_slaves(context);/* 查找从站 wkc>0 查找到从站，反之则未找到从站 */
0004d6  4620              MOV      r0,r4
0004d8  f7fffffe          BL       ecx_detect_slaves
;;;373    	 if(wkc>0)
0004dc  9003              STR      r0,[sp,#0xc]
0004de  2800              CMP      r0,#0
0004e0  dd6f              BLE      |L1.1474|
;;;374    	 {
;;;375             ecx_set_slaves_to_default(context); /* 初始化从站 */
0004e2  4620              MOV      r0,r4
0004e4  f7fffffe          BL       ecx_set_slaves_to_default
;;;376    		     // 设置 从站 node id
;;;377    				 for (slave = 1; slave <= *(context->slavecount); slave++)
0004e8  2501              MOVS     r5,#1
0004ea  46aa              MOV      r10,r5
0004ec  e05f              B        |L1.1454|
                  |L1.1262|
;;;378    						{
;;;379    							 ADPh = (uint16)(1 - slave);
0004ee  f1c50001          RSB      r0,r5,#1
0004f2  fa1ff880          UXTH     r8,r0
;;;380    							 context->slavelist[slave].Itype = 
0004f6  f2417770          MOV      r7,#0x1770
0004fa  463b              MOV      r3,r7
0004fc  f44f72a0          MOV      r2,#0x140
000500  4641              MOV      r1,r8
000502  6820              LDR      r0,[r4,#0]
000504  f7fffffe          BL       ecx_APRDw
000508  eb0502c5          ADD      r2,r5,r5,LSL #3
00050c  eb021685          ADD      r6,r2,r5,LSL #6
000510  6861              LDR      r1,[r4,#4]
000512  2214              MOVS     r2,#0x14
000514  eb020286          ADD      r2,r2,r6,LSL #2
000518  5288              STRH     r0,[r1,r2]
;;;381    									etohs(ecx_APRDw(context->port, ADPh, ECT_REG_PDICTL, EC_TIMEOUTRET3)); /* read interface type of slave */
;;;382    							 /* a node offset is used to improve readibility of network frames */
;;;383    							 /* this has no impact on the number of addressable slaves (auto wrap around) */
;;;384    							 ecx_APWRw(context->port, ADPh, ECT_REG_STADR, htoes(slave + EC_NODEOFFSET) , EC_TIMEOUTRET3); /* set node address of slave */
00051a  f505707a          ADD      r0,r5,#0x3e8
00051e  b283              UXTH     r3,r0
000520  9700              STR      r7,[sp,#0]
000522  2210              MOVS     r2,#0x10
000524  4641              MOV      r1,r8
000526  6820              LDR      r0,[r4,#0]
000528  f7fffffe          BL       ecx_APWRw
;;;385    							 if (slave == 1) 
00052c  2d01              CMP      r5,#1
00052e  d046              BEQ      |L1.1470|
;;;386    							 {
;;;387    									b = 1; /* kill non ecat frames for first slave */
;;;388    							 }
;;;389    							 else 
;;;390    							 {
;;;391    									b = 0; /* pass all frames for following slaves */
000530  2300              MOVS     r3,#0
                  |L1.1330|
;;;392    							 }
;;;393    							 ecx_APWRw(context->port, ADPh, ECT_REG_DLCTL, htoes(b), EC_TIMEOUTRET3); /* set non ecat frame behaviour */
000532  9700              STR      r7,[sp,#0]
000534  f44f7280          MOV      r2,#0x100
000538  4641              MOV      r1,r8
00053a  6820              LDR      r0,[r4,#0]
00053c  f7fffffe          BL       ecx_APWRw
;;;394    							 configadr = etohs(ecx_APRDw(context->port, ADPh, ECT_REG_STADR, EC_TIMEOUTRET3));  // get configure address						 
000540  463b              MOV      r3,r7
000542  2210              MOVS     r2,#0x10
000544  4641              MOV      r1,r8
000546  6820              LDR      r0,[r4,#0]
000548  f7fffffe          BL       ecx_APRDw
;;;395    							 context->slavelist[slave].configadr = configadr;
00054c  6862              LDR      r2,[r4,#4]
00054e  2104              MOVS     r1,#4
000550  eb010186          ADD      r1,r1,r6,LSL #2
000554  5250              STRH     r0,[r2,r1]
000556  4680              MOV      r8,r0                 ;394
;;;396    
;;;397    							 ecx_FPRD(context->port, configadr, ECT_REG_ALIAS, sizeof(aliasadr), &aliasadr, EC_TIMEOUTRET3);  // get  alias address				   
000558  a805              ADD      r0,sp,#0x14
00055a  e9cd0700          STRD     r0,r7,[sp,#0]
00055e  2302              MOVS     r3,#2
000560  2212              MOVS     r2,#0x12
000562  4641              MOV      r1,r8
000564  6820              LDR      r0,[r4,#0]
000566  f7fffffe          BL       ecx_FPRD
;;;398    							   context->slavelist[slave].aliasadr = etohs(aliasadr);
00056a  6861              LDR      r1,[r4,#4]
00056c  2206              MOVS     r2,#6
00056e  f8bd0014          LDRH     r0,[sp,#0x14]
000572  eb020286          ADD      r2,r2,r6,LSL #2
000576  5288              STRH     r0,[r1,r2]
;;;399    							 ecx_FPRD(context->port, configadr, ECT_REG_EEPSTAT, sizeof(estat), &estat, EC_TIMEOUTRET3);      // 
000578  a804              ADD      r0,sp,#0x10
00057a  e9cd0700          STRD     r0,r7,[sp,#0]
00057e  2302              MOVS     r3,#2
000580  f2405202          MOV      r2,#0x502
000584  4641              MOV      r1,r8
000586  6820              LDR      r0,[r4,#0]
000588  f7fffffe          BL       ecx_FPRD
;;;400    							 estat = etohs(estat);
00058c  f8bd0010          LDRH     r0,[sp,#0x10]
;;;401    							 if (estat & EC_ESTAT_R64) /* check if slave can read 8 byte chunks */
000590  0640              LSLS     r0,r0,#25
000592  d505              BPL      |L1.1440|
;;;402    							 {
;;;403    									context->slavelist[slave].eep_8byte = 1;
000594  22fa              MOVS     r2,#0xfa
000596  6861              LDR      r1,[r4,#4]
000598  eb020286          ADD      r2,r2,r6,LSL #2
00059c  f801a002          STRB     r10,[r1,r2]
                  |L1.1440|
;;;404    							 }
;;;405    							 ecx_readeeprom1(context, slave, ECT_SII_MANUF); /* Manuf */
0005a0  2208              MOVS     r2,#8
0005a2  4629              MOV      r1,r5
0005a4  4620              MOV      r0,r4
0005a6  f7fffffe          BL       ecx_readeeprom1
0005aa  1c6d              ADDS     r5,r5,#1
0005ac  b2ad              UXTH     r5,r5                 ;377
                  |L1.1454|
0005ae  68a0              LDR      r0,[r4,#8]            ;377
0005b0  6800              LDR      r0,[r0,#0]            ;377
0005b2  42a8              CMP      r0,r5                 ;377
0005b4  da9b              BGE      |L1.1262|
;;;406    						}
;;;407    						// 读取从站信息SII_ID
;;;408    						for (slave = 1; slave <= *(context->slavecount); slave++)
0005b6  2501              MOVS     r5,#1
;;;409    						{
;;;410    							 context->slavelist[slave].eep_man = 
0005b8  f6446620          MOV      r6,#0x4e20
0005bc  e017              B        |L1.1518|
                  |L1.1470|
0005be  2301              MOVS     r3,#1                 ;387
0005c0  e7b7              B        |L1.1330|
                  |L1.1474|
0005c2  e30f              B        |L1.3044|
                  |L1.1476|
0005c4  4632              MOV      r2,r6
0005c6  4629              MOV      r1,r5
0005c8  4620              MOV      r0,r4
0005ca  f7fffffe          BL       ecx_readeeprom2
0005ce  eb0501c5          ADD      r1,r5,r5,LSL #3
0005d2  eb011385          ADD      r3,r1,r5,LSL #6
0005d6  2108              MOVS     r1,#8
0005d8  6862              LDR      r2,[r4,#4]
0005da  eb010183          ADD      r1,r1,r3,LSL #2
0005de  5050              STR      r0,[r2,r1]
;;;411    									etohl(ecx_readeeprom2(context, slave, EC_TIMEOUTEEP)); /* Manuf */
;;;412    							 ecx_readeeprom1(context, slave, ECT_SII_ID); /* ID */
0005e0  220a              MOVS     r2,#0xa
0005e2  4629              MOV      r1,r5
0005e4  4620              MOV      r0,r4
0005e6  f7fffffe          BL       ecx_readeeprom1
0005ea  1c6d              ADDS     r5,r5,#1
0005ec  b2ad              UXTH     r5,r5                 ;408
                  |L1.1518|
0005ee  68a0              LDR      r0,[r4,#8]            ;408
0005f0  6800              LDR      r0,[r0,#0]            ;408
0005f2  42a8              CMP      r0,r5                 ;408
0005f4  dae6              BGE      |L1.1476|
;;;413    						}
;;;414    						// 读取从站信息SII_REV
;;;415    						for (slave = 1; slave <= *(context->slavecount); slave++)
0005f6  2501              MOVS     r5,#1
0005f8  e014              B        |L1.1572|
                  |L1.1530|
;;;416    						{
;;;417    							 context->slavelist[slave].eep_id = 
0005fa  4632              MOV      r2,r6
0005fc  4629              MOV      r1,r5
0005fe  4620              MOV      r0,r4
000600  f7fffffe          BL       ecx_readeeprom2
000604  eb0501c5          ADD      r1,r5,r5,LSL #3
000608  eb011385          ADD      r3,r1,r5,LSL #6
00060c  210c              MOVS     r1,#0xc
00060e  6862              LDR      r2,[r4,#4]
000610  eb010183          ADD      r1,r1,r3,LSL #2
000614  5050              STR      r0,[r2,r1]
;;;418    									etohl(ecx_readeeprom2(context, slave, EC_TIMEOUTEEP)); /* ID */
;;;419    							 ecx_readeeprom1(context, slave, ECT_SII_REV); /* revision */
000616  220c              MOVS     r2,#0xc
000618  4629              MOV      r1,r5
00061a  4620              MOV      r0,r4
00061c  f7fffffe          BL       ecx_readeeprom1
000620  1c6d              ADDS     r5,r5,#1
000622  b2ad              UXTH     r5,r5                 ;415
                  |L1.1572|
000624  68a0              LDR      r0,[r4,#8]            ;415
000626  6800              LDR      r0,[r0,#0]            ;415
000628  42a8              CMP      r0,r5                 ;415
00062a  dae6              BGE      |L1.1530|
;;;420    						}
;;;421    						for (slave = 1; slave <= *(context->slavecount); slave++)
00062c  2501              MOVS     r5,#1
00062e  2710              MOVS     r7,#0x10              ;384
000630  e013              B        |L1.1626|
                  |L1.1586|
;;;422    						{
;;;423    							 context->slavelist[slave].eep_rev = 
000632  4632              MOV      r2,r6
000634  4629              MOV      r1,r5
000636  4620              MOV      r0,r4
000638  f7fffffe          BL       ecx_readeeprom2
00063c  eb0502c5          ADD      r2,r5,r5,LSL #3
000640  eb021285          ADD      r2,r2,r5,LSL #6
000644  6861              LDR      r1,[r4,#4]
000646  eb070282          ADD      r2,r7,r2,LSL #2
00064a  5088              STR      r0,[r1,r2]
;;;424    									etohl(ecx_readeeprom2(context, slave, EC_TIMEOUTEEP)); /* revision */
;;;425    							 ecx_readeeprom1(context, slave, ECT_SII_RXMBXADR); /* write mailbox address + mailboxsize */
00064c  2218              MOVS     r2,#0x18
00064e  4629              MOV      r1,r5
000650  4620              MOV      r0,r4
000652  f7fffffe          BL       ecx_readeeprom1
000656  1c6d              ADDS     r5,r5,#1
000658  b2ad              UXTH     r5,r5                 ;421
                  |L1.1626|
00065a  68a0              LDR      r0,[r4,#8]            ;421
00065c  6800              LDR      r0,[r0,#0]            ;421
00065e  42a8              CMP      r0,r5                 ;421
000660  dae7              BGE      |L1.1586|
;;;426    						}
;;;427    						for (slave = 1; slave <= *(context->slavecount); slave++)
000662  2501              MOVS     r5,#1
000664  e01d              B        |L1.1698|
                  |L1.1638|
;;;428    						{
;;;429    							 eedat = etohl(ecx_readeeprom2(context, slave, EC_TIMEOUTEEP)); /* write mailbox address and mailboxsize */
000666  f6446220          MOV      r2,#0x4e20
00066a  4629              MOV      r1,r5
00066c  4620              MOV      r0,r4
00066e  f7fffffe          BL       ecx_readeeprom2
;;;430    							 context->slavelist[slave].mbx_wo = (uint16)LO_WORD(eedat); /* write mailbox offset */
000672  eb0501c5          ADD      r1,r5,r5,LSL #3
000676  6863              LDR      r3,[r4,#4]
000678  eb011185          ADD      r1,r1,r5,LSL #6
00067c  22c2              MOVS     r2,#0xc2
00067e  eb020281          ADD      r2,r2,r1,LSL #2
000682  5298              STRH     r0,[r3,r2]
;;;431    							 context->slavelist[slave].mbx_l = (uint16)HI_WORD(eedat);  /* write mailbox length */
000684  6863              LDR      r3,[r4,#4]
000686  f04f02c0          MOV      r2,#0xc0
00068a  0c00              LSRS     r0,r0,#16
00068c  eb020181          ADD      r1,r2,r1,LSL #2
000690  5258              STRH     r0,[r3,r1]
;;;432    							 if (context->slavelist[slave].mbx_l > 0) 
000692  d004              BEQ      |L1.1694|
;;;433    							 {
;;;434    									ecx_readeeprom1(context, slave, ECT_SII_TXMBXADR); /* read mailbox offset */
000694  221a              MOVS     r2,#0x1a
000696  4629              MOV      r1,r5
000698  4620              MOV      r0,r4
00069a  f7fffffe          BL       ecx_readeeprom1
                  |L1.1694|
00069e  1c6d              ADDS     r5,r5,#1
0006a0  b2ad              UXTH     r5,r5                 ;427
                  |L1.1698|
0006a2  68a0              LDR      r0,[r4,#8]            ;427
0006a4  6800              LDR      r0,[r0,#0]            ;427
0006a6  42a8              CMP      r0,r5                 ;427
0006a8  dadd              BGE      |L1.1638|
;;;435    							 }
;;;436    						}
;;;437    						for (slave = 1; slave <= *(context->slavecount); slave++)
0006aa  f04f0801          MOV      r8,#1
0006ae  f04f0b02          MOV      r11,#2                ;397
0006b2  e291              B        |L1.3032|
                  |L1.1716|
;;;438    						{
;;;439    							 if (context->slavelist[slave].mbx_l > 0) 
0006b4  eb0002c0          ADD      r2,r0,r0,LSL #3
0006b8  6861              LDR      r1,[r4,#4]
0006ba  eb021588          ADD      r5,r2,r8,LSL #6
0006be  20c0              MOVS     r0,#0xc0
0006c0  eb000985          ADD      r9,r0,r5,LSL #2
0006c4  f8310009          LDRH     r0,[r1,r9]
0006c8  b1d8              CBZ      r0,|L1.1794|
;;;440    							 {
;;;441    									eedat = etohl(ecx_readeeprom2(context, slave, EC_TIMEOUTEEP)); /* read mailbox offset */
0006ca  f6446220          MOV      r2,#0x4e20
0006ce  4641              MOV      r1,r8
0006d0  4620              MOV      r0,r4
0006d2  f7fffffe          BL       ecx_readeeprom2
;;;442    									context->slavelist[slave].mbx_ro = (uint16)LO_WORD(eedat); /* read mailbox offset */
0006d6  6862              LDR      r2,[r4,#4]
0006d8  21c6              MOVS     r1,#0xc6
0006da  eb010185          ADD      r1,r1,r5,LSL #2
0006de  5250              STRH     r0,[r2,r1]
;;;443    									context->slavelist[slave].mbx_rl = (uint16)HI_WORD(eedat); /*read mailbox length */
0006e0  0c01              LSRS     r1,r0,#16
0006e2  6863              LDR      r3,[r4,#4]
0006e4  f04f00c4          MOV      r0,#0xc4
0006e8  eb000285          ADD      r2,r0,r5,LSL #2
0006ec  5299              STRH     r1,[r3,r2]
;;;444    									if (context->slavelist[slave].mbx_rl == 0)
0006ee  6860              LDR      r0,[r4,#4]
0006f0  d102              BNE      |L1.1784|
;;;445    									{
;;;446    										 context->slavelist[slave].mbx_rl = context->slavelist[slave].mbx_l;
0006f2  f8301009          LDRH     r1,[r0,r9]
0006f6  5281              STRH     r1,[r0,r2]
                  |L1.1784|
;;;447    									}
;;;448    									ecx_readeeprom1(context, slave, ECT_SII_MBXPROTO);
0006f8  221c              MOVS     r2,#0x1c
0006fa  4641              MOV      r1,r8
0006fc  4620              MOV      r0,r4
0006fe  f7fffffe          BL       ecx_readeeprom1
                  |L1.1794|
;;;449    							 }
;;;450    							 configadr = context->slavelist[slave].configadr;
000702  6861              LDR      r1,[r4,#4]
000704  2004              MOVS     r0,#4
000706  eb000085          ADD      r0,r0,r5,LSL #2
00070a  5a08              LDRH     r0,[r1,r0]
;;;451    							 if ((etohs(ecx_FPRDw(context->port, configadr, ECT_REG_ESCSUP, EC_TIMEOUTRET3)) & 0x04) > 0)  /* Support DC? */
00070c  9002              STR      r0,[sp,#8]
00070e  f2417370          MOV      r3,#0x1770
000712  2208              MOVS     r2,#8
000714  6820              LDR      r0,[r4,#0]
000716  9902              LDR      r1,[sp,#8]
000718  f7fffffe          BL       ecx_FPRDw
00071c  0740              LSLS     r0,r0,#29
00071e  d506              BPL      |L1.1838|
;;;452    							 {   
;;;453    									context->slavelist[slave].hasdc = TRUE;
000720  21cb              MOVS     r1,#0xcb
000722  6862              LDR      r2,[r4,#4]
000724  eb010185          ADD      r1,r1,r5,LSL #2
000728  f802a001          STRB     r10,[r2,r1]
00072c  e005              B        |L1.1850|
                  |L1.1838|
;;;454    							 }
;;;455    							 else
;;;456    							 {
;;;457    									context->slavelist[slave].hasdc = FALSE;
00072e  2000              MOVS     r0,#0
000730  21cb              MOVS     r1,#0xcb
000732  6862              LDR      r2,[r4,#4]
000734  eb010185          ADD      r1,r1,r5,LSL #2
000738  5450              STRB     r0,[r2,r1]
                  |L1.1850|
;;;458    							 }
;;;459    							 topology = etohs(ecx_FPRDw(context->port, configadr, ECT_REG_DLSTAT, EC_TIMEOUTRET3)); /* extract topology from DL status */
00073a  f2417370          MOV      r3,#0x1770
00073e  f44f7288          MOV      r2,#0x110
000742  6820              LDR      r0,[r4,#0]
000744  9902              LDR      r1,[sp,#8]
000746  f7fffffe          BL       ecx_FPRDw
;;;460    							 h = 0; 
00074a  2600              MOVS     r6,#0
;;;461    							 b = 0;
;;;462    							 if ((topology & 0x0300) == 0x0200) /* port0 open and communication established */
00074c  f3c02101          UBFX     r1,r0,#8,#2
000750  4637              MOV      r7,r6                 ;461
000752  2902              CMP      r1,#2
000754  d101              BNE      |L1.1882|
;;;463    							 {
;;;464    									h++;
000756  2601              MOVS     r6,#1
;;;465    									b |= 0x01;
000758  4637              MOV      r7,r6
                  |L1.1882|
;;;466    							 }
;;;467    							 if ((topology & 0x0c00) == 0x0800) /* port1 open and communication established */
00075a  f3c02181          UBFX     r1,r0,#10,#2
00075e  2902              CMP      r1,#2
000760  d102              BNE      |L1.1896|
;;;468    							 {
;;;469    									h++;
;;;470    									b |= 0x02;
000762  f0470702          ORR      r7,r7,#2
000766  1c76              ADDS     r6,r6,#1
                  |L1.1896|
;;;471    							 }
;;;472    							 if ((topology & 0x3000) == 0x2000) /* port2 open and communication established */
000768  f3c03101          UBFX     r1,r0,#12,#2
00076c  2902              CMP      r1,#2
00076e  d102              BNE      |L1.1910|
;;;473    							 {
;;;474    									h++;
;;;475    									b |= 0x04;
000770  f0470704          ORR      r7,r7,#4
000774  1c76              ADDS     r6,r6,#1
                  |L1.1910|
;;;476    							 }
;;;477    							 if ((topology & 0xc000) == 0x8000) /* port3 open and communication established */
000776  ebbb3f90          CMP      r11,r0,LSR #14
00077a  d102              BNE      |L1.1922|
;;;478    							 {
;;;479    									h++;
;;;480    									b |= 0x08;
00077c  f0470708          ORR      r7,r7,#8
000780  1c76              ADDS     r6,r6,#1
                  |L1.1922|
;;;481    							 }
;;;482    							 /* ptype = Physical type*/
;;;483    							 context->slavelist[slave].ptype = LO_BYTE(etohs(ecx_FPRDw(context->port, configadr, ECT_REG_PORTDES, EC_TIMEOUTRET3)));
000782  f2417370          MOV      r3,#0x1770
000786  2207              MOVS     r2,#7
000788  6820              LDR      r0,[r4,#0]
00078a  9902              LDR      r1,[sp,#8]
00078c  f7fffffe          BL       ecx_FPRDw
000790  22cc              MOVS     r2,#0xcc
000792  6861              LDR      r1,[r4,#4]
000794  eb020285          ADD      r2,r2,r5,LSL #2
;;;484    							 context->slavelist[slave].topology = h;
000798  f04f0ccd          MOV      r12,#0xcd
00079c  5488              STRB     r0,[r1,r2]            ;483
00079e  6860              LDR      r0,[r4,#4]
0007a0  eb0c0185          ADD      r1,r12,r5,LSL #2
0007a4  5446              STRB     r6,[r0,r1]
;;;485    							 context->slavelist[slave].activeports = b;
0007a6  20ce              MOVS     r0,#0xce
0007a8  6861              LDR      r1,[r4,#4]
0007aa  eb000085          ADD      r0,r0,r5,LSL #2
0007ae  540f              STRB     r7,[r1,r0]
;;;486    							 /* 0=no links, not possible             */
;;;487    							 /* 1=1 link  , end of line              */
;;;488    							 /* 2=2 links , one before and one after */
;;;489    							 /* 3=3 links , split point              */
;;;490    							 /* 4=4 links , cross point              */
;;;491    							 /* search for parent */
;;;492    							 context->slavelist[slave].parent = 0; /* parent is master */
0007b0  20d0              MOVS     r0,#0xd0
0007b2  6862              LDR      r2,[r4,#4]
0007b4  2100              MOVS     r1,#0
0007b6  eb000685          ADD      r6,r0,r5,LSL #2
0007ba  5391              STRH     r1,[r2,r6]
;;;493    							 if (slave > 1)
0007bc  f1b80f01          CMP      r8,#1
0007c0  d925              BLS      |L1.2062|
;;;494    							 {
;;;495    									topoc = 0; 
;;;496    									slavec = slave - 1;
0007c2  f1a80101          SUB      r1,r8,#1
0007c6  2000              MOVS     r0,#0                 ;495
0007c8  b209              SXTH     r1,r1
                  |L1.1994|
;;;497    									do
;;;498    									{
;;;499    										 topology = context->slavelist[slavec].topology;
0007ca  eb0102c1          ADD      r2,r1,r1,LSL #3
0007ce  eb021281          ADD      r2,r2,r1,LSL #6
0007d2  6863              LDR      r3,[r4,#4]
0007d4  eb0c0282          ADD      r2,r12,r2,LSL #2
0007d8  5c9a              LDRB     r2,[r3,r2]
;;;500    										 if (topology == 1)
0007da  2a01              CMP      r2,#1
0007dc  d004              BEQ      |L1.2024|
;;;501    										 {
;;;502    												topoc--; /* endpoint found */
;;;503    										 }
;;;504    										 if (topology == 3)
0007de  2a03              CMP      r2,#3
0007e0  d004              BEQ      |L1.2028|
;;;505    										 {
;;;506    												topoc++; /* split found */
;;;507    										 }
;;;508    										 if (topology == 4)
0007e2  2a04              CMP      r2,#4
0007e4  d00b              BEQ      |L1.2046|
0007e6  e003              B        |L1.2032|
                  |L1.2024|
0007e8  1e40              SUBS     r0,r0,#1
0007ea  e000              B        |L1.2030|
                  |L1.2028|
0007ec  1c40              ADDS     r0,r0,#1              ;502
                  |L1.2030|
0007ee  b200              SXTH     r0,r0                 ;502
                  |L1.2032|
;;;509    										 {
;;;510    												topoc += 2; /* cross found */
;;;511    										 }
;;;512    										 if (((topoc >= 0) && (topology > 1)) || (slavec == 1)) /* parent found */
0007f0  2800              CMP      r0,#0
0007f2  db01              BLT      |L1.2040|
0007f4  2a01              CMP      r2,#1
0007f6  d804              BHI      |L1.2050|
                  |L1.2040|
0007f8  2901              CMP      r1,#1
0007fa  d002              BEQ      |L1.2050|
0007fc  e003              B        |L1.2054|
                  |L1.2046|
0007fe  1c80              ADDS     r0,r0,#2
000800  e7f5              B        |L1.2030|
                  |L1.2050|
;;;513    										 {
;;;514    												context->slavelist[slave].parent = slavec;
000802  5399              STRH     r1,[r3,r6]
;;;515    												slavec = 1;
000804  2101              MOVS     r1,#1
                  |L1.2054|
000806  1e49              SUBS     r1,r1,#1
;;;516    										 }
;;;517    										 slavec--;
000808  b209              SXTH     r1,r1
;;;518    									}
;;;519    									while (slavec > 0);
00080a  2900              CMP      r1,#0
00080c  dcdd              BGT      |L1.1994|
                  |L1.2062|
;;;520    							 }
;;;521    							 (void)ecx_statecheck(context, slave, EC_STATE_INIT,  EC_TIMEOUTSTATE); //* check state change Init */
00080e  4b30              LDR      r3,|L1.2256|
000810  2201              MOVS     r2,#1
000812  4641              MOV      r1,r8
000814  4620              MOV      r0,r4
000816  f7fffffe          BL       ecx_statecheck
;;;522    				 
;;;523    							 /* set default mailbox configuration if slave has mailbox */
;;;524    							 if (context->slavelist[slave].mbx_l>0)
00081a  6860              LDR      r0,[r4,#4]
00081c  f8301009          LDRH     r1,[r0,r9]
000820  b3f1              CBZ      r1,|L1.2208|
;;;525    							 {   
;;;526    									context->slavelist[slave].SMtype[0] = 1;
000822  2274              MOVS     r2,#0x74
000824  eb020285          ADD      r2,r2,r5,LSL #2
;;;527    									context->slavelist[slave].SMtype[1] = 2;
;;;528    									context->slavelist[slave].SMtype[2] = 3;
000828  2176              MOVS     r1,#0x76
00082a  f800a002          STRB     r10,[r0,r2]           ;526
00082e  2075              MOVS     r0,#0x75              ;527
000830  6862              LDR      r2,[r4,#4]            ;527
000832  eb000085          ADD      r0,r0,r5,LSL #2       ;527
000836  eb010185          ADD      r1,r1,r5,LSL #2
00083a  f802b000          STRB     r11,[r2,r0]           ;527
00083e  6860              LDR      r0,[r4,#4]
000840  2203              MOVS     r2,#3
000842  5442              STRB     r2,[r0,r1]
;;;529    									context->slavelist[slave].SMtype[3] = 4;
000844  2277              MOVS     r2,#0x77
000846  6861              LDR      r1,[r4,#4]
000848  eb020285          ADD      r2,r2,r5,LSL #2
00084c  2004              MOVS     r0,#4
00084e  5488              STRB     r0,[r1,r2]
;;;530    									context->slavelist[slave].SM[0].StartAddr = htoes(context->slavelist[slave].mbx_wo);
000850  6860              LDR      r0,[r4,#4]
000852  21c2              MOVS     r1,#0xc2
000854  eb010185          ADD      r1,r1,r5,LSL #2
000858  5a42              LDRH     r2,[r0,r1]
00085a  2134              MOVS     r1,#0x34
00085c  eb010185          ADD      r1,r1,r5,LSL #2
000860  5242              STRH     r2,[r0,r1]
;;;531    									context->slavelist[slave].SM[0].SMlength = htoes(context->slavelist[slave].mbx_l);
000862  6860              LDR      r0,[r4,#4]
000864  2136              MOVS     r1,#0x36
000866  eb010185          ADD      r1,r1,r5,LSL #2
00086a  f8302009          LDRH     r2,[r0,r9]
00086e  5242              STRH     r2,[r0,r1]
;;;532    									context->slavelist[slave].SM[0].SMflags = htoel(EC_DEFAULTMBXSM0);
000870  2138              MOVS     r1,#0x38
000872  6862              LDR      r2,[r4,#4]
000874  eb010185          ADD      r1,r1,r5,LSL #2
000878  4816              LDR      r0,|L1.2260|
00087a  5050              STR      r0,[r2,r1]
;;;533    									context->slavelist[slave].SM[1].StartAddr = htoes(context->slavelist[slave].mbx_ro);
00087c  6860              LDR      r0,[r4,#4]
00087e  21c6              MOVS     r1,#0xc6
000880  eb010185          ADD      r1,r1,r5,LSL #2
000884  5a42              LDRH     r2,[r0,r1]
000886  213c              MOVS     r1,#0x3c
000888  eb010185          ADD      r1,r1,r5,LSL #2
00088c  5242              STRH     r2,[r0,r1]
;;;534    									context->slavelist[slave].SM[1].SMlength = htoes(context->slavelist[slave].mbx_rl);
00088e  6860              LDR      r0,[r4,#4]
000890  21c4              MOVS     r1,#0xc4
000892  eb010185          ADD      r1,r1,r5,LSL #2
000896  5a42              LDRH     r2,[r0,r1]
000898  213e              MOVS     r1,#0x3e
00089a  eb010185          ADD      r1,r1,r5,LSL #2
00089e  e000              B        |L1.2210|
                  |L1.2208|
0008a0  e025              B        |L1.2286|
                  |L1.2210|
0008a2  5242              STRH     r2,[r0,r1]
;;;535    									context->slavelist[slave].SM[1].SMflags = htoel(EC_DEFAULTMBXSM1);
0008a4  480b              LDR      r0,|L1.2260|
0008a6  6862              LDR      r2,[r4,#4]
0008a8  1f00              SUBS     r0,r0,#4
0008aa  2140              MOVS     r1,#0x40
0008ac  eb010185          ADD      r1,r1,r5,LSL #2
0008b0  5050              STR      r0,[r2,r1]
;;;536    									context->slavelist[slave].mbx_proto = ecx_readeeprom2(context, slave, EC_TIMEOUTEEP);
0008b2  e011              B        |L1.2264|
                  |L1.2228|
0008b4  436f7079          DCB      "Copy SII slave %d from %d.\n",0
0008b8  20534949
0008bc  20736c61
0008c0  76652025
0008c4  64206672
0008c8  6f6d2025
0008cc  642e0a00
                  |L1.2256|
                          DCD      0x001e8480
                  |L1.2260|
                          DCD      0x00010026
                  |L1.2264|
0008d8  f6446220          MOV      r2,#0x4e20
0008dc  4641              MOV      r1,r8
0008de  4620              MOV      r0,r4
0008e0  f7fffffe          BL       ecx_readeeprom2
0008e4  6862              LDR      r2,[r4,#4]
0008e6  21c8              MOVS     r1,#0xc8
0008e8  eb010185          ADD      r1,r1,r5,LSL #2
0008ec  5250              STRH     r0,[r2,r1]
                  |L1.2286|
;;;537    							 }   
;;;538    							 cindex = 0;
;;;539    							 /* use configuration table ? */
;;;540    							 if (usetable == 1)
0008ee  9808              LDR      r0,[sp,#0x20]
0008f0  2801              CMP      r0,#1
0008f2  d105              BNE      |L1.2304|
;;;541    							 {
;;;542    									cindex = ecx_config_from_table(context, slave);
0008f4  4641              MOV      r1,r8
0008f6  4620              MOV      r0,r4
0008f8  f7fffffe          BL       ecx_config_from_table
;;;543    							 }
;;;544    							 /* slave not in configuration table, find out via SII */
;;;545    							 if (!cindex && !ecx_lookup_prev_sii(context, slave))
0008fc  2800              CMP      r0,#0
                  |L1.2302|
0008fe  d17c              BNE      |L1.2554|
                  |L1.2304|
000900  4641              MOV      r1,r8
000902  4620              MOV      r0,r4
000904  f7fffffe          BL       ecx_lookup_prev_sii
000908  2800              CMP      r0,#0
00090a  d1f8              BNE      |L1.2302|
;;;546    							 {
;;;547    									ssigen = ecx_siifind(context, slave, ECT_SII_GENERAL);
00090c  221e              MOVS     r2,#0x1e
00090e  4641              MOV      r1,r8
000910  4620              MOV      r0,r4
000912  f7fffffe          BL       ecx_siifind
000916  0406              LSLS     r6,r0,#16
000918  0c36              LSRS     r6,r6,#16
;;;548    									/* SII general section */
;;;549    									if (ssigen)
00091a  d064              BEQ      |L1.2534|
;;;550    									{
;;;551    										 context->slavelist[slave].CoEdetails = ecx_siigetbyte(context, slave, ssigen + 0x07);
00091c  1df0              ADDS     r0,r6,#7
00091e  b282              UXTH     r2,r0
000920  4641              MOV      r1,r8
000922  4620              MOV      r0,r4
000924  f7fffffe          BL       ecx_siigetbyte
000928  21fc              MOVS     r1,#0xfc
00092a  6862              LDR      r2,[r4,#4]
00092c  eb010185          ADD      r1,r1,r5,LSL #2
000930  5450              STRB     r0,[r2,r1]
;;;552    										 context->slavelist[slave].FoEdetails = ecx_siigetbyte(context, slave, ssigen + 0x08);
000932  f1060008          ADD      r0,r6,#8
000936  b282              UXTH     r2,r0
000938  4641              MOV      r1,r8
00093a  4620              MOV      r0,r4
00093c  f7fffffe          BL       ecx_siigetbyte
000940  21fd              MOVS     r1,#0xfd
000942  6862              LDR      r2,[r4,#4]
000944  eb010185          ADD      r1,r1,r5,LSL #2
000948  5450              STRB     r0,[r2,r1]
;;;553    										 context->slavelist[slave].EoEdetails = ecx_siigetbyte(context, slave, ssigen + 0x09);
00094a  f1060009          ADD      r0,r6,#9
00094e  b282              UXTH     r2,r0
000950  4641              MOV      r1,r8
000952  4620              MOV      r0,r4
000954  f7fffffe          BL       ecx_siigetbyte
000958  21fe              MOVS     r1,#0xfe
00095a  6862              LDR      r2,[r4,#4]
00095c  eb010185          ADD      r1,r1,r5,LSL #2
000960  5450              STRB     r0,[r2,r1]
;;;554    										 context->slavelist[slave].SoEdetails = ecx_siigetbyte(context, slave, ssigen + 0x0a);
000962  f106000a          ADD      r0,r6,#0xa
000966  b282              UXTH     r2,r0
000968  4641              MOV      r1,r8
00096a  4620              MOV      r0,r4
00096c  f7fffffe          BL       ecx_siigetbyte
000970  21ff              MOVS     r1,#0xff
000972  6862              LDR      r2,[r4,#4]
000974  eb010185          ADD      r1,r1,r5,LSL #2
000978  5450              STRB     r0,[r2,r1]
;;;555    										 if((ecx_siigetbyte(context, slave, ssigen + 0x0d) & 0x02) > 0)
00097a  f106000d          ADD      r0,r6,#0xd
00097e  b282              UXTH     r2,r0
000980  4641              MOV      r1,r8
000982  4620              MOV      r0,r4
000984  f7fffffe          BL       ecx_siigetbyte
000988  0780              LSLS     r0,r0,#30
00098a  d50c              BPL      |L1.2470|
;;;556    										 {
;;;557    												context->slavelist[slave].blockLRW = 1;
00098c  f44f7181          MOV      r1,#0x102
000990  6862              LDR      r2,[r4,#4]
000992  eb010185          ADD      r1,r1,r5,LSL #2
000996  f802a001          STRB     r10,[r2,r1]
;;;558    												context->slavelist[0].blockLRW++;                  
00099a  6860              LDR      r0,[r4,#4]
00099c  f8901102          LDRB     r1,[r0,#0x102]
0009a0  1c49              ADDS     r1,r1,#1
0009a2  f8801102          STRB     r1,[r0,#0x102]
                  |L1.2470|
;;;559    										 }   
;;;560    										 context->slavelist[slave].Ebuscurrent = ecx_siigetbyte(context, slave, ssigen + 0x0e);
0009a6  f106000e          ADD      r0,r6,#0xe
0009aa  b282              UXTH     r2,r0
0009ac  4641              MOV      r1,r8
0009ae  4620              MOV      r0,r4
0009b0  f7fffffe          BL       ecx_siigetbyte
0009b4  4601              MOV      r1,r0
0009b6  f44f7080          MOV      r0,#0x100
0009ba  6862              LDR      r2,[r4,#4]
0009bc  eb000785          ADD      r7,r0,r5,LSL #2
0009c0  360f              ADDS     r6,r6,#0xf
0009c2  53d1              STRH     r1,[r2,r7]
;;;561    										 context->slavelist[slave].Ebuscurrent += ecx_siigetbyte(context, slave, ssigen + 0x0f) << 8;
0009c4  b2b2              UXTH     r2,r6
0009c6  4641              MOV      r1,r8
0009c8  4620              MOV      r0,r4
0009ca  f7fffffe          BL       ecx_siigetbyte
0009ce  4601              MOV      r1,r0
0009d0  6860              LDR      r0,[r4,#4]
0009d2  5bc2              LDRH     r2,[r0,r7]
0009d4  eb022101          ADD      r1,r2,r1,LSL #8
0009d8  53c1              STRH     r1,[r0,r7]
;;;562    										 context->slavelist[0].Ebuscurrent += context->slavelist[slave].Ebuscurrent;
0009da  6860              LDR      r0,[r4,#4]
0009dc  f8b02100          LDRH     r2,[r0,#0x100]
0009e0  4411              ADD      r1,r1,r2
0009e2  f8a01100          STRH     r1,[r0,#0x100]
                  |L1.2534|
;;;563    									}
;;;564    									/* SII strings section */
;;;565    									if (ecx_siifind(context, slave, ECT_SII_STRING) > 0)
0009e6  220a              MOVS     r2,#0xa
0009e8  4641              MOV      r1,r8
0009ea  4620              MOV      r0,r4
0009ec  f7fffffe          BL       ecx_siifind
0009f0  2800              CMP      r0,#0
0009f2  dd0d              BLE      |L1.2576|
;;;566    									{
;;;567    										 ecx_siistring(context, context->slavelist[slave].name, slave, 1);
0009f4  f44f7086          MOV      r0,#0x10c
0009f8  e000              B        |L1.2556|
                  |L1.2554|
0009fa  e08e              B        |L1.2842|
                  |L1.2556|
0009fc  6861              LDR      r1,[r4,#4]
0009fe  eb000085          ADD      r0,r0,r5,LSL #2
000a02  4401              ADD      r1,r1,r0
000a04  2301              MOVS     r3,#1
000a06  4642              MOV      r2,r8
000a08  4620              MOV      r0,r4
000a0a  f7fffffe          BL       ecx_siistring
000a0e  e010              B        |L1.2610|
                  |L1.2576|
;;;568    									}
;;;569    									/* no name for slave found, use constructed name */
;;;570    									else
;;;571    									{
;;;572    										 sprintf(context->slavelist[slave].name, "? M:%8.8x I:%8.8x",
000a10  210c              MOVS     r1,#0xc
000a12  6860              LDR      r0,[r4,#4]
000a14  eb010185          ADD      r1,r1,r5,LSL #2
000a18  5843              LDR      r3,[r0,r1]
000a1a  2108              MOVS     r1,#8
000a1c  eb010185          ADD      r1,r1,r5,LSL #2
000a20  5842              LDR      r2,[r0,r1]
000a22  f44f7186          MOV      r1,#0x10c
000a26  eb010185          ADD      r1,r1,r5,LSL #2
000a2a  4408              ADD      r0,r0,r1
000a2c  a1fc              ADR      r1,|L1.3616|
000a2e  f7fffffe          BL       __2sprintf
                  |L1.2610|
;;;573    														 (unsigned int)context->slavelist[slave].eep_man, 
;;;574    														 (unsigned int)context->slavelist[slave].eep_id);
;;;575    									}
;;;576    									/* SII SM section */
;;;577    									nSM = ecx_siiSM(context, slave, context->eepSM);
000a32  4641              MOV      r1,r8
000a34  4620              MOV      r0,r4
000a36  6c62              LDR      r2,[r4,#0x44]
000a38  f7fffffe          BL       ecx_siiSM
;;;578    									if (nSM>0)
000a3c  2800              CMP      r0,#0
000a3e  dd42              BLE      |L1.2758|
;;;579    									{   
;;;580    										 context->slavelist[slave].SM[0].StartAddr = htoes(context->eepSM->PhStart);
000a40  6c60              LDR      r0,[r4,#0x44]
000a42  6861              LDR      r1,[r4,#4]
;;;581    										 context->slavelist[slave].SM[0].SMlength = htoes(context->eepSM->Plength);
000a44  2736              MOVS     r7,#0x36
000a46  8882              LDRH     r2,[r0,#4]            ;580
000a48  2034              MOVS     r0,#0x34              ;580
000a4a  eb000085          ADD      r0,r0,r5,LSL #2       ;580
000a4e  520a              STRH     r2,[r1,r0]            ;580
000a50  6c60              LDR      r0,[r4,#0x44]
000a52  6861              LDR      r1,[r4,#4]
000a54  eb070285          ADD      r2,r7,r5,LSL #2
000a58  88c0              LDRH     r0,[r0,#6]
000a5a  5288              STRH     r0,[r1,r2]
;;;582    										 context->slavelist[slave].SM[0].SMflags = 
000a5c  6c60              LDR      r0,[r4,#0x44]
000a5e  6862              LDR      r2,[r4,#4]
000a60  7a01              LDRB     r1,[r0,#8]
000a62  7a80              LDRB     r0,[r0,#0xa]
000a64  eb014100          ADD      r1,r1,r0,LSL #16
000a68  2038              MOVS     r0,#0x38
000a6a  eb000085          ADD      r0,r0,r5,LSL #2
;;;583    												htoel((context->eepSM->Creg) + (context->eepSM->Activate << 16));
;;;584    										 SMc = 1;
000a6e  2601              MOVS     r6,#1
000a70  5011              STR      r1,[r2,r0]            ;582
;;;585    										 while ((SMc < EC_MAXSM) &&  ecx_siiSMnext(context, slave, context->eepSM, SMc))
000a72  e020              B        |L1.2742|
                  |L1.2676|
;;;586    										 {
;;;587    												context->slavelist[slave].SM[SMc].StartAddr = htoes(context->eepSM->PhStart);
000a74  6c60              LDR      r0,[r4,#0x44]
000a76  8881              LDRH     r1,[r0,#4]
000a78  6860              LDR      r0,[r4,#4]
000a7a  eb000285          ADD      r2,r0,r5,LSL #2
000a7e  2034              MOVS     r0,#0x34
000a80  eb0000c6          ADD      r0,r0,r6,LSL #3
000a84  5211              STRH     r1,[r2,r0]
;;;588    												context->slavelist[slave].SM[SMc].SMlength = htoes(context->eepSM->Plength);
000a86  6c60              LDR      r0,[r4,#0x44]
000a88  6861              LDR      r1,[r4,#4]
000a8a  eb0702c6          ADD      r2,r7,r6,LSL #3
000a8e  eb010185          ADD      r1,r1,r5,LSL #2
000a92  88c0              LDRH     r0,[r0,#6]
000a94  5288              STRH     r0,[r1,r2]
;;;589    												context->slavelist[slave].SM[SMc].SMflags = 
000a96  6c60              LDR      r0,[r4,#0x44]
000a98  7a01              LDRB     r1,[r0,#8]
000a9a  7a80              LDRB     r0,[r0,#0xa]
000a9c  eb014100          ADD      r1,r1,r0,LSL #16
000aa0  6860              LDR      r0,[r4,#4]
000aa2  eb000285          ADD      r2,r0,r5,LSL #2
000aa6  2038              MOVS     r0,#0x38
000aa8  eb0000c6          ADD      r0,r0,r6,LSL #3
000aac  1c76              ADDS     r6,r6,#1
;;;590    													 htoel((context->eepSM->Creg) + (context->eepSM->Activate << 16));
;;;591    												SMc++;
000aae  b2f6              UXTB     r6,r6
000ab0  5011              STR      r1,[r2,r0]            ;589
000ab2  2e08              CMP      r6,#8                 ;585
000ab4  d207              BCS      |L1.2758|
                  |L1.2742|
000ab6  4633              MOV      r3,r6                 ;585
000ab8  4641              MOV      r1,r8                 ;585
000aba  4620              MOV      r0,r4                 ;585
000abc  6c62              LDR      r2,[r4,#0x44]         ;585
000abe  f7fffffe          BL       ecx_siiSMnext
000ac2  2800              CMP      r0,#0                 ;585
000ac4  d1d6              BNE      |L1.2676|
                  |L1.2758|
;;;592    										 }   
;;;593    									}   
;;;594    									/* SII FMMU section */
;;;595    									if (ecx_siiFMMU(context, slave, context->eepFMMU))
000ac6  4641              MOV      r1,r8
000ac8  4620              MOV      r0,r4
000aca  6ca2              LDR      r2,[r4,#0x48]
000acc  f7fffffe          BL       ecx_siiFMMU
000ad0  b318              CBZ      r0,|L1.2842|
;;;596    									{
;;;597    										 if (context->eepFMMU->FMMU0 !=0xff) 
000ad2  6ca0              LDR      r0,[r4,#0x48]
000ad4  78c0              LDRB     r0,[r0,#3]
000ad6  28ff              CMP      r0,#0xff
000ad8  d004              BEQ      |L1.2788|
;;;598    										 {
;;;599    												context->slavelist[slave].FMMU0func = context->eepFMMU->FMMU0;
000ada  22bc              MOVS     r2,#0xbc
000adc  6861              LDR      r1,[r4,#4]
000ade  eb020285          ADD      r2,r2,r5,LSL #2
000ae2  5488              STRB     r0,[r1,r2]
                  |L1.2788|
;;;600    										 }
;;;601    										 if (context->eepFMMU->FMMU1 !=0xff) 
000ae4  6ca0              LDR      r0,[r4,#0x48]
000ae6  7900              LDRB     r0,[r0,#4]
000ae8  28ff              CMP      r0,#0xff
000aea  d004              BEQ      |L1.2806|
;;;602    										 {
;;;603    												context->slavelist[slave].FMMU1func = context->eepFMMU->FMMU1;
000aec  21bd              MOVS     r1,#0xbd
000aee  6862              LDR      r2,[r4,#4]
000af0  eb010185          ADD      r1,r1,r5,LSL #2
000af4  5450              STRB     r0,[r2,r1]
                  |L1.2806|
;;;604    										 }
;;;605    										 if (context->eepFMMU->FMMU2 !=0xff) 
000af6  6ca0              LDR      r0,[r4,#0x48]
000af8  7940              LDRB     r0,[r0,#5]
000afa  28ff              CMP      r0,#0xff
000afc  d004              BEQ      |L1.2824|
;;;606    										 {
;;;607    												context->slavelist[slave].FMMU2func = context->eepFMMU->FMMU2;
000afe  21be              MOVS     r1,#0xbe
000b00  6862              LDR      r2,[r4,#4]
000b02  eb010185          ADD      r1,r1,r5,LSL #2
000b06  5450              STRB     r0,[r2,r1]
                  |L1.2824|
;;;608    										 }
;;;609    										 if (context->eepFMMU->FMMU3 !=0xff) 
000b08  6ca0              LDR      r0,[r4,#0x48]
000b0a  7980              LDRB     r0,[r0,#6]
000b0c  28ff              CMP      r0,#0xff
000b0e  d004              BEQ      |L1.2842|
;;;610    										 {
;;;611    												context->slavelist[slave].FMMU3func = context->eepFMMU->FMMU3;
000b10  21bf              MOVS     r1,#0xbf
000b12  6862              LDR      r2,[r4,#4]
000b14  eb010185          ADD      r1,r1,r5,LSL #2
000b18  5450              STRB     r0,[r2,r1]
                  |L1.2842|
;;;612    										 }
;;;613    									}            
;;;614    							 }   
;;;615    
;;;616    							 if (context->slavelist[slave].mbx_l > 0)
000b1a  6861              LDR      r1,[r4,#4]
000b1c  f8310009          LDRH     r0,[r1,r9]
000b20  b3f0              CBZ      r0,|L1.2976|
;;;617    							 {
;;;618    									if (context->slavelist[slave].SM[0].StartAddr == 0x0000) /* should never happen */
000b22  2034              MOVS     r0,#0x34
000b24  eb000085          ADD      r0,r0,r5,LSL #2
000b28  5a0a              LDRH     r2,[r1,r0]
000b2a  b9a2              CBNZ     r2,|L1.2902|
;;;619    									{
;;;620    										 context->slavelist[slave].SM[0].StartAddr = htoes(0x1000);
000b2c  f44f5280          MOV      r2,#0x1000
000b30  520a              STRH     r2,[r1,r0]
;;;621    										 context->slavelist[slave].SM[0].SMlength = htoes(0x0080);
000b32  6863              LDR      r3,[r4,#4]
000b34  2136              MOVS     r1,#0x36
000b36  2280              MOVS     r2,#0x80
000b38  eb010185          ADD      r1,r1,r5,LSL #2
000b3c  525a              STRH     r2,[r3,r1]
;;;622    										 context->slavelist[slave].SM[0].SMflags = htoel(EC_DEFAULTMBXSM0);
000b3e  2138              MOVS     r1,#0x38
000b40  6863              LDR      r3,[r4,#4]
000b42  eb010185          ADD      r1,r1,r5,LSL #2
000b46  4abb              LDR      r2,|L1.3636|
000b48  505a              STR      r2,[r3,r1]
;;;623    										 context->slavelist[slave].SMtype[0] = 1;               
000b4a  2174              MOVS     r1,#0x74
000b4c  6863              LDR      r3,[r4,#4]
000b4e  eb010185          ADD      r1,r1,r5,LSL #2
000b52  f803a001          STRB     r10,[r3,r1]
                  |L1.2902|
;;;624    									}         
;;;625    									if (context->slavelist[slave].SM[1].StartAddr == 0x0000) /* should never happen */
000b56  6861              LDR      r1,[r4,#4]
000b58  223c              MOVS     r2,#0x3c
000b5a  eb020285          ADD      r2,r2,r5,LSL #2
000b5e  5a8b              LDRH     r3,[r1,r2]
000b60  b9ab              CBNZ     r3,|L1.2958|
;;;626    									{
;;;627    										 context->slavelist[slave].SM[1].StartAddr = htoes(0x1080);
000b62  f44f5384          MOV      r3,#0x1080
000b66  528b              STRH     r3,[r1,r2]
;;;628    										 context->slavelist[slave].SM[1].SMlength = htoes(0x0080);
000b68  6863              LDR      r3,[r4,#4]
000b6a  213e              MOVS     r1,#0x3e
000b6c  2280              MOVS     r2,#0x80
000b6e  eb010185          ADD      r1,r1,r5,LSL #2
000b72  525a              STRH     r2,[r3,r1]
;;;629    										 context->slavelist[slave].SM[1].SMflags = htoel(EC_DEFAULTMBXSM1);
000b74  49af              LDR      r1,|L1.3636|
000b76  2240              MOVS     r2,#0x40
000b78  6863              LDR      r3,[r4,#4]
000b7a  eb020285          ADD      r2,r2,r5,LSL #2
000b7e  1f09              SUBS     r1,r1,#4
000b80  5099              STR      r1,[r3,r2]
;;;630    										 context->slavelist[slave].SMtype[1] = 2;
000b82  2275              MOVS     r2,#0x75
000b84  6863              LDR      r3,[r4,#4]
000b86  eb020285          ADD      r2,r2,r5,LSL #2
000b8a  f803b002          STRB     r11,[r3,r2]
                  |L1.2958|
;;;631    									}         
;;;632    									/* program SM0 mailbox in and SM1 mailbox out for slave */
;;;633    									/* writing both SM in one datagram will solve timing issue in old NETX */
;;;634    									ecx_FPWR(context->port, configadr, ECT_REG_SM0, sizeof(ec_smt) * 2, &(context->slavelist[slave].SM[0]), EC_TIMEOUTRET3);
000b8e  6862              LDR      r2,[r4,#4]
000b90  f2417170          MOV      r1,#0x1770
000b94  4410              ADD      r0,r0,r2
000b96  2310              MOVS     r3,#0x10
000b98  e9cd0100          STRD     r0,r1,[sp,#0]
000b9c  01da              LSLS     r2,r3,#7
000b9e  e000              B        |L1.2978|
                  |L1.2976|
000ba0  e003              B        |L1.2986|
                  |L1.2978|
000ba2  6820              LDR      r0,[r4,#0]
000ba4  9902              LDR      r1,[sp,#8]
000ba6  f7fffffe          BL       ecx_FPWR
                  |L1.2986|
;;;635    							 } 
;;;636    							 /* some slaves need eeprom available to PDI in init->preop transition */
;;;637    							 ecx_eeprom2pdi(context, slave);
000baa  4641              MOV      r1,r8
000bac  4620              MOV      r0,r4
000bae  f7fffffe          BL       ecx_eeprom2pdi
;;;638    							 /* request pre_op for slave */
;;;639    							 ecx_FPWRw(context->port, configadr, ECT_REG_ALCTL, htoes(EC_STATE_PRE_OP | EC_STATE_ACK) , EC_TIMEOUTRET3); /* set preop status */
000bb2  f2417070          MOV      r0,#0x1770
000bb6  9000              STR      r0,[sp,#0]
000bb8  2312              MOVS     r3,#0x12
000bba  011a              LSLS     r2,r3,#4
000bbc  6820              LDR      r0,[r4,#0]
000bbe  9902              LDR      r1,[sp,#8]
000bc0  f7fffffe          BL       ecx_FPWRw
;;;640    						   ecx_statecheck(context, slave, EC_STATE_PRE_OP, EC_TIMEOUTSTATE);
000bc4  4b9c              LDR      r3,|L1.3640|
000bc6  2202              MOVS     r2,#2
000bc8  4641              MOV      r1,r8
000bca  4620              MOV      r0,r4
000bcc  f7fffffe          BL       ecx_statecheck
000bd0  f1080001          ADD      r0,r8,#1              ;437
000bd4  fa1ff880          UXTH     r8,r0                 ;437
                  |L1.3032|
000bd8  68a0              LDR      r0,[r4,#8]            ;437
000bda  6801              LDR      r1,[r0,#0]            ;437
000bdc  4640              MOV      r0,r8                 ;437
000bde  4541              CMP      r1,r8                 ;437
000be0  f6bfad68          BGE      |L1.1716|
                  |L1.3044|
;;;641    						}	
;;;642    		 }
;;;643       return wkc;
000be4  9803              LDR      r0,[sp,#0xc]
;;;644    }
000be6  b009              ADD      sp,sp,#0x24
                  |L1.3048|
000be8  e8bd8ff0          POP      {r4-r11,pc}
;;;645    
                          ENDP

                  ecx_lookup_mapping PROC
;;;648     */
;;;649    static int ecx_lookup_mapping(ecx_contextt *context, uint16 slave, int *Osize, int *Isize)
000bec  e92d47f0          PUSH     {r4-r10,lr}
;;;650    {
000bf0  469a              MOV      r10,r3
000bf2  4691              MOV      r9,r2
;;;651       int i, nSM;
;;;652       if ((slave > 1) && (*(context->slavecount) > 0))
000bf4  2901              CMP      r1,#1
000bf6  d96c              BLS      |L1.3282|
000bf8  6882              LDR      r2,[r0,#8]
000bfa  6812              LDR      r2,[r2,#0]
000bfc  2a00              CMP      r2,#0
000bfe  dd68              BLE      |L1.3282|
;;;653       {
;;;654          i = 1;
;;;655          while(((context->slavelist[i].eep_man != context->slavelist[slave].eep_man) ||
000c00  eb0103c1          ADD      r3,r1,r1,LSL #3
000c04  eb031381          ADD      r3,r3,r1,LSL #6
000c08  f04f0808          MOV      r8,#8
000c0c  6845              LDR      r5,[r0,#4]
000c0e  eb080483          ADD      r4,r8,r3,LSL #2
000c12  2201              MOVS     r2,#1                 ;654
000c14  f855c004          LDR      r12,[r5,r4]
000c18  e000              B        |L1.3100|
                  |L1.3098|
000c1a  1c52              ADDS     r2,r2,#1
                  |L1.3100|
000c1c  eb0204c2          ADD      r4,r2,r2,LSL #3
000c20  eb041482          ADD      r4,r4,r2,LSL #6
000c24  eb080684          ADD      r6,r8,r4,LSL #2
000c28  59ae              LDR      r6,[r5,r6]
000c2a  4566              CMP      r6,r12
000c2c  d111              BNE      |L1.3154|
;;;656                 (context->slavelist[i].eep_id  != context->slavelist[slave].eep_id ) ||
000c2e  260c              MOVS     r6,#0xc
000c30  eb060784          ADD      r7,r6,r4,LSL #2
000c34  eb060683          ADD      r6,r6,r3,LSL #2
000c38  59ef              LDR      r7,[r5,r7]
000c3a  59ae              LDR      r6,[r5,r6]
000c3c  42b7              CMP      r7,r6
000c3e  d108              BNE      |L1.3154|
;;;657                 (context->slavelist[i].eep_rev != context->slavelist[slave].eep_rev)) &&
000c40  2610              MOVS     r6,#0x10
000c42  eb060784          ADD      r7,r6,r4,LSL #2
000c46  eb060683          ADD      r6,r6,r3,LSL #2
000c4a  59ef              LDR      r7,[r5,r7]
000c4c  59ae              LDR      r6,[r5,r6]
000c4e  42b7              CMP      r7,r6
000c50  d001              BEQ      |L1.3158|
                  |L1.3154|
;;;658                (i < slave))
000c52  428a              CMP      r2,r1
000c54  dbe1              BLT      |L1.3098|
                  |L1.3158|
;;;659          {
;;;660             i++;
;;;661          }
;;;662          if(i < slave)
000c56  428a              CMP      r2,r1
000c58  da3b              BGE      |L1.3282|
;;;663          {
;;;664             for( nSM=0 ; nSM < EC_MAXSM ; nSM++ )
000c5a  2500              MOVS     r5,#0
;;;665             {   
;;;666                context->slavelist[slave].SM[nSM].SMlength = context->slavelist[i].SM[nSM].SMlength;
000c5c  f04f0836          MOV      r8,#0x36
                  |L1.3168|
000c60  6847              LDR      r7,[r0,#4]
000c62  eb0806c5          ADD      r6,r8,r5,LSL #3
000c66  eb070c84          ADD      r12,r7,r4,LSL #2
000c6a  eb070783          ADD      r7,r7,r3,LSL #2
000c6e  f83cc006          LDRH     r12,[r12,r6]
000c72  f827c006          STRH     r12,[r7,r6]
;;;667                context->slavelist[slave].SMtype[nSM] = context->slavelist[i].SMtype[nSM];
000c76  6847              LDR      r7,[r0,#4]
000c78  f1050674          ADD      r6,r5,#0x74
000c7c  eb070c84          ADD      r12,r7,r4,LSL #2
000c80  eb070783          ADD      r7,r7,r3,LSL #2
000c84  f81cc006          LDRB     r12,[r12,r6]
000c88  1c6d              ADDS     r5,r5,#1
000c8a  f807c006          STRB     r12,[r7,r6]
000c8e  2d08              CMP      r5,#8                 ;664
000c90  dbe6              BLT      |L1.3168|
;;;668             }   
;;;669             *Osize = context->slavelist[i].Obits;
000c92  6846              LDR      r6,[r0,#4]
000c94  2518              MOVS     r5,#0x18
000c96  eb050784          ADD      r7,r5,r4,LSL #2
000c9a  5bf7              LDRH     r7,[r6,r7]
;;;670             *Isize = context->slavelist[i].Ibits;
000c9c  f8c97000          STR      r7,[r9,#0]
000ca0  6847              LDR      r7,[r0,#4]
000ca2  2626              MOVS     r6,#0x26
000ca4  eb060484          ADD      r4,r6,r4,LSL #2
000ca8  5b3f              LDRH     r7,[r7,r4]
;;;671             context->slavelist[slave].Obits = *Osize;
000caa  f8ca7000          STR      r7,[r10,#0]
000cae  6847              LDR      r7,[r0,#4]
000cb0  f8b94000          LDRH     r4,[r9,#0]
000cb4  eb050583          ADD      r5,r5,r3,LSL #2
000cb8  537c              STRH     r4,[r7,r5]
;;;672             context->slavelist[slave].Ibits = *Isize;
000cba  6840              LDR      r0,[r0,#4]
000cbc  f8ba4000          LDRH     r4,[r10,#0]
000cc0  eb060383          ADD      r3,r6,r3,LSL #2
000cc4  52c4              STRH     r4,[r0,r3]
;;;673             EC_PRINT("Copy mapping slave %d from %d.\n", slave, i);
000cc6  a05d              ADR      r0,|L1.3644|
000cc8  f7fffffe          BL       __2printf
;;;674             return 1;
000ccc  2001              MOVS     r0,#1
                  |L1.3278|
;;;675          }
;;;676       }
;;;677       return 0;
;;;678    }
000cce  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3282|
000cd2  2000              MOVS     r0,#0                 ;677
000cd4  e7fb              B        |L1.3278|
;;;679    
                          ENDP

                  ecx_map_sii PROC
;;;729    
;;;730    static int ecx_map_sii(ecx_contextt *context, uint16 slave)
000cd6  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;731    {
000cda  f6ad4d24          SUB      sp,sp,#0xc24
000cde  4604              MOV      r4,r0
;;;732       int Isize, Osize;
;;;733       int nSM;
;;;734       ec_eepromPDOt eepPDO;
;;;735       
;;;736       Osize = context->slavelist[slave].Obits;
000ce0  6841              LDR      r1,[r0,#4]
000ce2  f8dd0c28          LDR      r0,[sp,#0xc28]
000ce6  eb0002c0          ADD      r2,r0,r0,LSL #3
000cea  eb021580          ADD      r5,r2,r0,LSL #6
000cee  2018              MOVS     r0,#0x18
000cf0  eb000885          ADD      r8,r0,r5,LSL #2
000cf4  f8310008          LDRH     r0,[r1,r8]
;;;737       Isize = context->slavelist[slave].Ibits;
000cf8  f8cd0c1c          STR      r0,[sp,#0xc1c]
000cfc  6861              LDR      r1,[r4,#4]
000cfe  2026              MOVS     r0,#0x26
000d00  eb000a85          ADD      r10,r0,r5,LSL #2
000d04  f831000a          LDRH     r0,[r1,r10]
;;;738    
;;;739       if (!Isize && !Osize) /* find PDO in previous slave with same ID */
000d08  f8dd1c1c          LDR      r1,[sp,#0xc1c]
000d0c  f8cd0c18          STR      r0,[sp,#0xc18]
000d10  4308              ORRS     r0,r0,r1
000d12  d16e              BNE      |L1.3570|
;;;740       {
;;;741          (void)ecx_lookup_mapping(context, slave, &Osize, &Isize);
000d14  f60d4318          ADD      r3,sp,#0xc18
000d18  1d1a              ADDS     r2,r3,#4
000d1a  4620              MOV      r0,r4
000d1c  f8dd1c28          LDR      r1,[sp,#0xc28]
000d20  f7fffffe          BL       ecx_lookup_mapping
;;;742       }
;;;743       if (!Isize && !Osize) /* find PDO mapping by SII */
000d24  f60d4018          ADD      r0,sp,#0xc18
000d28  c803              LDM      r0,{r0,r1}
000d2a  4308              ORRS     r0,r0,r1
000d2c  d161              BNE      |L1.3570|
;;;744       {
;;;745          memset(&eepPDO, 0, sizeof(eepPDO));
000d2e  f6404118          MOV      r1,#0xc18
000d32  4668              MOV      r0,sp
000d34  f7fffffe          BL       __aeabi_memclr4
;;;746          Isize = (int)ecx_siiPDO(context, slave, &eepPDO, 0);
000d38  2300              MOVS     r3,#0
000d3a  466a              MOV      r2,sp
000d3c  4620              MOV      r0,r4
000d3e  f8dd1c28          LDR      r1,[sp,#0xc28]
000d42  f7fffffe          BL       ecx_siiPDO
000d46  4601              MOV      r1,r0
;;;747          EC_PRINT("  SII Isize:%d\n", Isize);               
000d48  f8cd0c18          STR      r0,[sp,#0xc18]
000d4c  a043              ADR      r0,|L1.3676|
000d4e  f7fffffe          BL       __2printf
;;;748          for( nSM=0 ; nSM < EC_MAXSM ; nSM++ )
000d52  2700              MOVS     r7,#0
;;;749          {   
;;;750             if (eepPDO.SMbitsize[nSM] > 0)
;;;751             {   
;;;752                context->slavelist[slave].SM[nSM].SMlength =  htoes((eepPDO.SMbitsize[nSM] + 7) / 8);
;;;753                context->slavelist[slave].SMtype[nSM] = 4;
000d54  f04f0b04          MOV      r11,#4
000d58  466e              MOV      r6,sp                 ;734
000d5a  f04f0936          MOV      r9,#0x36              ;752
                  |L1.3422|
000d5e  eb060047          ADD      r0,r6,r7,LSL #1       ;750
000d62  f8b01c06          LDRH     r1,[r0,#0xc06]        ;750
000d66  b1a1              CBZ      r1,|L1.3474|
000d68  1dc9              ADDS     r1,r1,#7              ;750
000d6a  08ca              LSRS     r2,r1,#3              ;752
000d6c  6861              LDR      r1,[r4,#4]            ;752
000d6e  eb010385          ADD      r3,r1,r5,LSL #2       ;752
000d72  eb0901c7          ADD      r1,r9,r7,LSL #3       ;752
000d76  525a              STRH     r2,[r3,r1]            ;752
000d78  6862              LDR      r2,[r4,#4]
;;;754                EC_PRINT("    SM%d length %d\n", nSM, eepPDO.SMbitsize[nSM]);
000d7a  4639              MOV      r1,r7
000d7c  eb020385          ADD      r3,r2,r5,LSL #2       ;753
000d80  f1070274          ADD      r2,r7,#0x74           ;753
000d84  f803b002          STRB     r11,[r3,r2]           ;753
000d88  f8b02c06          LDRH     r2,[r0,#0xc06]
000d8c  a037              ADR      r0,|L1.3692|
000d8e  f7fffffe          BL       __2printf
                  |L1.3474|
000d92  1c7f              ADDS     r7,r7,#1
000d94  2f08              CMP      r7,#8                 ;748
000d96  dbe2              BLT      |L1.3422|
;;;755             }   
;;;756          }   
;;;757          Osize = (int)ecx_siiPDO(context, slave, &eepPDO, 1);
000d98  2301              MOVS     r3,#1
000d9a  466a              MOV      r2,sp
000d9c  4620              MOV      r0,r4
000d9e  f8dd1c28          LDR      r1,[sp,#0xc28]
000da2  f7fffffe          BL       ecx_siiPDO
000da6  4601              MOV      r1,r0
;;;758          EC_PRINT("  SII Osize:%d\n", Osize);               
000da8  f8cd0c1c          STR      r0,[sp,#0xc1c]
000dac  a034              ADR      r0,|L1.3712|
000dae  f7fffffe          BL       __2printf
;;;759          for( nSM=0 ; nSM < EC_MAXSM ; nSM++ )
000db2  2700              MOVS     r7,#0
;;;760          {   
;;;761             if (eepPDO.SMbitsize[nSM] > 0)
;;;762             {   
;;;763                context->slavelist[slave].SM[nSM].SMlength =  htoes((eepPDO.SMbitsize[nSM] + 7) / 8);
;;;764                context->slavelist[slave].SMtype[nSM] = 3;
000db4  f04f0b03          MOV      r11,#3
                  |L1.3512|
000db8  eb060147          ADD      r1,r6,r7,LSL #1       ;761
000dbc  f8b10c06          LDRH     r0,[r1,#0xc06]        ;761
000dc0  b1a0              CBZ      r0,|L1.3564|
000dc2  1dc0              ADDS     r0,r0,#7              ;761
000dc4  08c2              LSRS     r2,r0,#3              ;763
000dc6  6860              LDR      r0,[r4,#4]            ;763
000dc8  eb000385          ADD      r3,r0,r5,LSL #2       ;763
000dcc  eb0900c7          ADD      r0,r9,r7,LSL #3       ;763
000dd0  521a              STRH     r2,[r3,r0]            ;763
000dd2  6862              LDR      r2,[r4,#4]
;;;765                EC_PRINT("    SM%d length %d\n", nSM, eepPDO.SMbitsize[nSM]);
000dd4  a025              ADR      r0,|L1.3692|
000dd6  eb020385          ADD      r3,r2,r5,LSL #2       ;764
000dda  f1070274          ADD      r2,r7,#0x74           ;764
000dde  f803b002          STRB     r11,[r3,r2]           ;764
000de2  f8b12c06          LDRH     r2,[r1,#0xc06]
000de6  4639              MOV      r1,r7
000de8  f7fffffe          BL       __2printf
                  |L1.3564|
000dec  1c7f              ADDS     r7,r7,#1
000dee  2f08              CMP      r7,#8                 ;759
000df0  dbe2              BLT      |L1.3512|
                  |L1.3570|
;;;766             }   
;;;767          }   
;;;768       }
;;;769       context->slavelist[slave].Obits = Osize;
000df2  6862              LDR      r2,[r4,#4]
000df4  f8dd0c1c          LDR      r0,[sp,#0xc1c]
000df8  f8220008          STRH     r0,[r2,r8]
;;;770       context->slavelist[slave].Ibits = Isize;
000dfc  f8dd0c18          LDR      r0,[sp,#0xc18]
000e00  6862              LDR      r2,[r4,#4]
000e02  b281              UXTH     r1,r0
;;;771       EC_PRINT("     ISIZE:%d %d OSIZE:%d\n", 
000e04  a022              ADR      r0,|L1.3728|
000e06  f822100a          STRH     r1,[r2,r10]           ;770
000e0a  6862              LDR      r2,[r4,#4]
000e0c  f8323008          LDRH     r3,[r2,r8]
000e10  f8dd2c18          LDR      r2,[sp,#0xc18]
000e14  f7fffffe          BL       __2printf
;;;772          context->slavelist[slave].Ibits, Isize,context->slavelist[slave].Obits);    
;;;773    
;;;774       return 1;
000e18  2001              MOVS     r0,#1
;;;775    }
000e1a  f60d4d2c          ADD      sp,sp,#0xc2c
000e1e  e6e3              B        |L1.3048|
                  |L1.3616|
000e20  3f204d3a          DCB      "? M:%8.8x I:%8.8x",0
000e24  25382e38
000e28  7820493a
000e2c  25382e38
000e30  7800    
000e32  00                DCB      0
000e33  00                DCB      0
                  |L1.3636|
                          DCD      0x00010026
                  |L1.3640|
                          DCD      0x001e8480
                  |L1.3644|
000e3c  436f7079          DCB      "Copy mapping slave %d from %d.\n",0
000e40  206d6170
000e44  70696e67
000e48  20736c61
000e4c  76652025
000e50  64206672
000e54  6f6d2025
000e58  642e0a00
                  |L1.3676|
000e5c  20205349          DCB      "  SII Isize:%d\n",0
000e60  49204973
000e64  697a653a
000e68  25640a00
                  |L1.3692|
000e6c  20202020          DCB      "    SM%d length %d\n",0
000e70  534d2564
000e74  206c656e
000e78  67746820
000e7c  25640a00
                  |L1.3712|
000e80  20205349          DCB      "  SII Osize:%d\n",0
000e84  49204f73
000e88  697a653a
000e8c  25640a00
                  |L1.3728|
000e90  20202020          DCB      "     ISIZE:%d %d OSIZE:%d\n",0
000e94  20495349
000e98  5a453a25
000e9c  64202564
000ea0  204f5349
000ea4  5a453a25
000ea8  640a00  
000eab  00                DCB      0
                          ENDP

                  ecx_map_sm PROC
;;;776    
;;;777    static int ecx_map_sm(ecx_contextt *context, uint16 slave)
000eac  e92d4ffe          PUSH     {r1-r11,lr}
;;;778    {
000eb0  4606              MOV      r6,r0
;;;779       uint16 configadr;
;;;780       int nSM;
;;;781       
;;;782       configadr = context->slavelist[slave].configadr;
000eb2  eb0102c1          ADD      r2,r1,r1,LSL #3
000eb6  6840              LDR      r0,[r0,#4]
000eb8  eb021581          ADD      r5,r2,r1,LSL #6
000ebc  2104              MOVS     r1,#4
000ebe  eb010185          ADD      r1,r1,r5,LSL #2
000ec2  5a40              LDRH     r0,[r0,r1]
;;;783    
;;;784       EC_PRINT("  SM programming\n");  
000ec4  9002              STR      r0,[sp,#8]
000ec6  a0f4              ADR      r0,|L1.4760|
000ec8  f7fffffe          BL       __2printf
;;;785       if (!context->slavelist[slave].mbx_l && context->slavelist[slave].SM[0].StartAddr)
000ecc  6870              LDR      r0,[r6,#4]
000ece  21c0              MOVS     r1,#0xc0
000ed0  eb010785          ADD      r7,r1,r5,LSL #2
000ed4  5bc1              LDRH     r1,[r0,r7]
000ed6  f04f0a34          MOV      r10,#0x34
;;;786       {
;;;787          ecx_FPWR(context->port, configadr, ECT_REG_SM0, 
000eda  f2417970          MOV      r9,#0x1770
000ede  f44f6b00          MOV      r11,#0x800
;;;788             sizeof(ec_smt), &(context->slavelist[slave].SM[0]), EC_TIMEOUTRET3);
;;;789          EC_PRINT("    SM0 Type:%d StartAddr:%4.4x Flags:%8.8x\n", 
000ee2  f04f0838          MOV      r8,#0x38
000ee6  2900              CMP      r1,#0                 ;785
000ee8  d138              BNE      |L1.3932|
000eea  eb0a0485          ADD      r4,r10,r5,LSL #2      ;785
000eee  5b01              LDRH     r1,[r0,r4]            ;785
000ef0  b1b9              CBZ      r1,|L1.3874|
000ef2  4420              ADD      r0,r0,r4              ;787
000ef4  e9cd0900          STRD     r0,r9,[sp,#0]         ;787
000ef8  2308              MOVS     r3,#8                 ;787
000efa  465a              MOV      r2,r11                ;787
000efc  6830              LDR      r0,[r6,#0]            ;787
000efe  9902              LDR      r1,[sp,#8]            ;787
000f00  f7fffffe          BL       ecx_FPWR
000f04  6870              LDR      r0,[r6,#4]
000f06  eb080185          ADD      r1,r8,r5,LSL #2
000f0a  5843              LDR      r3,[r0,r1]
000f0c  2174              MOVS     r1,#0x74
000f0e  eb010185          ADD      r1,r1,r5,LSL #2
000f12  5b02              LDRH     r2,[r0,r4]
000f14  5c41              LDRB     r1,[r0,r1]
000f16  a0e5              ADR      r0,|L1.4780|
000f18  f7fffffe          BL       __2printf
;;;790              context->slavelist[slave].SMtype[0], 
;;;791              etohs(context->slavelist[slave].SM[0].StartAddr),
;;;792              etohl(context->slavelist[slave].SM[0].SMflags));
;;;793       }
;;;794       if (!context->slavelist[slave].mbx_l && context->slavelist[slave].SM[1].StartAddr)
000f1c  6870              LDR      r0,[r6,#4]
000f1e  5bc0              LDRH     r0,[r0,r7]
000f20  b9e0              CBNZ     r0,|L1.3932|
                  |L1.3874|
000f22  6870              LDR      r0,[r6,#4]
000f24  213c              MOVS     r1,#0x3c
000f26  eb010485          ADD      r4,r1,r5,LSL #2
000f2a  5b01              LDRH     r1,[r0,r4]
000f2c  b1b1              CBZ      r1,|L1.3932|
;;;795       {
;;;796          ecx_FPWR(context->port, configadr, ECT_REG_SM1, 
000f2e  4420              ADD      r0,r0,r4
000f30  e9cd0900          STRD     r0,r9,[sp,#0]
000f34  2308              MOVS     r3,#8
000f36  f6400208          MOV      r2,#0x808
000f3a  6830              LDR      r0,[r6,#0]
000f3c  9902              LDR      r1,[sp,#8]
000f3e  f7fffffe          BL       ecx_FPWR
;;;797             sizeof(ec_smt), &context->slavelist[slave].SM[1], EC_TIMEOUTRET3);
;;;798          EC_PRINT("    SM1 Type:%d StartAddr:%4.4x Flags:%8.8x\n", 
000f42  2140              MOVS     r1,#0x40
000f44  6870              LDR      r0,[r6,#4]
000f46  eb010185          ADD      r1,r1,r5,LSL #2
000f4a  5843              LDR      r3,[r0,r1]
000f4c  2175              MOVS     r1,#0x75
000f4e  eb010185          ADD      r1,r1,r5,LSL #2
000f52  5b02              LDRH     r2,[r0,r4]
000f54  5c41              LDRB     r1,[r0,r1]
000f56  a0e1              ADR      r0,|L1.4828|
000f58  f7fffffe          BL       __2printf
                  |L1.3932|
;;;799              context->slavelist[slave].SMtype[1], 
;;;800              etohs(context->slavelist[slave].SM[1].StartAddr),
;;;801              etohl(context->slavelist[slave].SM[1].SMflags));
;;;802       }
;;;803       /* program SM2 to SMx */
;;;804       for( nSM = 2 ; nSM < EC_MAXSM ; nSM++ )
000f5c  2402              MOVS     r4,#2
                  |L1.3934|
;;;805       {   
;;;806          if (context->slavelist[slave].SM[nSM].StartAddr)
000f5e  6870              LDR      r0,[r6,#4]
000f60  eb0a07c4          ADD      r7,r10,r4,LSL #3
000f64  eb000085          ADD      r0,r0,r5,LSL #2
000f68  5bc1              LDRH     r1,[r0,r7]
000f6a  b341              CBZ      r1,|L1.4030|
;;;807          {
;;;808             /* check if SM length is zero -> clear enable flag */
;;;809             if( context->slavelist[slave].SM[nSM].SMlength == 0) 
000f6c  2136              MOVS     r1,#0x36
000f6e  eb0101c4          ADD      r1,r1,r4,LSL #3
000f72  5a41              LDRH     r1,[r0,r1]
000f74  2900              CMP      r1,#0
;;;810             {
;;;811                context->slavelist[slave].SM[nSM].SMflags = 
;;;812                   htoel( etohl(context->slavelist[slave].SM[nSM].SMflags) & EC_SMENABLEMASK);
;;;813             }
;;;814             else
;;;815             {
;;;816                context->slavelist[slave].SM[nSM].SMflags =
000f76  eb0801c4          ADD      r1,r8,r4,LSL #3
000f7a  5842              LDR      r2,[r0,r1]
000f7c  d03f              BEQ      |L1.4094|
000f7e  f4423280          ORR      r2,r2,#0x10000
                  |L1.3970|
000f82  5042              STR      r2,[r0,r1]
;;;817                   htoel( etohl(context->slavelist[slave].SM[nSM].SMflags) | ~EC_SMENABLEMASK);
;;;818             }
;;;819             ecx_FPWR(context->port, configadr, (uint16)(ECT_REG_SM0 + (nSM * sizeof(ec_smt))),
000f84  6871              LDR      r1,[r6,#4]
000f86  eb0b00c4          ADD      r0,r11,r4,LSL #3
000f8a  eb010185          ADD      r1,r1,r5,LSL #2
000f8e  4439              ADD      r1,r1,r7
000f90  e9cd1900          STRD     r1,r9,[sp,#0]
000f94  b282              UXTH     r2,r0
000f96  2308              MOVS     r3,#8
000f98  6830              LDR      r0,[r6,#0]
000f9a  9902              LDR      r1,[sp,#8]
000f9c  f7fffffe          BL       ecx_FPWR
;;;820                sizeof(ec_smt), &context->slavelist[slave].SM[nSM], EC_TIMEOUTRET3);
;;;821             EC_PRINT("    SM%d Type:%d StartAddr:%4.4x Flags:%8.8x\n", nSM,
000fa0  6870              LDR      r0,[r6,#4]
000fa2  eb0801c4          ADD      r1,r8,r4,LSL #3
000fa6  eb000085          ADD      r0,r0,r5,LSL #2
000faa  5841              LDR      r1,[r0,r1]
000fac  9100              STR      r1,[sp,#0]
000fae  f1040174          ADD      r1,r4,#0x74
000fb2  5bc3              LDRH     r3,[r0,r7]
000fb4  5c42              LDRB     r2,[r0,r1]
000fb6  4621              MOV      r1,r4
000fb8  a0d4              ADR      r0,|L1.4876|
000fba  f7fffffe          BL       __2printf
                  |L1.4030|
000fbe  1c64              ADDS     r4,r4,#1
000fc0  2c08              CMP      r4,#8                 ;804
000fc2  dbcc              BLT      |L1.3934|
;;;822                 context->slavelist[slave].SMtype[nSM], 
;;;823                 etohs(context->slavelist[slave].SM[nSM].StartAddr),
;;;824                 etohl(context->slavelist[slave].SM[nSM].SMflags));
;;;825          }
;;;826       }
;;;827       if (context->slavelist[slave].Ibits > 7)
000fc4  6871              LDR      r1,[r6,#4]
000fc6  2026              MOVS     r0,#0x26
000fc8  eb000085          ADD      r0,r0,r5,LSL #2
000fcc  5a08              LDRH     r0,[r1,r0]
000fce  2807              CMP      r0,#7
000fd0  d905              BLS      |L1.4062|
000fd2  1dc0              ADDS     r0,r0,#7
;;;828       {
;;;829          context->slavelist[slave].Ibytes = (context->slavelist[slave].Ibits + 7) / 8;
000fd4  08c0              LSRS     r0,r0,#3
000fd6  2228              MOVS     r2,#0x28
000fd8  eb020285          ADD      r2,r2,r5,LSL #2
000fdc  5088              STR      r0,[r1,r2]
                  |L1.4062|
;;;830       }
;;;831       if (context->slavelist[slave].Obits > 7)
000fde  6871              LDR      r1,[r6,#4]
000fe0  2018              MOVS     r0,#0x18
000fe2  eb000085          ADD      r0,r0,r5,LSL #2
000fe6  5a08              LDRH     r0,[r1,r0]
000fe8  2807              CMP      r0,#7
000fea  d905              BLS      |L1.4088|
000fec  1dc0              ADDS     r0,r0,#7
;;;832       {
;;;833          context->slavelist[slave].Obytes = (context->slavelist[slave].Obits + 7) / 8;
000fee  08c0              LSRS     r0,r0,#3
000ff0  221c              MOVS     r2,#0x1c
000ff2  eb020285          ADD      r2,r2,r5,LSL #2
000ff6  5088              STR      r0,[r1,r2]
                  |L1.4088|
;;;834       }
;;;835       
;;;836       return 1;
000ff8  2001              MOVS     r0,#1
;;;837    } 
000ffa  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.4094|
000ffe  f4223280          BIC      r2,r2,#0x10000        ;811
001002  e7be              B        |L1.3970|
;;;838    
                          ENDP

                  ecx_recover_slave PROC
;;;1111    */
;;;1112   int ecx_recover_slave(ecx_contextt *context, uint16 slave, int timeout)
001004  e92d5fff          PUSH     {r0-r12,lr}
;;;1113   {
001008  468b              MOV      r11,r1
00100a  4616              MOV      r6,r2
;;;1114      int rval;
;;;1115      uint16 ADPh, configadr, readadr, wkc;
;;;1116   	 uint16 w;
;;;1117      uint32 zbuf;
;;;1118   	 uint8 b;
;;;1119      memset(&zbuf, 0x00, sizeof(zbuf));
;;;1120   	
;;;1121      rval = 0;
;;;1122      configadr = context->slavelist[slave].configadr;
00100c  eb0b02cb          ADD      r2,r11,r11,LSL #3
001010  4604              MOV      r4,r0                 ;1113
001012  eb02158b          ADD      r5,r2,r11,LSL #6
001016  6841              LDR      r1,[r0,#4]
001018  2004              MOVS     r0,#4
00101a  eb000885          ADD      r8,r0,r5,LSL #2
;;;1123   	   ADPh = (uint16)(1 - slave);
00101e  f1cb0001          RSB      r0,r11,#1
001022  f8317008          LDRH     r7,[r1,r8]            ;1122
001026  b280              UXTH     r0,r0
;;;1124      /* check if we found another slave than the requested */
;;;1125      readadr = 0xfffe;
001028  9002              STR      r0,[sp,#8]
00102a  f64f70fe          MOV      r0,#0xfffe
00102e  f8ad000c          STRH     r0,[sp,#0xc]
;;;1126      wkc = ecx_APRD(context->port, ADPh, ECT_REG_STADR, sizeof(readadr), &readadr, timeout);
001032  a803              ADD      r0,sp,#0xc
001034  e9cd0600          STRD     r0,r6,[sp,#0]
001038  f04f0a00          MOV      r10,#0                ;1121
00103c  2302              MOVS     r3,#2
00103e  2210              MOVS     r2,#0x10
001040  6820              LDR      r0,[r4,#0]
001042  9902              LDR      r1,[sp,#8]
001044  f7fffffe          BL       ecx_APRD
001048  b281              UXTH     r1,r0
;;;1127      /* correct slave found, finished */
;;;1128   	 
;;;1129   	if(readadr == configadr)
00104a  f8bd000c          LDRH     r0,[sp,#0xc]
00104e  42b8              CMP      r0,r7
001050  d103              BNE      |L1.4186|
;;;1130      {
;;;1131          return 2;
001052  2002              MOVS     r0,#2
                  |L1.4180|
;;;1132      }
;;;1133      /* only try if no config address*/
;;;1134      if( (wkc > 0) && (readadr == 0))
;;;1135   //	 if(wkc > 0)
;;;1136      {
;;;1137         /* clear possible slaves at EC_TEMPNODE */
;;;1138         b = 0xf0;
;;;1139         ecx_APWRw(context->port, ADPh, ECT_REG_DLPORT , b, EC_TIMEOUTRET3);     /* deact loop manual */
;;;1140         zbuf=0x00000000;
;;;1141   		  ecx_APWRw(context->port, ADPh, ECT_REG_RXERR  , zbuf, EC_TIMEOUTRET3);  /* reset CRC counters */		 
;;;1142   		  ecx_APWRw(context->port, ADPh, ECT_REG_ALCTL, htoes(EC_STATE_INIT|EC_STATE_ACK) , EC_TIMEOUTRET3);
;;;1143   		 
;;;1144         ecx_FPWRw(context->port, EC_TEMPNODE, ECT_REG_STADR, htoes(0) , 0);
;;;1145         /* set temporary node address of slave */
;;;1146   		if(ecx_APWRw(context->port, ADPh, ECT_REG_STADR, htoes(EC_TEMPNODE) , timeout) <= 0)
;;;1147   		{   
;;;1148   			 ecx_FPWRw(context->port, EC_TEMPNODE, ECT_REG_STADR, htoes(0) , 0);
;;;1149   			 return 0; /* slave fails to respond */
;;;1150   		}
;;;1151      
;;;1152        context->slavelist[slave].configadr = EC_TEMPNODE; /* temporary config address */   
;;;1153       ecx_eeprom2master(context, slave); /* set Eeprom control to master */         
;;;1154         /* check if slave is the same as configured before */
;;;1155         if ((ecx_FPRDw(context->port, EC_TEMPNODE, ECT_REG_ALIAS, timeout) == 
;;;1156                context->slavelist[slave].aliasadr) &&
;;;1157             (ecx_readeeprom(context, slave, ECT_SII_ID, EC_TIMEOUTEEP) == 
;;;1158                context->slavelist[slave].eep_id) &&
;;;1159             (ecx_readeeprom(context, slave, ECT_SII_MANUF, EC_TIMEOUTEEP) == 
;;;1160                context->slavelist[slave].eep_man) &&
;;;1161             (ecx_readeeprom(context, slave, ECT_SII_REV, EC_TIMEOUTEEP) == 
;;;1162                context->slavelist[slave].eep_rev))
;;;1163         {
;;;1164            rval = ecx_FPWRw(context->port, EC_TEMPNODE, ECT_REG_STADR, htoes(configadr) , timeout);
;;;1165            context->slavelist[slave].configadr = configadr;
;;;1166         }
;;;1167         else
;;;1168         {
;;;1169            /* slave is not the expected one, remove config address*/
;;;1170            ecx_FPWRw(context->port, EC_TEMPNODE, ECT_REG_STADR, htoes(0) , timeout);
;;;1171            context->slavelist[slave].configadr = configadr;
;;;1172         }
;;;1173      }
;;;1174   
;;;1175      return rval;
;;;1176   }
001054  b004              ADD      sp,sp,#0x10
001056  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.4186|
00105a  2900              CMP      r1,#0                 ;1134
00105c  d07e              BEQ      |L1.4444|
00105e  2800              CMP      r0,#0                 ;1134
001060  d17c              BNE      |L1.4444|
001062  f2417970          MOV      r9,#0x1770            ;1139
001066  f8cd9000          STR      r9,[sp,#0]            ;1139
00106a  23f0              MOVS     r3,#0xf0              ;1138
00106c  f2401201          MOV      r2,#0x101             ;1139
001070  6820              LDR      r0,[r4,#0]            ;1139
001072  9902              LDR      r1,[sp,#8]            ;1139
001074  f7fffffe          BL       ecx_APWRw
001078  f8cd9000          STR      r9,[sp,#0]            ;1141
00107c  2300              MOVS     r3,#0                 ;1141
00107e  f44f7240          MOV      r2,#0x300             ;1141
001082  6820              LDR      r0,[r4,#0]            ;1141
001084  9902              LDR      r1,[sp,#8]            ;1141
001086  f7fffffe          BL       ecx_APWRw
00108a  f8cd9000          STR      r9,[sp,#0]            ;1142
00108e  2311              MOVS     r3,#0x11              ;1142
001090  f44f7290          MOV      r2,#0x120             ;1142
001094  6820              LDR      r0,[r4,#0]            ;1142
001096  9902              LDR      r1,[sp,#8]            ;1142
001098  f7fffffe          BL       ecx_APWRw
00109c  2000              MOVS     r0,#0                 ;1144
00109e  9000              STR      r0,[sp,#0]            ;1144
0010a0  f64f79ff          MOV      r9,#0xffff            ;1144
0010a4  2300              MOVS     r3,#0                 ;1144
0010a6  2210              MOVS     r2,#0x10              ;1144
0010a8  4649              MOV      r1,r9                 ;1144
0010aa  6820              LDR      r0,[r4,#0]            ;1144
0010ac  f7fffffe          BL       ecx_FPWRw
0010b0  9600              STR      r6,[sp,#0]            ;1146
0010b2  464b              MOV      r3,r9                 ;1146
0010b4  2210              MOVS     r2,#0x10              ;1146
0010b6  6820              LDR      r0,[r4,#0]            ;1146
0010b8  9902              LDR      r1,[sp,#8]            ;1146
0010ba  f7fffffe          BL       ecx_APWRw
0010be  2800              CMP      r0,#0                 ;1146
0010c0  dc09              BGT      |L1.4310|
0010c2  2000              MOVS     r0,#0                 ;1148
0010c4  9000              STR      r0,[sp,#0]            ;1148
0010c6  2300              MOVS     r3,#0                 ;1148
0010c8  2210              MOVS     r2,#0x10              ;1148
0010ca  4649              MOV      r1,r9                 ;1148
0010cc  6820              LDR      r0,[r4,#0]            ;1148
0010ce  f7fffffe          BL       ecx_FPWRw
0010d2  2000              MOVS     r0,#0                 ;1149
0010d4  e7be              B        |L1.4180|
                  |L1.4310|
0010d6  6862              LDR      r2,[r4,#4]            ;1152
0010d8  4659              MOV      r1,r11                ;1153
0010da  4620              MOV      r0,r4                 ;1153
0010dc  f8229008          STRH     r9,[r2,r8]            ;1152
0010e0  f7fffffe          BL       ecx_eeprom2master
0010e4  4633              MOV      r3,r6                 ;1155
0010e6  2212              MOVS     r2,#0x12              ;1155
0010e8  4649              MOV      r1,r9                 ;1155
0010ea  6820              LDR      r0,[r4,#0]            ;1155
0010ec  f7fffffe          BL       ecx_FPRDw
0010f0  6861              LDR      r1,[r4,#4]            ;1155
0010f2  2206              MOVS     r2,#6                 ;1155
0010f4  eb020285          ADD      r2,r2,r5,LSL #2       ;1155
0010f8  5a89              LDRH     r1,[r1,r2]            ;1155
0010fa  4288              CMP      r0,r1                 ;1155
0010fc  d134              BNE      |L1.4456|
0010fe  f6446320          MOV      r3,#0x4e20            ;1157
001102  220a              MOVS     r2,#0xa               ;1157
001104  4659              MOV      r1,r11                ;1157
001106  4620              MOV      r0,r4                 ;1157
001108  f7fffffe          BL       ecx_readeeprom
00110c  220c              MOVS     r2,#0xc               ;1157
00110e  6861              LDR      r1,[r4,#4]            ;1157
001110  eb020285          ADD      r2,r2,r5,LSL #2       ;1157
001114  5889              LDR      r1,[r1,r2]            ;1157
001116  4288              CMP      r0,r1                 ;1157
001118  d126              BNE      |L1.4456|
00111a  f6446320          MOV      r3,#0x4e20            ;1159
00111e  2208              MOVS     r2,#8                 ;1159
001120  4659              MOV      r1,r11                ;1159
001122  4620              MOV      r0,r4                 ;1159
001124  f7fffffe          BL       ecx_readeeprom
001128  2208              MOVS     r2,#8                 ;1159
00112a  6861              LDR      r1,[r4,#4]            ;1159
00112c  eb020285          ADD      r2,r2,r5,LSL #2       ;1159
001130  5889              LDR      r1,[r1,r2]            ;1159
001132  4288              CMP      r0,r1                 ;1159
001134  d118              BNE      |L1.4456|
001136  f6446320          MOV      r3,#0x4e20            ;1161
00113a  220c              MOVS     r2,#0xc               ;1161
00113c  4659              MOV      r1,r11                ;1161
00113e  4620              MOV      r0,r4                 ;1161
001140  f7fffffe          BL       ecx_readeeprom
001144  2210              MOVS     r2,#0x10              ;1161
001146  6861              LDR      r1,[r4,#4]            ;1161
001148  eb020285          ADD      r2,r2,r5,LSL #2       ;1161
00114c  5889              LDR      r1,[r1,r2]            ;1161
00114e  4288              CMP      r0,r1                 ;1161
001150  d10a              BNE      |L1.4456|
001152  9600              STR      r6,[sp,#0]            ;1164
001154  463b              MOV      r3,r7                 ;1164
001156  2210              MOVS     r2,#0x10              ;1164
001158  4649              MOV      r1,r9                 ;1164
00115a  e000              B        |L1.4446|
                  |L1.4444|
00115c  e00e              B        |L1.4476|
                  |L1.4446|
00115e  6820              LDR      r0,[r4,#0]            ;1164
001160  f7fffffe          BL       ecx_FPWRw
001164  4682              MOV      r10,r0                ;1164
001166  e006              B        |L1.4470|
                  |L1.4456|
001168  9600              STR      r6,[sp,#0]            ;1170
00116a  2300              MOVS     r3,#0                 ;1170
00116c  2210              MOVS     r2,#0x10              ;1170
00116e  4649              MOV      r1,r9                 ;1170
001170  6820              LDR      r0,[r4,#0]            ;1170
001172  f7fffffe          BL       ecx_FPWRw
                  |L1.4470|
001176  6861              LDR      r1,[r4,#4]            ;1165
001178  f8217008          STRH     r7,[r1,r8]            ;1165
                  |L1.4476|
00117c  4650              MOV      r0,r10                ;1175
00117e  e769              B        |L1.4180|
;;;1177   #ifdef EC_VER1
                          ENDP

                  ec_config_init PROC
;;;1178   int ec_config_init(uint8 usetable)
001180  4601              MOV      r1,r0
;;;1179   {
;;;1180      return ecx_config_init(&ecx_context, usetable);
001182  486e              LDR      r0,|L1.4924|
001184  f7ffbffe          B.W      ecx_config_init
;;;1181   }
;;;1182   /** Map all PDOs in one group of slaves to IOmap with Outputs/Inputs
                          ENDP

                  ecx_config_map_group PROC
;;;1235    */
;;;1236   int ecx_config_map_group(ecx_contextt *context, void *pIOmap, uint8 group)
001188  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1237   {
00118c  4604              MOV      r4,r0
;;;1238      uint16 slave, configadr;
;;;1239      int BitCount, ByteCount, FMMUsize, FMMUdone;
;;;1240      uint16 SMlength, EndAddr;
;;;1241      uint8 BitPos;
;;;1242      uint8 SMc, FMMUc;
;;;1243      uint32 LogAddr = 0;
;;;1244      uint32 oLogAddr = 0;
;;;1245      uint32 diff;
;;;1246      uint16 currentsegment = 0;
;;;1247      uint32 segmentsize = 0;
;;;1248      int thrn, thrc;
;;;1249      if ((*(context->slavecount) > 0) && (group < context->maxgroup))
00118e  6880              LDR      r0,[r0,#8]
001190  f04f0b00          MOV      r11,#0                ;1246
001194  b090              SUB      sp,sp,#0x40           ;1237
001196  6800              LDR      r0,[r0,#0]
001198  46da              MOV      r10,r11               ;1247
00119a  2800              CMP      r0,#0
                  |L1.4508|
00119c  dd7a              BLE      |L1.4756|
00119e  6961              LDR      r1,[r4,#0x14]
0011a0  9812              LDR      r0,[sp,#0x48]
0011a2  4281              CMP      r1,r0
0011a4  ddfa              BLE      |L1.4508|
;;;1250      {   
;;;1251         EC_PRINT("ec_config_map_group IOmap:%p group:%d\n", pIOmap, group);
0011a6  4602              MOV      r2,r0
0011a8  a065              ADR      r0,|L1.4928|
0011aa  9911              LDR      r1,[sp,#0x44]
0011ac  f7fffffe          BL       __2printf
;;;1252         LogAddr = context->grouplist[group].logstartaddr;
0011b0  9812              LDR      r0,[sp,#0x48]
0011b2  6921              LDR      r1,[r4,#0x10]
0011b4  eb000280          ADD      r2,r0,r0,LSL #2
0011b8  eb021040          ADD      r0,r2,r0,LSL #5
0011bc  9002              STR      r0,[sp,#8]
0011be  f8515030          LDR      r5,[r1,r0,LSL #3]
;;;1253         oLogAddr = LogAddr;
;;;1254         BitPos = 0;
;;;1255         context->grouplist[group].nsegments = 0;
0011c2  231c              MOVS     r3,#0x1c
0011c4  eb0300c0          ADD      r0,r3,r0,LSL #3
0011c8  46d9              MOV      r9,r11                ;1254
0011ca  9507              STR      r5,[sp,#0x1c]
0011cc  900b              STR      r0,[sp,#0x2c]
0011ce  f8219000          STRH     r9,[r1,r0]
;;;1256         context->grouplist[group].outputsWKC = 0;
0011d2  9802              LDR      r0,[sp,#8]
0011d4  2122              MOVS     r1,#0x22
0011d6  6923              LDR      r3,[r4,#0x10]
0011d8  eb0100c0          ADD      r0,r1,r0,LSL #3
0011dc  900c              STR      r0,[sp,#0x30]
0011de  f8239000          STRH     r9,[r3,r0]
;;;1257         context->grouplist[group].inputsWKC = 0;
0011e2  9802              LDR      r0,[sp,#8]
0011e4  6923              LDR      r3,[r4,#0x10]
0011e6  2124              MOVS     r1,#0x24
0011e8  eb0100c0          ADD      r0,r1,r0,LSL #3
0011ec  900a              STR      r0,[sp,#0x28]
0011ee  f8239000          STRH     r9,[r3,r0]
0011f2  68a1              LDR      r1,[r4,#8]            ;1249
;;;1258   #ifdef EC_MAX_MAPT		 
;;;1259   				/* find CoE and SoE mapping of slaves in multiple threads */
;;;1260   			 for (slave = 1; slave <= *(context->slavecount); slave++)
0011f4  2001              MOVS     r0,#1
0011f6  6809              LDR      r1,[r1,#0]            ;1249
0011f8  e001              B        |L1.4606|
                  |L1.4602|
0011fa  1c40              ADDS     r0,r0,#1
0011fc  b280              UXTH     r0,r0
                  |L1.4606|
0011fe  4281              CMP      r1,r0
001200  dafb              BGE      |L1.4602|
;;;1261   			 {
;;;1262   					if (!group || (group == context->slavelist[slave].group))
;;;1263   					{
;;;1264   						;
;;;1265   	//							ecx_map_coe_soe(context, slave,0);
;;;1266   					}
;;;1267   			 }
;;;1268   #endif
;;;1269         /* find SII mapping of slave and program SM */
;;;1270         for (slave = 1; slave <= *(context->slavecount); slave++)
001202  2601              MOVS     r6,#1
001204  e018              B        |L1.4664|
                  |L1.4614|
;;;1271         {
;;;1272            if (!group || (group == context->slavelist[slave].group))
001206  9812              LDR      r0,[sp,#0x48]
001208  b160              CBZ      r0,|L1.4644|
00120a  eb0600c6          ADD      r0,r6,r6,LSL #3
00120e  eb001286          ADD      r2,r0,r6,LSL #6
001212  f2401003          MOV      r0,#0x103
001216  6861              LDR      r1,[r4,#4]
001218  eb000082          ADD      r0,r0,r2,LSL #2
00121c  5c09              LDRB     r1,[r1,r0]
00121e  9812              LDR      r0,[sp,#0x48]
001220  4281              CMP      r1,r0
001222  d107              BNE      |L1.4660|
                  |L1.4644|
;;;1273            {             
;;;1274               ecx_map_sii(context, slave);
001224  4631              MOV      r1,r6
001226  4620              MOV      r0,r4
001228  f7fffffe          BL       ecx_map_sii
;;;1275               ecx_map_sm(context, slave);
00122c  4631              MOV      r1,r6
00122e  4620              MOV      r0,r4
001230  f7fffffe          BL       ecx_map_sm
                  |L1.4660|
001234  1c76              ADDS     r6,r6,#1
001236  b2b6              UXTH     r6,r6                 ;1270
                  |L1.4664|
001238  68a0              LDR      r0,[r4,#8]            ;1270
00123a  6800              LDR      r0,[r0,#0]            ;1270
00123c  42b0              CMP      r0,r6                 ;1270
00123e  dae2              BGE      |L1.4614|
;;;1276            }
;;;1277         }
;;;1278   //      /* do input mapping of slave and program FMMUs */
;;;1279   //      for (slave = 1; slave <= *(context->slavecount); slave++)
;;;1280   //      {
;;;1281   //         configadr = context->slavelist[slave].configadr;
;;;1282   
;;;1283   //         if (!group || (group == context->slavelist[slave].group))
;;;1284   //         {   
;;;1285   //            /* create output mapping */
;;;1286   //            if (context->slavelist[slave].Obits)
;;;1287   //            {
;;;1288   //               ecx_config_create_output_mappings (context, pIOmap, group, slave, &LogAddr, &BitPos);
;;;1289   //               diff = LogAddr - oLogAddr;
;;;1290   //               oLogAddr = LogAddr;
;;;1291   //               if ((segmentsize + diff) > (EC_MAXLRWDATA - EC_FIRSTDCDATAGRAM))
;;;1292   //               {
;;;1293   //                  context->grouplist[group].IOsegment[currentsegment] = segmentsize;
;;;1294   //                  if (currentsegment < (EC_MAXIOSEGMENTS - 1))
;;;1295   //                  {
;;;1296   //                     currentsegment++;
;;;1297   //                     segmentsize = diff;
;;;1298   //                  }
;;;1299   //               }
;;;1300   //               else
;;;1301   //               {
;;;1302   //                  segmentsize += diff;
;;;1303   //               }
;;;1304   //            }
;;;1305   //         }   
;;;1306   //      }
;;;1307   //     if (BitPos)
;;;1308   //      {
;;;1309   //         LogAddr++;
;;;1310   //         oLogAddr = LogAddr;
;;;1311   //         BitPos = 0;
;;;1312   //         if ((segmentsize + 1) > (EC_MAXLRWDATA - EC_FIRSTDCDATAGRAM))
;;;1313   //         {
;;;1314   //            context->grouplist[group].IOsegment[currentsegment] = segmentsize;
;;;1315   //            if (currentsegment < (EC_MAXIOSEGMENTS - 1))
;;;1316   //            {
;;;1317   //               currentsegment++;
;;;1318   //               segmentsize = 1;
;;;1319   //            }
;;;1320   //         }
;;;1321   //         else
;;;1322   //         {
;;;1323   //            segmentsize += 1;
;;;1324   //         }
;;;1325   //      }
;;;1326   //      context->grouplist[group].outputs = pIOmap;
;;;1327   //      context->grouplist[group].Obytes = LogAddr - context->grouplist[group].logstartaddr;
;;;1328   //      context->grouplist[group].nsegments = currentsegment + 1;
;;;1329   //      context->grouplist[group].Isegment = currentsegment;
;;;1330   //      context->grouplist[group].Ioffset = segmentsize;
;;;1331   //      if (!group)
;;;1332   //      {
;;;1333   //         context->slavelist[0].outputs = pIOmap;
;;;1334   //         context->slavelist[0].Obytes = LogAddr - 
;;;1335   //            context->grouplist[group].logstartaddr; /* store output bytes in master record */
;;;1336   //      }
;;;1337         /* do input mapping of slave and program FMMUs */
;;;1338         for (slave = 1; slave <= *(context->slavecount); slave++)
001240  2001              MOVS     r0,#1
001242  e1f4              B        |L1.5678|
                  |L1.4676|
;;;1339         {
;;;1340            configadr = context->slavelist[slave].configadr;
001244  9903              LDR      r1,[sp,#0xc]
001246  6860              LDR      r0,[r4,#4]
001248  eb0102c1          ADD      r2,r1,r1,LSL #3
00124c  eb021681          ADD      r6,r2,r1,LSL #6
001250  2104              MOVS     r1,#4
001252  eb010186          ADD      r1,r1,r6,LSL #2
001256  5a41              LDRH     r1,[r0,r1]
;;;1341   
;;;1342            if (!group || (group == context->slavelist[slave].group))
001258  9108              STR      r1,[sp,#0x20]
00125a  9912              LDR      r1,[sp,#0x48]
00125c  b139              CBZ      r1,|L1.4718|
00125e  f2401103          MOV      r1,#0x103
001262  eb010186          ADD      r1,r1,r6,LSL #2
001266  5c42              LDRB     r2,[r0,r1]
001268  9912              LDR      r1,[sp,#0x48]
00126a  428a              CMP      r2,r1
00126c  d113              BNE      |L1.4758|
                  |L1.4718|
;;;1343            {   
;;;1344               FMMUc = context->slavelist[slave].FMMUunused;
00126e  f44f7182          MOV      r1,#0x104
001272  eb010186          ADD      r1,r1,r6,LSL #2
001276  910d              STR      r1,[sp,#0x34]
001278  f8108001          LDRB     r8,[r0,r1]
;;;1345               SMc = 0;
00127c  2700              MOVS     r7,#0
;;;1346               BitCount = 0;
;;;1347               ByteCount = 0;
;;;1348               EndAddr = 0;
;;;1349               FMMUsize = 0;
;;;1350               FMMUdone = 0;
;;;1351               /* create output mapping */
;;;1352               if (context->slavelist[slave].Obits)
00127e  2118              MOVS     r1,#0x18
001280  eb010186          ADD      r1,r1,r6,LSL #2
001284  9704              STR      r7,[sp,#0x10]
001286  9706              STR      r7,[sp,#0x18]         ;1347
001288  9705              STR      r7,[sp,#0x14]         ;1350
00128a  9109              STR      r1,[sp,#0x24]
00128c  5a40              LDRH     r0,[r0,r1]
00128e  2800              CMP      r0,#0
001290  d001              BEQ      |L1.4758|
;;;1353               {
;;;1354                  EC_PRINT("  OUTPUT MAPPING\n");
001292  e069              B        |L1.4968|
                  |L1.4756|
001294  e3f1              B        |L1.6778|
                  |L1.4758|
001296  e1c5              B        |L1.5668|
                  |L1.4760|
001298  2020534d          DCB      "  SM programming\n",0
00129c  2070726f
0012a0  6772616d
0012a4  6d696e67
0012a8  0a00    
0012aa  00                DCB      0
0012ab  00                DCB      0
                  |L1.4780|
0012ac  20202020          DCB      "    SM0 Type:%d StartAddr:%4.4x Flags:%8.8x\n",0
0012b0  534d3020
0012b4  54797065
0012b8  3a256420
0012bc  53746172
0012c0  74416464
0012c4  723a2534
0012c8  2e347820
0012cc  466c6167
0012d0  733a2538
0012d4  2e38780a
0012d8  00      
0012d9  00                DCB      0
0012da  00                DCB      0
0012db  00                DCB      0
                  |L1.4828|
0012dc  20202020          DCB      "    SM1 Type:%d StartAddr:%4.4x Flags:%8.8x\n",0
0012e0  534d3120
0012e4  54797065
0012e8  3a256420
0012ec  53746172
0012f0  74416464
0012f4  723a2534
0012f8  2e347820
0012fc  466c6167
001300  733a2538
001304  2e38780a
001308  00      
001309  00                DCB      0
00130a  00                DCB      0
00130b  00                DCB      0
                  |L1.4876|
00130c  20202020          DCB      "    SM%d Type:%d StartAddr:%4.4x Flags:%8.8x\n",0
001310  534d2564
001314  20547970
001318  653a2564
00131c  20537461
001320  72744164
001324  64723a25
001328  342e3478
00132c  20466c61
001330  67733a25
001334  382e3878
001338  0a00    
00133a  00                DCB      0
00133b  00                DCB      0
                  |L1.4924|
                          DCD      ecx_context
                  |L1.4928|
001340  65635f63          DCB      "ec_config_map_group IOmap:%p group:%d\n",0
001344  6f6e6669
001348  675f6d61
00134c  705f6772
001350  6f757020
001354  494f6d61
001358  703a2570
00135c  2067726f
001360  75703a25
001364  640a00  
001367  00                DCB      0
                  |L1.4968|
001368  a0f8              ADR      r0,|L1.5964|
00136a  f7fffffe          BL       __2printf
;;;1355                  /* search for SM that contribute to the output mapping */
;;;1356                  while ( (SMc < (EC_MAXSM - 1)) && (FMMUdone < ((context->slavelist[slave].Obits + 7) / 8)))
00136e  e132              B        |L1.5590|
                  |L1.4976|
;;;1357                  {   
;;;1358                     EC_PRINT("    FMMU %d\n", FMMUc);
001370  4641              MOV      r1,r8
001372  a0fb              ADR      r0,|L1.5984|
001374  f7fffffe          BL       __2printf
;;;1359                     while ( (SMc < (EC_MAXSM - 1)) && (context->slavelist[slave].SMtype[SMc] != 3)) SMc++;
001378  e001              B        |L1.4990|
                  |L1.4986|
00137a  1c7f              ADDS     r7,r7,#1
00137c  b2ff              UXTB     r7,r7
                  |L1.4990|
00137e  2f07              CMP      r7,#7
001380  d207              BCS      |L1.5010|
001382  6860              LDR      r0,[r4,#4]
001384  eb000186          ADD      r1,r0,r6,LSL #2
001388  f1070074          ADD      r0,r7,#0x74
00138c  5c08              LDRB     r0,[r1,r0]
00138e  2803              CMP      r0,#3
001390  d1f3              BNE      |L1.4986|
                  |L1.5010|
;;;1360                     EC_PRINT("      SM%d\n", SMc);
001392  4639              MOV      r1,r7
001394  a0f6              ADR      r0,|L1.6000|
001396  f7fffffe          BL       __2printf
;;;1361                     context->slavelist[slave].FMMU[FMMUc].PhysStart = 
00139a  6860              LDR      r0,[r4,#4]
00139c  2134              MOVS     r1,#0x34
00139e  eb000086          ADD      r0,r0,r6,LSL #2
0013a2  eb0101c7          ADD      r1,r1,r7,LSL #3
0013a6  2384              MOVS     r3,#0x84
0013a8  f830c001          LDRH     r12,[r0,r1]
0013ac  eb031208          ADD      r2,r3,r8,LSL #4
0013b0  f820c002          STRH     r12,[r0,r2]
;;;1362                        context->slavelist[slave].SM[SMc].StartAddr;
;;;1363                     SMlength = etohs(context->slavelist[slave].SM[SMc].SMlength);
0013b4  6860              LDR      r0,[r4,#4]
;;;1364                     ByteCount += SMlength;
0013b6  9b05              LDR      r3,[sp,#0x14]
0013b8  eb000286          ADD      r2,r0,r6,LSL #2       ;1363
0013bc  2036              MOVS     r0,#0x36              ;1363
0013be  eb0000c7          ADD      r0,r0,r7,LSL #3       ;1363
0013c2  5a10              LDRH     r0,[r2,r0]            ;1363
0013c4  4403              ADD      r3,r3,r0
;;;1365                     BitCount += SMlength * 8;
0013c6  9305              STR      r3,[sp,#0x14]
0013c8  9b06              LDR      r3,[sp,#0x18]
0013ca  eb0303c0          ADD      r3,r3,r0,LSL #3
;;;1366                     EndAddr = etohs(context->slavelist[slave].SM[SMc].StartAddr) + SMlength;
0013ce  9306              STR      r3,[sp,#0x18]
0013d0  5a51              LDRH     r1,[r2,r1]
;;;1367                     while ( (BitCount < context->slavelist[slave].Obits) && (SMc < (EC_MAXSM - 1)) ) /* more SM for output */
0013d2  e028              B        |L1.5158|
                  |L1.5076|
0013d4  1c7f              ADDS     r7,r7,#1
;;;1368                     {
;;;1369                        SMc++;
0013d6  b2ff              UXTB     r7,r7
0013d8  eb000186          ADD      r1,r0,r6,LSL #2       ;1359
;;;1370                        while ( (SMc < (EC_MAXSM - 1)) && (context->slavelist[slave].SMtype[SMc] != 3)) SMc++;
0013dc  e001              B        |L1.5090|
                  |L1.5086|
0013de  1c7f              ADDS     r7,r7,#1
0013e0  b2ff              UXTB     r7,r7
                  |L1.5090|
0013e2  2f07              CMP      r7,#7
0013e4  d204              BCS      |L1.5104|
0013e6  f1070274          ADD      r2,r7,#0x74
0013ea  5c8a              LDRB     r2,[r1,r2]
0013ec  2a03              CMP      r2,#3
0013ee  d1f6              BNE      |L1.5086|
                  |L1.5104|
;;;1371                        /* if addresses from more SM connect use one FMMU otherwise break up in mutiple FMMU */
;;;1372                        if ( etohs(context->slavelist[slave].SM[SMc].StartAddr) > EndAddr ) 
0013f0  2234              MOVS     r2,#0x34
0013f2  eb0202c7          ADD      r2,r2,r7,LSL #3
0013f6  9200              STR      r2,[sp,#0]
0013f8  5a89              LDRH     r1,[r1,r2]
0013fa  4299              CMP      r1,r3
0013fc  d81d              BHI      |L1.5178|
;;;1373                        {
;;;1374                           break;
;;;1375                        }
;;;1376                        EC_PRINT("      SM%d\n", SMc);
0013fe  4639              MOV      r1,r7
001400  a0db              ADR      r0,|L1.6000|
001402  f7fffffe          BL       __2printf
;;;1377                        SMlength = etohs(context->slavelist[slave].SM[SMc].SMlength);
001406  6860              LDR      r0,[r4,#4]
;;;1378                        ByteCount += SMlength;
001408  9a05              LDR      r2,[sp,#0x14]
00140a  eb000186          ADD      r1,r0,r6,LSL #2       ;1377
00140e  2036              MOVS     r0,#0x36              ;1377
001410  eb0000c7          ADD      r0,r0,r7,LSL #3       ;1377
001414  5a08              LDRH     r0,[r1,r0]            ;1377
001416  4402              ADD      r2,r2,r0
;;;1379                        BitCount += SMlength * 8;
001418  9205              STR      r2,[sp,#0x14]
00141a  9a06              LDR      r2,[sp,#0x18]
00141c  eb0202c0          ADD      r2,r2,r0,LSL #3
001420  9206              STR      r2,[sp,#0x18]
;;;1380                        EndAddr = etohs(context->slavelist[slave].SM[SMc].StartAddr) + SMlength;               
001422  9a00              LDR      r2,[sp,#0]
001424  5a89              LDRH     r1,[r1,r2]
                  |L1.5158|
001426  4408              ADD      r0,r0,r1              ;1366
001428  b283              UXTH     r3,r0                 ;1366
00142a  6860              LDR      r0,[r4,#4]            ;1367
00142c  9909              LDR      r1,[sp,#0x24]         ;1367
00142e  5a42              LDRH     r2,[r0,r1]            ;1367
001430  9906              LDR      r1,[sp,#0x18]         ;1367
001432  428a              CMP      r2,r1                 ;1367
001434  dd01              BLE      |L1.5178|
001436  2f07              CMP      r7,#7                 ;1367
001438  d3cc              BCC      |L1.5076|
                  |L1.5178|
;;;1381                     }   
;;;1382   
;;;1383                     /* bit oriented slave */
;;;1384                     if (!context->slavelist[slave].Obytes)
00143a  211c              MOVS     r1,#0x1c
00143c  6862              LDR      r2,[r4,#4]
00143e  eb010186          ADD      r1,r1,r6,LSL #2
001442  5852              LDR      r2,[r2,r1]
001444  b3f2              CBZ      r2,|L1.5316|
;;;1385                     {   
;;;1386                        context->slavelist[slave].FMMU[FMMUc].LogStart = htoel(LogAddr);
;;;1387                        context->slavelist[slave].FMMU[FMMUc].LogStartbit = BitPos;
;;;1388                        BitPos += context->slavelist[slave].Obits - 1;
;;;1389                        if (BitPos > 7)
;;;1390                        {
;;;1391                           LogAddr++;
;;;1392                           BitPos -= 8;
;;;1393                        }   
;;;1394                        FMMUsize = LogAddr - etohl(context->slavelist[slave].FMMU[FMMUc].LogStart) + 1;
;;;1395                        context->slavelist[slave].FMMU[FMMUc].LogLength = htoes(FMMUsize);
;;;1396                        context->slavelist[slave].FMMU[FMMUc].LogEndbit = BitPos;
;;;1397                        BitPos ++;
;;;1398                        if (BitPos > 7)
;;;1399                        {
;;;1400                           LogAddr++;
;;;1401                           BitPos -= 8;
;;;1402                        }   
;;;1403                     }
;;;1404                     /* byte oriented slave */
;;;1405                     else
;;;1406                     {
;;;1407                        if (BitPos)
001446  f1b90f00          CMP      r9,#0
00144a  d002              BEQ      |L1.5202|
;;;1408                        {
;;;1409                           LogAddr++;
;;;1410                           BitPos = 0;
00144c  f04f0900          MOV      r9,#0
001450  1c6d              ADDS     r5,r5,#1
                  |L1.5202|
;;;1411                        }   
;;;1412                        context->slavelist[slave].FMMU[FMMUc].LogStart = htoel(LogAddr);
001452  eb000386          ADD      r3,r0,r6,LSL #2
001456  227c              MOVS     r2,#0x7c
001458  eb021008          ADD      r0,r2,r8,LSL #4
00145c  501d              STR      r5,[r3,r0]
;;;1413                        context->slavelist[slave].FMMU[FMMUc].LogStartbit = BitPos;
00145e  6862              LDR      r2,[r4,#4]
001460  2382              MOVS     r3,#0x82
001462  eb020c86          ADD      r12,r2,r6,LSL #2
001466  eb031208          ADD      r2,r3,r8,LSL #4
;;;1414                        BitPos = 7;
00146a  2307              MOVS     r3,#7
00146c  f80c9002          STRB     r9,[r12,r2]           ;1413
;;;1415                        FMMUsize = ByteCount;
;;;1416                        if ((FMMUsize + FMMUdone)> (int)context->slavelist[slave].Obytes)
001470  6862              LDR      r2,[r4,#4]
001472  9805              LDR      r0,[sp,#0x14]
001474  f8ddc010          LDR      r12,[sp,#0x10]
001478  5851              LDR      r1,[r2,r1]
00147a  4484              ADD      r12,r12,r0
00147c  4561              CMP      r1,r12
00147e  da01              BGE      |L1.5252|
;;;1417                        {
;;;1418                           FMMUsize = context->slavelist[slave].Obytes - FMMUdone;
001480  9804              LDR      r0,[sp,#0x10]
001482  1a08              SUBS     r0,r1,r0
                  |L1.5252|
;;;1419                        }
;;;1420                        LogAddr += FMMUsize;
;;;1421                        context->slavelist[slave].FMMU[FMMUc].LogLength = htoes(FMMUsize);
001484  eb020c86          ADD      r12,r2,r6,LSL #2
001488  2280              MOVS     r2,#0x80
00148a  eb021108          ADD      r1,r2,r8,LSL #4
00148e  f82c0001          STRH     r0,[r12,r1]
;;;1422                        context->slavelist[slave].FMMU[FMMUc].LogEndbit = BitPos;
001492  6861              LDR      r1,[r4,#4]
001494  2283              MOVS     r2,#0x83
001496  eb010c86          ADD      r12,r1,r6,LSL #2
00149a  eb021108          ADD      r1,r2,r8,LSL #4
00149e  4405              ADD      r5,r5,r0              ;1420
0014a0  f80c3001          STRB     r3,[r12,r1]
;;;1423                        BitPos = 0;
0014a4  f04f0900          MOV      r9,#0
                  |L1.5288|
;;;1424                     }
;;;1425                     FMMUdone += FMMUsize;
0014a8  9904              LDR      r1,[sp,#0x10]
;;;1426                     context->slavelist[slave].FMMU[FMMUc].PhysStartBit = 0;
0014aa  2286              MOVS     r2,#0x86
0014ac  4408              ADD      r0,r0,r1              ;1425
0014ae  9004              STR      r0,[sp,#0x10]
0014b0  6861              LDR      r1,[r4,#4]
0014b2  2000              MOVS     r0,#0
0014b4  eb010386          ADD      r3,r1,r6,LSL #2
0014b8  eb021108          ADD      r1,r2,r8,LSL #4
;;;1427                     context->slavelist[slave].FMMU[FMMUc].FMMUtype = 2;
0014bc  2202              MOVS     r2,#2
0014be  5458              STRB     r0,[r3,r1]            ;1426
0014c0  6860              LDR      r0,[r4,#4]
0014c2  e000              B        |L1.5318|
                  |L1.5316|
0014c4  e02f              B        |L1.5414|
                  |L1.5318|
0014c6  eb000386          ADD      r3,r0,r6,LSL #2
0014ca  2087              MOVS     r0,#0x87
0014cc  eb001008          ADD      r0,r0,r8,LSL #4
0014d0  541a              STRB     r2,[r3,r0]
;;;1428                     context->slavelist[slave].FMMU[FMMUc].FMMUactive = 1;
0014d2  6861              LDR      r1,[r4,#4]
0014d4  2288              MOVS     r2,#0x88
0014d6  eb010386          ADD      r3,r1,r6,LSL #2
0014da  eb021108          ADD      r1,r2,r8,LSL #4
0014de  2001              MOVS     r0,#1
0014e0  5458              STRB     r0,[r3,r1]
;;;1429                     /* program FMMU for output */
;;;1430                     ecx_FPWR(context->port, configadr, ECT_REG_FMMU0 + (sizeof(ec_fmmut) * FMMUc),
0014e2  6860              LDR      r0,[r4,#4]
0014e4  f2417270          MOV      r2,#0x1770
0014e8  eb000386          ADD      r3,r0,r6,LSL #2
0014ec  207c              MOVS     r0,#0x7c
0014ee  eb001008          ADD      r0,r0,r8,LSL #4
0014f2  900e              STR      r0,[sp,#0x38]
0014f4  4418              ADD      r0,r0,r3
0014f6  e9cd0200          STRD     r0,r2,[sp,#0]
0014fa  f44f61c0          MOV      r1,#0x600
0014fe  eb011208          ADD      r2,r1,r8,LSL #4
001502  2310              MOVS     r3,#0x10
001504  6820              LDR      r0,[r4,#0]
001506  9908              LDR      r1,[sp,#0x20]
001508  f7fffffe          BL       ecx_FPWR
;;;1431                        sizeof(ec_fmmut), &(context->slavelist[slave].FMMU[FMMUc]), EC_TIMEOUTRET3);
;;;1432                     context->grouplist[group].outputsWKC++;
00150c  6920              LDR      r0,[r4,#0x10]
00150e  990c              LDR      r1,[sp,#0x30]
001510  9a0c              LDR      r2,[sp,#0x30]
001512  5a41              LDRH     r1,[r0,r1]
001514  1c49              ADDS     r1,r1,#1
001516  5281              STRH     r1,[r0,r2]
;;;1433                     if (!context->slavelist[slave].outputs)
001518  2020              MOVS     r0,#0x20
00151a  6861              LDR      r1,[r4,#4]
00151c  eb000086          ADD      r0,r0,r6,LSL #2
001520  580a              LDR      r2,[r1,r0]
001522  b3c2              CBZ      r2,|L1.5526|
001524  e051              B        |L1.5578|
                  |L1.5414|
001526  eb000286          ADD      r2,r0,r6,LSL #2       ;1386
00152a  207c              MOVS     r0,#0x7c              ;1386
00152c  eb001008          ADD      r0,r0,r8,LSL #4       ;1386
001530  2382              MOVS     r3,#0x82              ;1387
001532  5015              STR      r5,[r2,r0]            ;1386
001534  6861              LDR      r1,[r4,#4]            ;1387
001536  eb010c86          ADD      r12,r1,r6,LSL #2      ;1387
00153a  eb031108          ADD      r1,r3,r8,LSL #4       ;1387
00153e  f80c9001          STRB     r9,[r12,r1]           ;1387
001542  6862              LDR      r2,[r4,#4]            ;1388
001544  9909              LDR      r1,[sp,#0x24]         ;1388
001546  5c53              LDRB     r3,[r2,r1]            ;1388
001548  f1a90101          SUB      r1,r9,#1              ;1388
00154c  4419              ADD      r1,r1,r3              ;1388
00154e  b2c9              UXTB     r1,r1                 ;1388
001550  2907              CMP      r1,#7                 ;1389
001552  d902              BLS      |L1.5466|
001554  3908              SUBS     r1,r1,#8              ;1389
001556  b2c9              UXTB     r1,r1                 ;1392
001558  1c6d              ADDS     r5,r5,#1              ;1392
                  |L1.5466|
00155a  eb020286          ADD      r2,r2,r6,LSL #2       ;1394
00155e  f04f0c80          MOV      r12,#0x80             ;1395
001562  5810              LDR      r0,[r2,r0]            ;1394
001564  eb0c1308          ADD      r3,r12,r8,LSL #4      ;1395
001568  1a28              SUBS     r0,r5,r0              ;1394
00156a  1c40              ADDS     r0,r0,#1              ;1395
00156c  52d0              STRH     r0,[r2,r3]            ;1395
00156e  6862              LDR      r2,[r4,#4]            ;1396
001570  2383              MOVS     r3,#0x83              ;1396
001572  eb020c86          ADD      r12,r2,r6,LSL #2      ;1396
001576  eb031208          ADD      r2,r3,r8,LSL #4       ;1396
00157a  f80c1002          STRB     r1,[r12,r2]           ;1396
00157e  1c49              ADDS     r1,r1,#1              ;1396
001580  f00109ff          AND      r9,r1,#0xff           ;1397
001584  f1b90f07          CMP      r9,#7                 ;1398
001588  d98e              BLS      |L1.5288|
00158a  f1a90108          SUB      r1,r9,#8              ;1401
00158e  f00109ff          AND      r9,r1,#0xff           ;1401
001592  1c6d              ADDS     r5,r5,#1              ;1401
001594  e788              B        |L1.5288|
                  |L1.5526|
001596  e7ff              B        |L1.5528|
                  |L1.5528|
;;;1434                     {   
;;;1435                        context->slavelist[slave].outputs = 
001598  9a0e              LDR      r2,[sp,#0x38]
00159a  eb010386          ADD      r3,r1,r6,LSL #2
00159e  589b              LDR      r3,[r3,r2]
0015a0  9a11              LDR      r2,[sp,#0x44]
0015a2  441a              ADD      r2,r2,r3
0015a4  500a              STR      r2,[r1,r0]
;;;1436                           (uint8 *)(pIOmap) + etohl(context->slavelist[slave].FMMU[FMMUc].LogStart);
;;;1437                        context->slavelist[slave].Ostartbit = 
0015a6  6861              LDR      r1,[r4,#4]
0015a8  2382              MOVS     r3,#0x82
0015aa  eb010c86          ADD      r12,r1,r6,LSL #2
0015ae  eb031208          ADD      r2,r3,r8,LSL #4
0015b2  f81c3002          LDRB     r3,[r12,r2]
0015b6  2224              MOVS     r2,#0x24
0015b8  eb020286          ADD      r2,r2,r6,LSL #2
0015bc  548b              STRB     r3,[r1,r2]
;;;1438                           context->slavelist[slave].FMMU[FMMUc].LogStartbit;
;;;1439                        EC_PRINT("    slave %d Outputs %p startbit %d\n", 
0015be  6861              LDR      r1,[r4,#4]
0015c0  580a              LDR      r2,[r1,r0]
0015c2  a06e              ADR      r0,|L1.6012|
0015c4  9903              LDR      r1,[sp,#0xc]
0015c6  f7fffffe          BL       __2printf
                  |L1.5578|
;;;1440                           slave, 
;;;1441                           context->slavelist[slave].outputs, 
;;;1442                           context->slavelist[slave].Ostartbit);
;;;1443                     }
;;;1444                     FMMUc++;
0015ca  f1080001          ADD      r0,r8,#1
0015ce  f00008ff          AND      r8,r0,#0xff
0015d2  2f07              CMP      r7,#7                 ;1356
0015d4  d208              BCS      |L1.5608|
                  |L1.5590|
0015d6  6861              LDR      r1,[r4,#4]            ;1356
0015d8  9809              LDR      r0,[sp,#0x24]         ;1356
0015da  5a08              LDRH     r0,[r1,r0]            ;1356
0015dc  9904              LDR      r1,[sp,#0x10]         ;1356
0015de  1dc0              ADDS     r0,r0,#7              ;1356
0015e0  ebb10fd0          CMP      r1,r0,LSR #3          ;1356
0015e4  f6ffaec4          BLT      |L1.4976|
                  |L1.5608|
;;;1445                  }   
;;;1446                  context->slavelist[slave].FMMUunused = FMMUc;
0015e8  6862              LDR      r2,[r4,#4]
0015ea  990d              LDR      r1,[sp,#0x34]
0015ec  f8028001          STRB     r8,[r2,r1]
;;;1447                  diff = LogAddr - oLogAddr;
0015f0  9807              LDR      r0,[sp,#0x1c]
;;;1448                  oLogAddr = LogAddr;
;;;1449                  if ((segmentsize + diff) > (EC_MAXLRWDATA - EC_FIRSTDCDATAGRAM))
0015f2  f24052ba          MOV      r2,#0x5ba
0015f6  1a28              SUBS     r0,r5,r0              ;1447
0015f8  eb0a0100          ADD      r1,r10,r0
0015fc  9507              STR      r5,[sp,#0x1c]
0015fe  4291              CMP      r1,r2
001600  d911              BLS      |L1.5670|
;;;1450                  {
;;;1451                     context->grouplist[group].IOsegment[currentsegment] = segmentsize;
001602  6923              LDR      r3,[r4,#0x10]
001604  9a02              LDR      r2,[sp,#8]
001606  2628              MOVS     r6,#0x28
001608  eb0303c2          ADD      r3,r3,r2,LSL #3
00160c  eb06028b          ADD      r2,r6,r11,LSL #2
;;;1452                     if (currentsegment < (EC_MAXIOSEGMENTS - 1))
001610  f1bb0f3f          CMP      r11,#0x3f
001614  f843a002          STR      r10,[r3,r2]           ;1451
001618  d206              BCS      |L1.5672|
;;;1453                     {
;;;1454                        currentsegment++;
00161a  f10b0101          ADD      r1,r11,#1
00161e  fa1ffb81          UXTH     r11,r1
;;;1455                        segmentsize = diff;   
001622  4682              MOV      r10,r0
                  |L1.5668|
001624  e000              B        |L1.5672|
                  |L1.5670|
;;;1456                     }
;;;1457                  }
;;;1458                  else
;;;1459                  {
;;;1460                     segmentsize += diff;
001626  468a              MOV      r10,r1
                  |L1.5672|
001628  9803              LDR      r0,[sp,#0xc]          ;1338
00162a  1c40              ADDS     r0,r0,#1              ;1338
00162c  b280              UXTH     r0,r0                 ;1338
                  |L1.5678|
00162e  9003              STR      r0,[sp,#0xc]          ;1338
001630  68a0              LDR      r0,[r4,#8]            ;1338
001632  6801              LDR      r1,[r0,#0]            ;1338
001634  9803              LDR      r0,[sp,#0xc]          ;1338
001636  4281              CMP      r1,r0                 ;1338
001638  f6bfae04          BGE      |L1.4676|
;;;1461                  }
;;;1462               }
;;;1463            }   
;;;1464         }
;;;1465         if (BitPos)
00163c  f1b90f00          CMP      r9,#0
001640  d01b              BEQ      |L1.5754|
001642  1c6d              ADDS     r5,r5,#1
;;;1466         {
;;;1467            LogAddr++;
;;;1468            oLogAddr = LogAddr;
;;;1469            BitPos = 0;
;;;1470            if ((segmentsize + 1) > (EC_MAXLRWDATA - EC_FIRSTDCDATAGRAM))
001644  f10a0001          ADD      r0,r10,#1
001648  f24051ba          MOV      r1,#0x5ba
00164c  f04f0900          MOV      r9,#0                 ;1469
001650  9507              STR      r5,[sp,#0x1c]
001652  4288              CMP      r0,r1
001654  d935              BLS      |L1.5826|
;;;1471            {
;;;1472               context->grouplist[group].IOsegment[currentsegment] = segmentsize;
001656  6922              LDR      r2,[r4,#0x10]
001658  9902              LDR      r1,[sp,#8]
00165a  2328              MOVS     r3,#0x28
00165c  eb0202c1          ADD      r2,r2,r1,LSL #3
001660  eb03018b          ADD      r1,r3,r11,LSL #2
;;;1473               if (currentsegment < (EC_MAXIOSEGMENTS - 1))
001664  f1bb0f3f          CMP      r11,#0x3f
001668  f842a001          STR      r10,[r2,r1]           ;1472
00166c  d205              BCS      |L1.5754|
;;;1474               {
;;;1475                  currentsegment++;
00166e  f10b0001          ADD      r0,r11,#1
001672  fa1ffb80          UXTH     r11,r0
;;;1476                  segmentsize = 1;   
001676  2001              MOVS     r0,#1
                  |L1.5752|
;;;1477               }
;;;1478            }
;;;1479            else
;;;1480            {
;;;1481               segmentsize += 1;
001678  4682              MOV      r10,r0
                  |L1.5754|
;;;1482            }
;;;1483         }   
;;;1484         context->grouplist[group].outputs = pIOmap;
00167a  9902              LDR      r1,[sp,#8]
00167c  6922              LDR      r2,[r4,#0x10]
00167e  2308              MOVS     r3,#8
001680  eb0301c1          ADD      r1,r3,r1,LSL #3
001684  9811              LDR      r0,[sp,#0x44]
001686  5050              STR      r0,[r2,r1]
;;;1485         context->grouplist[group].Obytes = LogAddr;
001688  9802              LDR      r0,[sp,#8]
00168a  6922              LDR      r2,[r4,#0x10]
00168c  2104              MOVS     r1,#4
00168e  eb0100c0          ADD      r0,r1,r0,LSL #3
001692  900c              STR      r0,[sp,#0x30]
001694  5015              STR      r5,[r2,r0]
;;;1486         context->grouplist[group].nsegments = currentsegment + 1;
001696  6923              LDR      r3,[r4,#0x10]
001698  9a0b              LDR      r2,[sp,#0x2c]
00169a  f10b0001          ADD      r0,r11,#1
00169e  5298              STRH     r0,[r3,r2]
;;;1487         context->grouplist[group].Isegment = currentsegment;
0016a0  6923              LDR      r3,[r4,#0x10]
0016a2  9802              LDR      r0,[sp,#8]
0016a4  261e              MOVS     r6,#0x1e
0016a6  eb0600c0          ADD      r0,r6,r0,LSL #3
0016aa  f823b000          STRH     r11,[r3,r0]
;;;1488         context->grouplist[group].Ioffset = segmentsize;
0016ae  6926              LDR      r6,[r4,#0x10]
0016b0  9a02              LDR      r2,[sp,#8]
0016b2  2320              MOVS     r3,#0x20
0016b4  eb0302c2          ADD      r2,r3,r2,LSL #3
0016b8  f826a002          STRH     r10,[r6,r2]
;;;1489         if (!group)
0016bc  9812              LDR      r0,[sp,#0x48]
0016be  b118              CBZ      r0,|L1.5832|
0016c0  e007              B        |L1.5842|
                  |L1.5826|
0016c2  f10a0001          ADD      r0,r10,#1             ;1481
0016c6  e7d7              B        |L1.5752|
                  |L1.5832|
;;;1490         {   
;;;1491            context->slavelist[0].outputs = pIOmap;
0016c8  6862              LDR      r2,[r4,#4]
0016ca  9811              LDR      r0,[sp,#0x44]
;;;1492            context->slavelist[0].Obytes = LogAddr; /* store output bytes in master record */
0016cc  6210              STR      r0,[r2,#0x20]
0016ce  6860              LDR      r0,[r4,#4]
0016d0  61c5              STR      r5,[r0,#0x1c]
                  |L1.5842|
;;;1493         }  
;;;1494   			
;;;1495   			      for (slave = 1; slave <= *(context->slavecount); slave++)
0016d2  2001              MOVS     r0,#1
0016d4  e206              B        |L1.6884|
                  |L1.5846|
;;;1496         {
;;;1497            configadr = context->slavelist[slave].configadr;
0016d6  9903              LDR      r1,[sp,#0xc]
0016d8  6860              LDR      r0,[r4,#4]
0016da  eb0102c1          ADD      r2,r1,r1,LSL #3
0016de  eb021681          ADD      r6,r2,r1,LSL #6
0016e2  2104              MOVS     r1,#4
0016e4  eb010186          ADD      r1,r1,r6,LSL #2
0016e8  5a41              LDRH     r1,[r0,r1]
;;;1498            if (!group || (group == context->slavelist[slave].group))
0016ea  9108              STR      r1,[sp,#0x20]
0016ec  9912              LDR      r1,[sp,#0x48]
0016ee  b139              CBZ      r1,|L1.5888|
0016f0  f2401103          MOV      r1,#0x103
0016f4  eb010186          ADD      r1,r1,r6,LSL #2
0016f8  5c42              LDRB     r2,[r0,r1]
0016fa  9912              LDR      r1,[sp,#0x48]
0016fc  428a              CMP      r2,r1
0016fe  d17d              BNE      |L1.6140|
                  |L1.5888|
;;;1499            {
;;;1500               FMMUc = context->slavelist[slave].FMMUunused;
001700  f44f7182          MOV      r1,#0x104
001704  eb010186          ADD      r1,r1,r6,LSL #2
001708  910d              STR      r1,[sp,#0x34]
00170a  5c47              LDRB     r7,[r0,r1]
;;;1501               if (context->slavelist[slave].Obits) /* find free FMMU */
00170c  2118              MOVS     r1,#0x18
00170e  eb010186          ADD      r1,r1,r6,LSL #2
001712  5a41              LDRH     r1,[r0,r1]
001714  b149              CBZ      r1,|L1.5930|
001716  227c              MOVS     r2,#0x7c              ;1386
001718  eb000186          ADD      r1,r0,r6,LSL #2       ;1359
                  |L1.5916|
;;;1502               {
;;;1503                  while ( context->slavelist[slave].FMMU[FMMUc].LogStart ) FMMUc++;
00171c  eb021307          ADD      r3,r2,r7,LSL #4
001720  58cb              LDR      r3,[r1,r3]
001722  b113              CBZ      r3,|L1.5930|
001724  1c7f              ADDS     r7,r7,#1
001726  b2ff              UXTB     r7,r7
001728  e7f8              B        |L1.5916|
                  |L1.5930|
;;;1504               }
;;;1505               SMc = 0;
00172a  f04f0800          MOV      r8,#0
;;;1506               BitCount = 0;
;;;1507               ByteCount = 0;
;;;1508               EndAddr = 0;
;;;1509               FMMUsize = 0;
;;;1510               FMMUdone = 0;
;;;1511               /* create input mapping */
;;;1512               if (context->slavelist[slave].Ibits)
00172e  2126              MOVS     r1,#0x26
001730  eb010186          ADD      r1,r1,r6,LSL #2
001734  f8cd8010          STR      r8,[sp,#0x10]
001738  f8cd8018          STR      r8,[sp,#0x18]         ;1507
00173c  f8cd8014          STR      r8,[sp,#0x14]         ;1510
001740  9109              STR      r1,[sp,#0x24]
001742  5a40              LDRH     r0,[r0,r1]
001744  2800              CMP      r0,#0
001746  d070              BEQ      |L1.6186|
;;;1513               {
;;;1514                  EC_PRINT(" =Slave %d, INPUT MAPPING\n", slave);
001748  e02c              B        |L1.6052|
00174a  0000              DCW      0x0000
                  |L1.5964|
00174c  20204f55          DCB      "  OUTPUT MAPPING\n",0
001750  54505554
001754  204d4150
001758  50494e47
00175c  0a00    
00175e  00                DCB      0
00175f  00                DCB      0
                  |L1.5984|
001760  20202020          DCB      "    FMMU %d\n",0
001764  464d4d55
001768  2025640a
00176c  00      
00176d  00                DCB      0
00176e  00                DCB      0
00176f  00                DCB      0
                  |L1.6000|
001770  20202020          DCB      "      SM%d\n",0
001774  2020534d
001778  25640a00
                  |L1.6012|
00177c  20202020          DCB      "    slave %d Outputs %p startbit %d\n",0
001780  736c6176
001784  65202564
001788  204f7574
00178c  70757473
001790  20257020
001794  73746172
001798  74626974
00179c  2025640a
0017a0  00      
0017a1  00                DCB      0
0017a2  00                DCB      0
0017a3  00                DCB      0
                  |L1.6052|
0017a4  a0fe              ADR      r0,|L1.7072|
0017a6  9903              LDR      r1,[sp,#0xc]
0017a8  f7fffffe          BL       __2printf
;;;1515                  /* search for SM that contribute to the input mapping */
;;;1516                  while ( (SMc < (EC_MAXSM - 1)) && (FMMUdone < ((context->slavelist[slave].Ibits + 7) / 8)))
0017ac  e13e              B        |L1.6700|
                  |L1.6062|
;;;1517                  {   
;;;1518                     EC_PRINT("    FMMU %d\n", FMMUc);
0017ae  4639              MOV      r1,r7
0017b0  f2af0054          ADR      r0,|L1.5984|
0017b4  f7fffffe          BL       __2printf
;;;1519                     while ( (SMc < (EC_MAXSM - 1)) && (context->slavelist[slave].SMtype[SMc] != 4)) SMc++;
0017b8  e003              B        |L1.6082|
                  |L1.6074|
0017ba  f1080001          ADD      r0,r8,#1
0017be  f00008ff          AND      r8,r0,#0xff
                  |L1.6082|
0017c2  f1b80f07          CMP      r8,#7
0017c6  d207              BCS      |L1.6104|
0017c8  6860              LDR      r0,[r4,#4]
0017ca  eb000186          ADD      r1,r0,r6,LSL #2
0017ce  f1080074          ADD      r0,r8,#0x74
0017d2  5c08              LDRB     r0,[r1,r0]
0017d4  2804              CMP      r0,#4
0017d6  d1f0              BNE      |L1.6074|
                  |L1.6104|
;;;1520                     EC_PRINT("      SM%d\n", SMc);
0017d8  4641              MOV      r1,r8
0017da  f2af006c          ADR      r0,|L1.6000|
0017de  f7fffffe          BL       __2printf
;;;1521                     context->slavelist[slave].FMMU[FMMUc].PhysStart = 
0017e2  6860              LDR      r0,[r4,#4]
0017e4  2134              MOVS     r1,#0x34
0017e6  eb000086          ADD      r0,r0,r6,LSL #2
0017ea  eb0101c8          ADD      r1,r1,r8,LSL #3
0017ee  2284              MOVS     r2,#0x84
0017f0  5a43              LDRH     r3,[r0,r1]
0017f2  eb021207          ADD      r2,r2,r7,LSL #4
0017f6  5283              STRH     r3,[r0,r2]
;;;1522                        context->slavelist[slave].SM[SMc].StartAddr;
;;;1523                     SMlength = etohs(context->slavelist[slave].SM[SMc].SMlength);
0017f8  6860              LDR      r0,[r4,#4]
0017fa  e000              B        |L1.6142|
                  |L1.6140|
0017fc  e16f              B        |L1.6878|
                  |L1.6142|
0017fe  eb000286          ADD      r2,r0,r6,LSL #2
001802  2336              MOVS     r3,#0x36
001804  eb0300c8          ADD      r0,r3,r8,LSL #3
001808  5a10              LDRH     r0,[r2,r0]
;;;1524                     ByteCount += SMlength;
00180a  9b05              LDR      r3,[sp,#0x14]
00180c  4403              ADD      r3,r3,r0
;;;1525                     BitCount += SMlength * 8;
00180e  9305              STR      r3,[sp,#0x14]
001810  9b06              LDR      r3,[sp,#0x18]
001812  eb0303c0          ADD      r3,r3,r0,LSL #3
;;;1526                     EndAddr = etohs(context->slavelist[slave].SM[SMc].StartAddr) + SMlength;
001816  9306              STR      r3,[sp,#0x18]
001818  5a51              LDRH     r1,[r2,r1]
;;;1527                     while ( (BitCount < context->slavelist[slave].Ibits) && (SMc < (EC_MAXSM - 1)) ) /* more SM for input */
00181a  e030              B        |L1.6270|
                  |L1.6172|
;;;1528                     {
;;;1529                        SMc++;
00181c  f1080101          ADD      r1,r8,#1
001820  f00108ff          AND      r8,r1,#0xff
001824  eb000186          ADD      r1,r0,r6,LSL #2       ;1359
;;;1530                        while ( (SMc < (EC_MAXSM - 1)) && (context->slavelist[slave].SMtype[SMc] != 4)) SMc++;
001828  e004              B        |L1.6196|
                  |L1.6186|
00182a  e125              B        |L1.6776|
                  |L1.6188|
00182c  f1080201          ADD      r2,r8,#1
001830  f00208ff          AND      r8,r2,#0xff
                  |L1.6196|
001834  f1b80f07          CMP      r8,#7
001838  d204              BCS      |L1.6212|
00183a  f1080274          ADD      r2,r8,#0x74
00183e  5c8a              LDRB     r2,[r1,r2]
001840  2a04              CMP      r2,#4
001842  d1f3              BNE      |L1.6188|
                  |L1.6212|
;;;1531                        /* if addresses from more SM connect use one FMMU otherwise break up in mutiple FMMU */
;;;1532                        if ( etohs(context->slavelist[slave].SM[SMc].StartAddr) > EndAddr ) 
001844  2234              MOVS     r2,#0x34
001846  eb0202c8          ADD      r2,r2,r8,LSL #3
00184a  9200              STR      r2,[sp,#0]
00184c  5a89              LDRH     r1,[r1,r2]
00184e  46c4              MOV      r12,r8
001850  4299              CMP      r1,r3
001852  d81f              BHI      |L1.6292|
;;;1533                        {
;;;1534                           break;
;;;1535                        }
;;;1536                        EC_PRINT("      SM%d\n", SMc);
001854  4661              MOV      r1,r12
001856  f2af00e8          ADR      r0,|L1.6000|
00185a  f7fffffe          BL       __2printf
;;;1537                        SMlength = etohs(context->slavelist[slave].SM[SMc].SMlength);
00185e  6860              LDR      r0,[r4,#4]
001860  2236              MOVS     r2,#0x36
001862  eb000186          ADD      r1,r0,r6,LSL #2
001866  eb0200c8          ADD      r0,r2,r8,LSL #3
00186a  5a08              LDRH     r0,[r1,r0]
;;;1538                        ByteCount += SMlength;
00186c  9a05              LDR      r2,[sp,#0x14]
00186e  4402              ADD      r2,r2,r0
;;;1539                        BitCount += SMlength * 8;
001870  9205              STR      r2,[sp,#0x14]
001872  9a06              LDR      r2,[sp,#0x18]
001874  eb0202c0          ADD      r2,r2,r0,LSL #3
001878  9206              STR      r2,[sp,#0x18]
;;;1540                        EndAddr = etohs(context->slavelist[slave].SM[SMc].StartAddr) + SMlength;               
00187a  9a00              LDR      r2,[sp,#0]
00187c  5a89              LDRH     r1,[r1,r2]
                  |L1.6270|
00187e  4408              ADD      r0,r0,r1              ;1526
001880  b283              UXTH     r3,r0                 ;1526
001882  6860              LDR      r0,[r4,#4]            ;1527
001884  9909              LDR      r1,[sp,#0x24]         ;1527
001886  5a42              LDRH     r2,[r0,r1]            ;1527
001888  9906              LDR      r1,[sp,#0x18]         ;1527
00188a  428a              CMP      r2,r1                 ;1527
00188c  dd02              BLE      |L1.6292|
00188e  f1b80f07          CMP      r8,#7                 ;1527
001892  d3c3              BCC      |L1.6172|
                  |L1.6292|
;;;1541                     }   
;;;1542      
;;;1543                     /* bit oriented slave */
;;;1544                     if (!context->slavelist[slave].Ibytes)
001894  2128              MOVS     r1,#0x28
001896  6862              LDR      r2,[r4,#4]
001898  eb010186          ADD      r1,r1,r6,LSL #2
00189c  5852              LDR      r2,[r2,r1]
00189e  b3e2              CBZ      r2,|L1.6426|
;;;1545                     {   
;;;1546                        context->slavelist[slave].FMMU[FMMUc].LogStart = htoel(LogAddr);
;;;1547                        context->slavelist[slave].FMMU[FMMUc].LogStartbit = BitPos;
;;;1548                        BitPos += context->slavelist[slave].Ibits - 1;
;;;1549                        if (BitPos > 7)
;;;1550                        {
;;;1551                           LogAddr++;
;;;1552                           BitPos -= 8;
;;;1553                        }   
;;;1554                        FMMUsize = LogAddr - etohl(context->slavelist[slave].FMMU[FMMUc].LogStart) + 1;
;;;1555                        context->slavelist[slave].FMMU[FMMUc].LogLength = htoes(FMMUsize);
;;;1556                        context->slavelist[slave].FMMU[FMMUc].LogEndbit = BitPos;
;;;1557                        BitPos ++;
;;;1558                        if (BitPos > 7)
;;;1559                        {
;;;1560                           LogAddr++;
;;;1561                           BitPos -= 8;
;;;1562                        }   
;;;1563                     }
;;;1564                     /* byte oriented slave */
;;;1565                     else
;;;1566                     {
;;;1567                        if (BitPos)
0018a0  f1b90f00          CMP      r9,#0
0018a4  d002              BEQ      |L1.6316|
;;;1568                        {
;;;1569                           LogAddr++;
;;;1570                           BitPos = 0;
0018a6  f04f0900          MOV      r9,#0
0018aa  1c6d              ADDS     r5,r5,#1
                  |L1.6316|
;;;1571                        }   
;;;1572                        context->slavelist[slave].FMMU[FMMUc].LogStart = htoel(LogAddr);
0018ac  eb000286          ADD      r2,r0,r6,LSL #2
0018b0  207c              MOVS     r0,#0x7c
0018b2  eb001007          ADD      r0,r0,r7,LSL #4
0018b6  5015              STR      r5,[r2,r0]
;;;1573                        context->slavelist[slave].FMMU[FMMUc].LogStartbit = BitPos;
0018b8  6862              LDR      r2,[r4,#4]
0018ba  eb020386          ADD      r3,r2,r6,LSL #2
0018be  2282              MOVS     r2,#0x82
0018c0  eb021207          ADD      r2,r2,r7,LSL #4
0018c4  f8039002          STRB     r9,[r3,r2]
;;;1574                        BitPos = 7;
;;;1575                        FMMUsize = ByteCount;
;;;1576                        if ((FMMUsize + FMMUdone)> (int)context->slavelist[slave].Ibytes)
0018c8  6862              LDR      r2,[r4,#4]
0018ca  9805              LDR      r0,[sp,#0x14]
0018cc  f8ddc010          LDR      r12,[sp,#0x10]
0018d0  5851              LDR      r1,[r2,r1]
0018d2  2307              MOVS     r3,#7                 ;1574
0018d4  4484              ADD      r12,r12,r0
0018d6  4561              CMP      r1,r12
0018d8  da01              BGE      |L1.6366|
;;;1577                        {
;;;1578                           FMMUsize = context->slavelist[slave].Ibytes - FMMUdone;
0018da  9804              LDR      r0,[sp,#0x10]
0018dc  1a08              SUBS     r0,r1,r0
                  |L1.6366|
;;;1579                        }
;;;1580                        LogAddr += FMMUsize;
;;;1581                        context->slavelist[slave].FMMU[FMMUc].LogLength = htoes(FMMUsize);
0018de  eb020286          ADD      r2,r2,r6,LSL #2
0018e2  2180              MOVS     r1,#0x80
0018e4  eb011107          ADD      r1,r1,r7,LSL #4
0018e8  5250              STRH     r0,[r2,r1]
;;;1582                        context->slavelist[slave].FMMU[FMMUc].LogEndbit = BitPos;
0018ea  6861              LDR      r1,[r4,#4]
0018ec  4405              ADD      r5,r5,r0              ;1580
0018ee  eb010286          ADD      r2,r1,r6,LSL #2
0018f2  2183              MOVS     r1,#0x83
0018f4  eb011107          ADD      r1,r1,r7,LSL #4
;;;1583                        BitPos = 0;
0018f8  f04f0900          MOV      r9,#0
0018fc  5453              STRB     r3,[r2,r1]            ;1582
                  |L1.6398|
;;;1584                     }
;;;1585                     FMMUdone += FMMUsize;
0018fe  9904              LDR      r1,[sp,#0x10]
001900  4408              ADD      r0,r0,r1
;;;1586                     if (context->slavelist[slave].FMMU[FMMUc].LogLength)
001902  9004              STR      r0,[sp,#0x10]
001904  6860              LDR      r0,[r4,#4]
001906  2180              MOVS     r1,#0x80
001908  eb000086          ADD      r0,r0,r6,LSL #2
00190c  eb011107          ADD      r1,r1,r7,LSL #4
001910  5a41              LDRH     r1,[r0,r1]
001912  b379              CBZ      r1,|L1.6516|
;;;1587                     {   
;;;1588                        context->slavelist[slave].FMMU[FMMUc].PhysStartBit = 0;
001914  2100              MOVS     r1,#0
001916  2286              MOVS     r2,#0x86
001918  e000              B        |L1.6428|
                  |L1.6426|
00191a  e032              B        |L1.6530|
                  |L1.6428|
00191c  eb021207          ADD      r2,r2,r7,LSL #4
;;;1589                        context->slavelist[slave].FMMU[FMMUc].FMMUtype = 1;
;;;1590                        context->slavelist[slave].FMMU[FMMUc].FMMUactive = 1;
;;;1591                        /* program FMMU for input */
;;;1592                        ecx_FPWR(context->port, configadr, ECT_REG_FMMU0 + (sizeof(ec_fmmut) * FMMUc), 
001920  2310              MOVS     r3,#0x10
001922  5481              STRB     r1,[r0,r2]            ;1588
001924  6861              LDR      r1,[r4,#4]            ;1589
001926  2001              MOVS     r0,#1                 ;1589
001928  eb010286          ADD      r2,r1,r6,LSL #2       ;1589
00192c  2187              MOVS     r1,#0x87              ;1589
00192e  eb011107          ADD      r1,r1,r7,LSL #4       ;1589
001932  5450              STRB     r0,[r2,r1]            ;1589
001934  6861              LDR      r1,[r4,#4]            ;1590
001936  eb010286          ADD      r2,r1,r6,LSL #2       ;1590
00193a  2188              MOVS     r1,#0x88              ;1590
00193c  eb011107          ADD      r1,r1,r7,LSL #4       ;1590
001940  5450              STRB     r0,[r2,r1]            ;1590
001942  6860              LDR      r0,[r4,#4]
001944  f2417170          MOV      r1,#0x1770
001948  eb000286          ADD      r2,r0,r6,LSL #2
00194c  207c              MOVS     r0,#0x7c
00194e  eb001007          ADD      r0,r0,r7,LSL #4
001952  4410              ADD      r0,r0,r2
001954  e9cd0100          STRD     r0,r1,[sp,#0]
001958  f44f60c0          MOV      r0,#0x600
00195c  eb001207          ADD      r2,r0,r7,LSL #4
001960  6820              LDR      r0,[r4,#0]
001962  9908              LDR      r1,[sp,#0x20]
001964  f7fffffe          BL       ecx_FPWR
;;;1593                           sizeof(ec_fmmut), &(context->slavelist[slave].FMMU[FMMUc]), EC_TIMEOUTRET3);
;;;1594                        /* add one for an input FMMU */
;;;1595                        context->grouplist[group].inputsWKC++;
001968  6920              LDR      r0,[r4,#0x10]
00196a  990a              LDR      r1,[sp,#0x28]
00196c  9a0a              LDR      r2,[sp,#0x28]
00196e  5a41              LDRH     r1,[r0,r1]
001970  1c49              ADDS     r1,r1,#1
001972  5281              STRH     r1,[r0,r2]
                  |L1.6516|
;;;1596                     }   
;;;1597                     if (!context->slavelist[slave].inputs)
001974  202c              MOVS     r0,#0x2c
001976  6861              LDR      r1,[r4,#4]
001978  eb000086          ADD      r0,r0,r6,LSL #2
00197c  580a              LDR      r2,[r1,r0]
00197e  b3b2              CBZ      r2,|L1.6638|
001980  e04f              B        |L1.6690|
                  |L1.6530|
001982  eb000186          ADD      r1,r0,r6,LSL #2       ;1546
001986  207c              MOVS     r0,#0x7c              ;1546
001988  eb001007          ADD      r0,r0,r7,LSL #4       ;1546
00198c  500d              STR      r5,[r1,r0]            ;1546
00198e  6861              LDR      r1,[r4,#4]            ;1547
001990  eb010386          ADD      r3,r1,r6,LSL #2       ;1547
001994  2182              MOVS     r1,#0x82              ;1547
001996  eb011107          ADD      r1,r1,r7,LSL #4       ;1547
00199a  f8039001          STRB     r9,[r3,r1]            ;1547
00199e  6862              LDR      r2,[r4,#4]            ;1548
0019a0  9909              LDR      r1,[sp,#0x24]         ;1548
0019a2  5c53              LDRB     r3,[r2,r1]            ;1548
0019a4  f1a90101          SUB      r1,r9,#1              ;1548
0019a8  4419              ADD      r1,r1,r3              ;1548
0019aa  b2c9              UXTB     r1,r1                 ;1548
0019ac  2907              CMP      r1,#7                 ;1549
0019ae  d902              BLS      |L1.6582|
0019b0  3908              SUBS     r1,r1,#8              ;1549
0019b2  b2c9              UXTB     r1,r1                 ;1552
0019b4  1c6d              ADDS     r5,r5,#1              ;1552
                  |L1.6582|
0019b6  eb020286          ADD      r2,r2,r6,LSL #2       ;1554
0019ba  2380              MOVS     r3,#0x80              ;1555
0019bc  5810              LDR      r0,[r2,r0]            ;1554
0019be  eb031307          ADD      r3,r3,r7,LSL #4       ;1555
0019c2  1a28              SUBS     r0,r5,r0              ;1554
0019c4  1c40              ADDS     r0,r0,#1              ;1555
0019c6  52d0              STRH     r0,[r2,r3]            ;1555
0019c8  6862              LDR      r2,[r4,#4]            ;1556
0019ca  eb020386          ADD      r3,r2,r6,LSL #2       ;1556
0019ce  2283              MOVS     r2,#0x83              ;1556
0019d0  eb021207          ADD      r2,r2,r7,LSL #4       ;1556
0019d4  5499              STRB     r1,[r3,r2]            ;1556
0019d6  1c49              ADDS     r1,r1,#1              ;1556
0019d8  f00109ff          AND      r9,r1,#0xff           ;1557
0019dc  f1b90f07          CMP      r9,#7                 ;1558
0019e0  d98d              BLS      |L1.6398|
0019e2  f1a90108          SUB      r1,r9,#8              ;1561
0019e6  f00109ff          AND      r9,r1,#0xff           ;1561
0019ea  1c6d              ADDS     r5,r5,#1              ;1561
0019ec  e787              B        |L1.6398|
                  |L1.6638|
0019ee  e7ff              B        |L1.6640|
                  |L1.6640|
;;;1598                     {   
;;;1599                        context->slavelist[slave].inputs = 
0019f0  227c              MOVS     r2,#0x7c
0019f2  eb010386          ADD      r3,r1,r6,LSL #2
0019f6  eb021207          ADD      r2,r2,r7,LSL #4
0019fa  589b              LDR      r3,[r3,r2]
0019fc  9a11              LDR      r2,[sp,#0x44]
0019fe  441a              ADD      r2,r2,r3
001a00  500a              STR      r2,[r1,r0]
;;;1600                           (uint8 *)(pIOmap) + etohl(context->slavelist[slave].FMMU[FMMUc].LogStart);
;;;1601                        context->slavelist[slave].Istartbit = 
001a02  6861              LDR      r1,[r4,#4]
001a04  2282              MOVS     r2,#0x82
001a06  eb010386          ADD      r3,r1,r6,LSL #2
001a0a  eb021207          ADD      r2,r2,r7,LSL #4
001a0e  5c9a              LDRB     r2,[r3,r2]
001a10  2330              MOVS     r3,#0x30
001a12  eb030386          ADD      r3,r3,r6,LSL #2
001a16  54ca              STRB     r2,[r1,r3]
;;;1602                           context->slavelist[slave].FMMU[FMMUc].LogStartbit;
;;;1603                        EC_PRINT("    Inputs %p startbit %d\n", 
001a18  6861              LDR      r1,[r4,#4]
001a1a  5809              LDR      r1,[r1,r0]
001a1c  a067              ADR      r0,|L1.7100|
001a1e  f7fffffe          BL       __2printf
                  |L1.6690|
001a22  1c7f              ADDS     r7,r7,#1
;;;1604                           context->slavelist[slave].inputs, 
;;;1605                           context->slavelist[slave].Istartbit);
;;;1606                     }
;;;1607                     FMMUc++;
001a24  b2ff              UXTB     r7,r7
001a26  f1b80f07          CMP      r8,#7                 ;1516
001a2a  d208              BCS      |L1.6718|
                  |L1.6700|
001a2c  6861              LDR      r1,[r4,#4]            ;1516
001a2e  9809              LDR      r0,[sp,#0x24]         ;1516
001a30  5a08              LDRH     r0,[r1,r0]            ;1516
001a32  9904              LDR      r1,[sp,#0x10]         ;1516
001a34  1dc0              ADDS     r0,r0,#7              ;1516
001a36  ebb10fd0          CMP      r1,r0,LSR #3          ;1516
001a3a  f6ffaeb8          BLT      |L1.6062|
                  |L1.6718|
;;;1608                  }   
;;;1609                  context->slavelist[slave].FMMUunused = FMMUc;
001a3e  6861              LDR      r1,[r4,#4]
001a40  980d              LDR      r0,[sp,#0x34]
;;;1610                  diff = LogAddr - oLogAddr;
;;;1611                  oLogAddr = LogAddr;
;;;1612                  if ((segmentsize + diff) > (EC_MAXLRWDATA - EC_FIRSTDCDATAGRAM))
001a42  f24052ba          MOV      r2,#0x5ba
001a46  540f              STRB     r7,[r1,r0]            ;1609
001a48  9807              LDR      r0,[sp,#0x1c]         ;1610
001a4a  9507              STR      r5,[sp,#0x1c]
001a4c  1a28              SUBS     r0,r5,r0              ;1610
001a4e  eb0a0100          ADD      r1,r10,r0
001a52  4291              CMP      r1,r2
001a54  d912              BLS      |L1.6780|
;;;1613                  {
;;;1614                     context->grouplist[group].IOsegment[currentsegment] = segmentsize;
001a56  6923              LDR      r3,[r4,#0x10]
001a58  9a02              LDR      r2,[sp,#8]
001a5a  2728              MOVS     r7,#0x28
001a5c  eb0303c2          ADD      r3,r3,r2,LSL #3
001a60  eb07028b          ADD      r2,r7,r11,LSL #2
;;;1615                     if (currentsegment < (EC_MAXIOSEGMENTS - 1))
001a64  f1bb0f3f          CMP      r11,#0x3f
001a68  f843a002          STR      r10,[r3,r2]           ;1614
001a6c  d207              BCS      |L1.6782|
;;;1616                     {
;;;1617                        currentsegment++;
001a6e  f10b0101          ADD      r1,r11,#1
001a72  fa1ffb81          UXTH     r11,r1
;;;1618                        segmentsize = diff;   
001a76  4682              MOV      r10,r0
                  |L1.6776|
001a78  e001              B        |L1.6782|
                  |L1.6778|
001a7a  e0bd              B        |L1.7160|
                  |L1.6780|
;;;1619                     }
;;;1620                  }
;;;1621                  else
;;;1622                  {
;;;1623                     segmentsize += diff;
001a7c  468a              MOV      r10,r1
                  |L1.6782|
;;;1624                  }   
;;;1625               }
;;;1626               ecx_eeprom2pdi(context, slave); /* set Eeprom control to PDI */         
001a7e  4620              MOV      r0,r4
001a80  9903              LDR      r1,[sp,#0xc]
001a82  f7fffffe          BL       ecx_eeprom2pdi
;;;1627               ecx_FPWRw(context->port, configadr, ECT_REG_ALCTL, htoes(EC_STATE_SAFE_OP) , EC_TIMEOUTRET3); /* set safeop status */
001a86  f2417070          MOV      r0,#0x1770
001a8a  9000              STR      r0,[sp,#0]
001a8c  2304              MOVS     r3,#4
001a8e  f44f7290          MOV      r2,#0x120
001a92  6820              LDR      r0,[r4,#0]
001a94  9908              LDR      r1,[sp,#0x20]
001a96  f7fffffe          BL       ecx_FPWRw
;;;1628               ec_statecheck(slave, EC_STATE_SAFE_OP,  EC_TIMEOUTSTATE);    
001a9a  4a4f              LDR      r2,|L1.7128|
001a9c  2104              MOVS     r1,#4
001a9e  9803              LDR      r0,[sp,#0xc]
001aa0  f7fffffe          BL       ec_statecheck
;;;1629               if (context->slavelist[slave].blockLRW)
001aa4  f44f7181          MOV      r1,#0x102
001aa8  6860              LDR      r0,[r4,#4]
001aaa  eb010186          ADD      r1,r1,r6,LSL #2
001aae  5c40              LDRB     r0,[r0,r1]
001ab0  b138              CBZ      r0,|L1.6850|
;;;1630               {    
;;;1631                  context->grouplist[group].blockLRW++;                     
001ab2  9902              LDR      r1,[sp,#8]
001ab4  6920              LDR      r0,[r4,#0x10]
001ab6  221a              MOVS     r2,#0x1a
001ab8  eb0201c1          ADD      r1,r2,r1,LSL #3
001abc  5c42              LDRB     r2,[r0,r1]
001abe  1c52              ADDS     r2,r2,#1
001ac0  5442              STRB     r2,[r0,r1]
                  |L1.6850|
;;;1632               }
;;;1633               context->grouplist[group].Ebuscurrent += context->slavelist[slave].Ebuscurrent;
001ac2  6920              LDR      r0,[r4,#0x10]
001ac4  9a02              LDR      r2,[sp,#8]
001ac6  6863              LDR      r3,[r4,#4]
001ac8  2118              MOVS     r1,#0x18
001aca  f44f7780          MOV      r7,#0x100
001ace  eb0101c2          ADD      r1,r1,r2,LSL #3
001ad2  eb070686          ADD      r6,r7,r6,LSL #2
001ad6  5a42              LDRH     r2,[r0,r1]
001ad8  5b9b              LDRH     r3,[r3,r6]
001ada  441a              ADD      r2,r2,r3
001adc  5242              STRH     r2,[r0,r1]
                  |L1.6878|
001ade  9803              LDR      r0,[sp,#0xc]          ;1495
001ae0  1c40              ADDS     r0,r0,#1              ;1495
001ae2  b280              UXTH     r0,r0                 ;1495
                  |L1.6884|
001ae4  9003              STR      r0,[sp,#0xc]          ;1495
001ae6  68a0              LDR      r0,[r4,#8]            ;1495
001ae8  6801              LDR      r1,[r0,#0]            ;1495
001aea  9803              LDR      r0,[sp,#0xc]          ;1495
001aec  4281              CMP      r1,r0                 ;1495
001aee  f6bfadf2          BGE      |L1.5846|
;;;1634            }
;;;1635         }
;;;1636         if (BitPos)
001af2  f1b90f00          CMP      r9,#0
001af6  d018              BEQ      |L1.6954|
;;;1637         {
;;;1638            LogAddr++;
;;;1639            oLogAddr = LogAddr;
;;;1640            BitPos = 0;
;;;1641            if ((segmentsize + 1) > (EC_MAXLRWDATA - EC_FIRSTDCDATAGRAM))
001af8  f10a0001          ADD      r0,r10,#1
001afc  f24051ba          MOV      r1,#0x5ba
001b00  1c6d              ADDS     r5,r5,#1
001b02  4288              CMP      r0,r1
001b04  d935              BLS      |L1.7026|
;;;1642            {
;;;1643               context->grouplist[group].IOsegment[currentsegment] = segmentsize;
001b06  6922              LDR      r2,[r4,#0x10]
001b08  9902              LDR      r1,[sp,#8]
001b0a  2328              MOVS     r3,#0x28
001b0c  eb0202c1          ADD      r2,r2,r1,LSL #3
001b10  eb03018b          ADD      r1,r3,r11,LSL #2
;;;1644               if (currentsegment < (EC_MAXIOSEGMENTS - 1))
001b14  f1bb0f3f          CMP      r11,#0x3f
001b18  f842a001          STR      r10,[r2,r1]           ;1643
001b1c  d205              BCS      |L1.6954|
;;;1645               {
;;;1646                  currentsegment++;
001b1e  f10b0001          ADD      r0,r11,#1
001b22  fa1ffb80          UXTH     r11,r0
;;;1647                  segmentsize = 1;   
001b26  2001              MOVS     r0,#1
                  |L1.6952|
;;;1648               }
;;;1649            }
;;;1650            else
;;;1651            {
;;;1652               segmentsize += 1;
001b28  4682              MOV      r10,r0
                  |L1.6954|
;;;1653            }
;;;1654         }   
;;;1655         context->grouplist[group].IOsegment[currentsegment] = segmentsize;
001b2a  6922              LDR      r2,[r4,#0x10]
001b2c  9902              LDR      r1,[sp,#8]
001b2e  2328              MOVS     r3,#0x28
001b30  eb0202c1          ADD      r2,r2,r1,LSL #3
001b34  eb03018b          ADD      r1,r3,r11,LSL #2
;;;1656         context->grouplist[group].nsegments = currentsegment + 1;
001b38  f10b0001          ADD      r0,r11,#1
001b3c  f842a001          STR      r10,[r2,r1]           ;1655
001b40  6922              LDR      r2,[r4,#0x10]
001b42  990b              LDR      r1,[sp,#0x2c]
;;;1657         context->grouplist[group].inputs = (uint8 *)(pIOmap) + context->grouplist[group].Obytes;
001b44  2310              MOVS     r3,#0x10
001b46  5250              STRH     r0,[r2,r1]            ;1656
001b48  6920              LDR      r0,[r4,#0x10]
001b4a  990c              LDR      r1,[sp,#0x30]
001b4c  5842              LDR      r2,[r0,r1]
001b4e  9911              LDR      r1,[sp,#0x44]
001b50  440a              ADD      r2,r2,r1
001b52  9902              LDR      r1,[sp,#8]
001b54  eb0301c1          ADD      r1,r3,r1,LSL #3
001b58  5042              STR      r2,[r0,r1]
;;;1658         context->grouplist[group].Ibytes = LogAddr - context->grouplist[group].Obytes;
001b5a  6920              LDR      r0,[r4,#0x10]
001b5c  990c              LDR      r1,[sp,#0x30]
001b5e  5841              LDR      r1,[r0,r1]
001b60  1a6a              SUBS     r2,r5,r1
001b62  9902              LDR      r1,[sp,#8]
001b64  230c              MOVS     r3,#0xc
001b66  eb0301c1          ADD      r1,r3,r1,LSL #3
001b6a  5042              STR      r2,[r0,r1]
;;;1659         if (!group)
001b6c  9812              LDR      r0,[sp,#0x48]
001b6e  b118              CBZ      r0,|L1.7032|
001b70  e00b              B        |L1.7050|
                  |L1.7026|
001b72  f10a0001          ADD      r0,r10,#1             ;1652
001b76  e7d7              B        |L1.6952|
                  |L1.7032|
;;;1660         {   
;;;1661            context->slavelist[0].inputs = (uint8 *)(pIOmap) + context->slavelist[0].Obytes;
001b78  6860              LDR      r0,[r4,#4]
001b7a  9911              LDR      r1,[sp,#0x44]
001b7c  69c2              LDR      r2,[r0,#0x1c]
001b7e  4411              ADD      r1,r1,r2
;;;1662            context->slavelist[0].Ibytes = LogAddr - context->slavelist[0].Obytes; /* store input bytes in master record */
001b80  62c1              STR      r1,[r0,#0x2c]
001b82  6860              LDR      r0,[r4,#4]
001b84  69c1              LDR      r1,[r0,#0x1c]
001b86  1a69              SUBS     r1,r5,r1
001b88  6281              STR      r1,[r0,#0x28]
                  |L1.7050|
;;;1663         }   
;;;1664   
;;;1665         EC_PRINT("IOmapSize %d\n", LogAddr - context->grouplist[group].logstartaddr);      
001b8a  6921              LDR      r1,[r4,#0x10]
001b8c  9802              LDR      r0,[sp,#8]
001b8e  f8510030          LDR      r0,[r1,r0,LSL #3]
001b92  1a29              SUBS     r1,r5,r0
001b94  a011              ADR      r0,|L1.7132|
001b96  f7fffffe          BL       __2printf
;;;1666      
;;;1667         return (LogAddr - context->grouplist[group].logstartaddr);
001b9a  6921              LDR      r1,[r4,#0x10]
001b9c  9802              LDR      r0,[sp,#8]
001b9e  e025              B        |L1.7148|
                  |L1.7072|
001ba0  203d536c          DCB      " =Slave %d, INPUT MAPPING\n",0
001ba4  61766520
001ba8  25642c20
001bac  494e5055
001bb0  54204d41
001bb4  5050494e
001bb8  470a00  
001bbb  00                DCB      0
                  |L1.7100|
001bbc  20202020          DCB      "    Inputs %p startbit %d\n",0
001bc0  496e7075
001bc4  74732025
001bc8  70207374
001bcc  61727462
001bd0  69742025
001bd4  640a00  
001bd7  00                DCB      0
                  |L1.7128|
                          DCD      0x001e8480
                  |L1.7132|
001bdc  494f6d61          DCB      "IOmapSize %d\n",0
001be0  7053697a
001be4  65202564
001be8  0a00    
001bea  00                DCB      0
001beb  00                DCB      0
                  |L1.7148|
001bec  f8510030          LDR      r0,[r1,r0,LSL #3]
001bf0  1a28              SUBS     r0,r5,r0
                  |L1.7154|
;;;1668   		}			
;;;1669         /* do input mapping of slave and program FMMUs */
;;;1670   //      for (slave = 1; slave <= *(context->slavecount); slave++)
;;;1671   //      {
;;;1672   //         configadr = context->slavelist[slave].configadr;
;;;1673   //         if (!group || (group == context->slavelist[slave].group))
;;;1674   //         {
;;;1675   //            /* create input mapping */
;;;1676   //            if (context->slavelist[slave].Ibits)
;;;1677   //            {
;;;1678   // 
;;;1679   //               ecx_config_create_input_mappings(context, pIOmap, group, slave, &LogAddr, &BitPos);
;;;1680   //               diff = LogAddr - oLogAddr;
;;;1681   //               oLogAddr = LogAddr;
;;;1682   //               if ((segmentsize + diff) > (EC_MAXLRWDATA - EC_FIRSTDCDATAGRAM))
;;;1683   //               {
;;;1684   //                  context->grouplist[group].IOsegment[currentsegment] = segmentsize;
;;;1685   //                  if (currentsegment < (EC_MAXIOSEGMENTS - 1))
;;;1686   //                  {
;;;1687   //                     currentsegment++;
;;;1688   //                     segmentsize = diff;
;;;1689   //                  }
;;;1690   //               }
;;;1691   //               else
;;;1692   //               {
;;;1693   //                  segmentsize += diff;
;;;1694   //               }
;;;1695   //            }
;;;1696   
;;;1697   //            ecx_eeprom2pdi(context, slave); /* set Eeprom control to PDI */
;;;1698   //            /* User may override automatic state change */
;;;1699   //               /* request safe_op for slave */
;;;1700   //            ecx_FPWRw(context->port,configadr,ECT_REG_ALCTL,htoes(EC_STATE_SAFE_OP),EC_TIMEOUTRET3); /* set safeop status */
;;;1701   //            ec_statecheck(1, EC_STATE_SAFE_OP,  EC_TIMEOUTSTATE);
;;;1702   //						if (context->slavelist[slave].blockLRW)
;;;1703   //            {
;;;1704   //               context->grouplist[group].blockLRW++;
;;;1705   //            }
;;;1706   //            context->grouplist[group].Ebuscurrent += context->slavelist[slave].Ebuscurrent;
;;;1707   //         }
;;;1708   //      }
;;;1709   //      if (BitPos)
;;;1710   //      {
;;;1711   //         LogAddr++;
;;;1712   //         oLogAddr = LogAddr;
;;;1713   //         BitPos = 0;
;;;1714   //         if ((segmentsize + 1) > (EC_MAXLRWDATA - EC_FIRSTDCDATAGRAM))
;;;1715   //         {
;;;1716   //            context->grouplist[group].IOsegment[currentsegment] = segmentsize;
;;;1717   //            if (currentsegment < (EC_MAXIOSEGMENTS - 1))
;;;1718   //            {
;;;1719   //               currentsegment++;
;;;1720   //               segmentsize = 1;
;;;1721   //            }
;;;1722   //         }
;;;1723   //         else
;;;1724   //         {
;;;1725   //            segmentsize += 1;
;;;1726   //         }
;;;1727   //      }
;;;1728   //      context->grouplist[group].IOsegment[currentsegment] = segmentsize;
;;;1729   //      context->grouplist[group].nsegments = currentsegment + 1;
;;;1730   //      context->grouplist[group].inputs = (uint8 *)(pIOmap) + context->grouplist[group].Obytes;
;;;1731   //      context->grouplist[group].Ibytes = LogAddr - 
;;;1732   //         context->grouplist[group].logstartaddr - 
;;;1733   //         context->grouplist[group].Obytes;
;;;1734   //      if (!group)
;;;1735   //      {
;;;1736   //         context->slavelist[0].inputs = (uint8 *)(pIOmap) + context->slavelist[0].Obytes;
;;;1737   //         context->slavelist[0].Ibytes = LogAddr - 
;;;1738   //            context->grouplist[group].logstartaddr - 
;;;1739   //            context->slavelist[0].Obytes; /* store input bytes in master record */
;;;1740   //      }
;;;1741   
;;;1742   //      EC_PRINT("IOmapSize %d\n", LogAddr - context->grouplist[group].logstartaddr);
;;;1743   
;;;1744   //      return (LogAddr - context->grouplist[group].logstartaddr);
;;;1745   //   }
;;;1746      
;;;1747      return 0;	
;;;1748   }
001bf2  b013              ADD      sp,sp,#0x4c
001bf4  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.7160|
001bf8  2000              MOVS     r0,#0                 ;1747
001bfa  e7fa              B        |L1.7154|
;;;1749   
                          ENDP

                  ec_config_map_group PROC
;;;1189    */
;;;1190   int ec_config_map_group(void *pIOmap, uint8 group)
001bfc  460a              MOV      r2,r1
;;;1191   {
;;;1192      return ecx_config_map_group(&ecx_context, pIOmap, group);
001bfe  4601              MOV      r1,r0
001c00  4817              LDR      r0,|L1.7264|
001c02  f7ffbffe          B.W      ecx_config_map_group
;;;1193   }
;;;1194   /** Map all PDOs from slaves to IOmap.
                          ENDP

                  ec_config_map PROC
;;;1198    */
;;;1199   int ec_config_map(void *pIOmap)
001c06  2100              MOVS     r1,#0
;;;1200   {
;;;1201      return ec_config_map_group(pIOmap, 0);
001c08  e7fe              B        ec_config_map_group
;;;1202   }
;;;1203   
                          ENDP

                  ec_config PROC
;;;1209    */
;;;1210   int ec_config(uint8 usetable)
001c0a  b510              PUSH     {r4,lr}
;;;1211   {
;;;1212      int wkc;
;;;1213      wkc = ec_config_init(usetable);
001c0c  f7fffffe          BL       ec_config_init
001c10  1e04              SUBS     r4,r0,#0
;;;1214      if (wkc>0)
001c12  dd03              BLE      |L1.7196|
;;;1215      {   
;;;1216   		 printf("EACT Find %d slaves\n\r", wkc);
001c14  4601              MOV      r1,r0
001c16  a013              ADR      r0,|L1.7268|
001c18  f7fffffe          BL       __2printf
                  |L1.7196|
;;;1217   //     wkc=ec_config_map();
;;;1218      }
;;;1219      return wkc;
001c1c  4620              MOV      r0,r4
;;;1220   }
001c1e  bd10              POP      {r4,pc}
;;;1221   
                          ENDP

                  ec_recover_slave PROC
;;;1222   int ec_recover_slave(uint16 slave, int timeout)
001c20  460a              MOV      r2,r1
;;;1223   {
;;;1224      return ecx_recover_slave(&ecx_context, slave, timeout);
001c22  4601              MOV      r1,r0
001c24  480e              LDR      r0,|L1.7264|
001c26  f7ffbffe          B.W      ecx_recover_slave
;;;1225   }
;;;1226   
                          ENDP

                  ecat_loop PROC
;;;1763   
;;;1764   void ecat_loop(void)
001c2a  4814              LDR      r0,|L1.7292|
;;;1765   {
001c2c  b510              PUSH     {r4,lr}
;;;1766   	uint8 i;
;;;1767       if(all_slave_op == 1)
001c2e  7800              LDRB     r0,[r0,#0]  ; all_slave_op
001c30  2801              CMP      r0,#1
001c32  d114              BNE      |L1.7262|
;;;1768       {
;;;1769   			ec_send_processdata();/* PDO发送函数 */
001c34  f7fffffe          BL       ec_send_processdata
;;;1770   			ec_receive_processdata(EC_TIMEOUTRET);/* PDO接收函数 */
001c38  f44f60fa          MOV      r0,#0x7d0
001c3c  f7fffffe          BL       ec_receive_processdata
;;;1771   //				 outputs1->out1=time_cnt;	
;;;1772   				 for(i=0;i<ec_slavecount;i++)
;;;1773   				 {
;;;1774   //						printf("%d slaves output %d.\r\n",i+1,time_cnt); 
;;;1775   				    IOmap[0+i*6]=time_cnt;//此处可以给多个同样的从站IO模块输出，6为每一个模块的输出字节长度。
001c40  490f              LDR      r1,|L1.7296|
001c42  4a11              LDR      r2,|L1.7304|
001c44  2000              MOVS     r0,#0                 ;1772
001c46  4b0f              LDR      r3,|L1.7300|
001c48  7809              LDRB     r1,[r1,#0]
001c4a  6812              LDR      r2,[r2,#0]            ;1772
001c4c  e005              B        |L1.7258|
                  |L1.7246|
001c4e  eb000440          ADD      r4,r0,r0,LSL #1
001c52  1c40              ADDS     r0,r0,#1
001c54  f8031014          STRB     r1,[r3,r4,LSL #1]
001c58  b2c0              UXTB     r0,r0                 ;1772
                  |L1.7258|
001c5a  4290              CMP      r0,r2                 ;1772
001c5c  dbf7              BLT      |L1.7246|
                  |L1.7262|
;;;1776               					 
;;;1777   			   }				
;;;1778       }
;;;1779   }
001c5e  bd10              POP      {r4,pc}
;;;1780   #endif
                          ENDP

                  |L1.7264|
                          DCD      ecx_context
                  |L1.7268|
001c64  45414354          DCB      "EACT Find %d slaves\n\r",0
001c68  2046696e
001c6c  64202564
001c70  20736c61
001c74  7665730a
001c78  0d00    
001c7a  00                DCB      0
001c7b  00                DCB      0
                  |L1.7292|
                          DCD      all_slave_op
                  |L1.7296|
                          DCD      time_cnt
                  |L1.7300|
                          DCD      IOmap
                  |L1.7304|
                          DCD      ec_slavecount

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ec_configlist
                          DCD      0x00000002
                          DCD      0x13ed3052
000008  454c3531          DCB      0x45,0x4c,0x35,0x31
00000c  30310000          DCB      0x30,0x31,0x00,0x00
                          %        12
00001c  0007              DCB      0x00,0x07
00001e  0028              DCW      0x0028
000020  00181000          DCW      0x0018,0x1000
                          DCD      0x00010024
000028  1100              DCW      0x1100
00002a  0000              DCB      0x00,0x00
                          DCD      0x00010020
000030  01010000          DCB      0x01,0x01,0x00,0x00
                          DCD      0x00528785
                          DCD      0x00000100
00003c  4c435420          DCB      0x4c,0x43,0x54,0x20
000040  45636174          DCB      0x45,0x63,0x61,0x74
000044  5f537465          DCB      0x5f,0x53,0x74,0x65
000048  705f4d6f          DCB      0x70,0x5f,0x4d,0x6f
00004c  746f7200          DCB      0x74,0x6f,0x72,0x00
000050  0007              DCB      0x00,0x07
000052  0120              DCW      0x0120
000054  01601600          DCW      0x0160,0x1600
                          DCD      0x00010064
00005c  1b00              DCW      0x1b00
00005e  0000              DCB      0x00,0x00
                          DCD      0x00010020
000064  01010000          DCB      0x01,0x01,0x00,0x00
                          DCD      0xffffffff
                          DCD      0x00000000
000070  00000000          DCB      0x00,0x00,0x00,0x00
                          %        16
000084  0000              DCB      0x00,0x00
000086  0000              DCW      0x0000
000088  00000000          DCW      0x0000,0x0000
                          DCD      0x00000000
000090  0000              DCW      0x0000
000092  0000              DCB      0x00,0x00
                          DCD      0x00000000
000098  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  4572726f          DCB      "Error: too many slaves on network: num_slaves=%d, EC_MA"
000004  723a2074
000008  6f6f206d
00000c  616e7920
000010  736c6176
000014  6573206f
000018  6e206e65
00001c  74776f72
000020  6b3a206e
000024  756d5f73
000028  6c617665
00002c  733d2564
000030  2c204543
000034  5f4d41  
000037  58534c41          DCB      "XSLAVE=%d\n",0
00003b  56453d25
00003f  640a00  

                          AREA ||.data||, DATA, ALIGN=0

                  flag
000000  01                DCB      0x01

                          AREA ||area_number.7||, DATA, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.data||
                  output
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\ETHERCAT\\ethercatconfig.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_ethercatconfig_c_5d4a504e____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___16_ethercatconfig_c_5d4a504e____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_ethercatconfig_c_5d4a504e____REVSH|
#line 144
|__asm___16_ethercatconfig_c_5d4a504e____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
