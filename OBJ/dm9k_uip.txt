; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\dm9k_uip.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\dm9k_uip.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\FWLIB\STM32F4xx_StdPeriph_Driver\inc -I..\USER -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\ETHERNET -I..\HARDWARE\TIMER -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\RTC -I..\HARDWARE\ADC -I..\HARDWARE\SRAM -I..\HARDWARE\InterTemperate -I..\FWLIB\STM32F4x7_ETH_Driver\inc -I..\MALLOC -I..\USMART -I..\HARDWARE -I..\ETHERCAT -I.\RTE\_LWIP -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS --omf_browse=..\obj\dm9k_uip.crf ..\HARDWARE\dm9k_uip.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  dm9k_WriteReg PROC
;;;305    */
;;;306    void dm9k_WriteReg(uint8_t reg, uint8_t writedata)
000000  4af8              LDR      r2,|L1.996|
;;;307    {
;;;308    	NET_REG_ADDR = reg;
000002  8010              STRH     r0,[r2,#0]
;;;309    	NET_REG_DATA = writedata;
000004  48f8              LDR      r0,|L1.1000|
000006  8001              STRH     r1,[r0,#0]
;;;310    }
000008  4770              BX       lr
;;;311    
                          ENDP

                  dm9k_hash_table PROC
;;;319    */
;;;320    void dm9k_hash_table(void)
00000a  b510              PUSH     {r4,lr}
;;;321    {
;;;322    	uint8_t i;
;;;323    
;;;324    //	/* 将MAC地址告诉uip */
;;;325    //	for (i = 0; i < 6; i++)
;;;326    //	{
;;;327    //		uip_ethaddr.addr[i] = DEF_MAC_ADDR[i];
;;;328    //	}
;;;329    
;;;330    	/* 设置 网卡 MAC 位置，来自於 MyHardware */
;;;331    	for(i = 0; i < 6; i++)
;;;332    	{
;;;333    		dm9k_WriteReg(DM9000_REG_PAR + i, DEF_MAC_ADDR[i]);
00000c  4cf7              LDR      r4,|L1.1004|
00000e  2300              MOVS     r3,#0                 ;331
                  |L1.16|
000010  f1030010          ADD      r0,r3,#0x10
000014  5ce1              LDRB     r1,[r4,r3]
000016  b2c0              UXTB     r0,r0
000018  f7fffffe          BL       dm9k_WriteReg
00001c  1c5b              ADDS     r3,r3,#1
00001e  b2db              UXTB     r3,r3                 ;331
000020  2b06              CMP      r3,#6                 ;331
000022  d3f5              BCC      |L1.16|
;;;334    	}
;;;335    
;;;336    	/* 清除 网卡多播设置 */
;;;337    	for(i = 0; i < 8; i++)
000024  2300              MOVS     r3,#0
                  |L1.38|
;;;338    	{
;;;339    		dm9k_WriteReg(DM9000_REG_MAR + i, 0xFF);
000026  f1030016          ADD      r0,r3,#0x16
00002a  b2c0              UXTB     r0,r0
00002c  21ff              MOVS     r1,#0xff
00002e  f7fffffe          BL       dm9k_WriteReg
000032  1c5b              ADDS     r3,r3,#1
000034  b2db              UXTB     r3,r3                 ;337
000036  2b08              CMP      r3,#8                 ;337
000038  d3f5              BCC      |L1.38|
;;;340    	}
;;;341    
;;;342    //	/* 设置 广播包 设置 */
;;;343    //	dm9k_WriteReg(DM9000_REG_MAR + 7, 0x80);
;;;344    }
00003a  bd10              POP      {r4,pc}
;;;345    /*
                          ENDP

                  dm9k_phy_write PROC
;;;423    */
;;;424    void dm9k_phy_write(uint8_t phy_reg, uint16_t writedata)
00003c  460b              MOV      r3,r1
;;;425    {
00003e  b510              PUSH     {r4,lr}
;;;426    	/* 设置写入 PHY 寄存器的位置 */
;;;427    	dm9k_WriteReg(DM9000_REG_EPAR, phy_reg | DM9000_PHY);
000040  f0400140          ORR      r1,r0,#0x40
000044  200c              MOVS     r0,#0xc
000046  f7fffffe          BL       dm9k_WriteReg
;;;428    
;;;429    	/* 设置写入 PHY 寄存器的值 */
;;;430    	dm9k_WriteReg(DM9000_REG_EPDRH, ( writedata >> 8 ) & 0xff);
00004a  0a19              LSRS     r1,r3,#8
00004c  200e              MOVS     r0,#0xe
00004e  f7fffffe          BL       dm9k_WriteReg
;;;431    	dm9k_WriteReg(DM9000_REG_EPDRL, writedata & 0xff);
000052  b2d9              UXTB     r1,r3
000054  200d              MOVS     r0,#0xd
000056  f7fffffe          BL       dm9k_WriteReg
;;;432    
;;;433    	dm9k_WriteReg(DM9000_REG_EPCR, 0x0a); 						/* 将资料写入 PHY 寄存器 */
00005a  210a              MOVS     r1,#0xa
00005c  200b              MOVS     r0,#0xb
00005e  f7fffffe          BL       dm9k_WriteReg
;;;434    //	while(dm9k_ReadReg(DM9000_REG_EPCR) & 0x01);					/* 查寻是否执行结束 */
;;;435    	Delay_ms(50);
000062  2032              MOVS     r0,#0x32
000064  f7fffffe          BL       Delay_ms
;;;436    //	dm9k_WriteReg(DM9000_REG_EPCR, 0x08); 						/* 清除写入命令 */
;;;437    	 dm9k_WriteReg(DM9000_REG_EPCR, 0x00); 	
000068  2100              MOVS     r1,#0
00006a  e8bd4010          POP      {r4,lr}
00006e  200b              MOVS     r0,#0xb
000070  e7fe              B        dm9k_WriteReg
;;;438    }
;;;439    
                          ENDP

                  dm9k_ReadReg PROC
;;;290    */
;;;291    uint8_t dm9k_ReadReg(uint8_t reg)
000072  49dc              LDR      r1,|L1.996|
;;;292    {
;;;293    	NET_REG_ADDR = reg;
000074  8008              STRH     r0,[r1,#0]
;;;294    	return (NET_REG_DATA);
000076  48dc              LDR      r0,|L1.1000|
000078  8800              LDRH     r0,[r0,#0]
00007a  b2c0              UXTB     r0,r0
;;;295    }
00007c  4770              BX       lr
;;;296    
                          ENDP

                  dm9k_reset PROC
;;;379    */
;;;380    void dm9k_reset(void)
00007e  b510              PUSH     {r4,lr}
;;;381    {
;;;382    	
;;;383    //复位DM9000,复位步骤参考<DM9000 Application Notes V1.22>手册29页
;;;384    //	DM9000_RST;								//DM9000硬件复位
;;;385    //	Delay_ms(20);
;;;386    //	DM9000_SET; 							//DM9000硬件复位结束
;;;387    //	Delay_ms(200);								//一定要有这个延时，让DM9000准备就绪！
;;;388     	dm9k_WriteReg(DM9000_REG_GPCR,0x01);			//第一步:设置GPCR寄存器(0X1E)的bit0为1 
000080  2101              MOVS     r1,#1
000082  201e              MOVS     r0,#0x1e
000084  f7fffffe          BL       dm9k_WriteReg
;;;389    	dm9k_WriteReg(DM9000_REG_GPR,0);				//第二步:设置GPR寄存器(0X1F)的bit1为0，DM9000内部的PHY上电
000088  2100              MOVS     r1,#0
00008a  201f              MOVS     r0,#0x1f
00008c  f7fffffe          BL       dm9k_WriteReg
;;;390    	Delay_ms(2);                          //延时2ms以上等待PHY上电
000090  2002              MOVS     r0,#2
000092  f7fffffe          BL       Delay_ms
;;;391     	dm9k_WriteReg(DM9000_REG_NCR,0x03);	   //第三步:软件复位DM9000 
000096  2103              MOVS     r1,#3
000098  2000              MOVS     r0,#0
00009a  f7fffffe          BL       dm9k_WriteReg
                  |L1.158|
;;;392      do 
;;;393    	{ 
;;;394    		Delay_ms(1); 
00009e  2001              MOVS     r0,#1
0000a0  f7fffffe          BL       Delay_ms
;;;395    	}while(dm9k_ReadReg(DM9000_REG_NCR)&1);		//等待DM9000软复位完成
0000a4  2000              MOVS     r0,#0
0000a6  f7fffffe          BL       dm9k_ReadReg
0000aa  07c0              LSLS     r0,r0,#31
0000ac  d1f7              BNE      |L1.158|
;;;396    	dm9k_WriteReg(DM9000_REG_NCR,0x00);	   //第四步:软件复位完成，进入正常工作模式 
0000ae  2100              MOVS     r1,#0
0000b0  4608              MOV      r0,r1
0000b2  f7fffffe          BL       dm9k_WriteReg
;;;397    	dm9k_WriteReg(DM9000_REG_NCR,0x03);	   //第五步:第二次软件复位DM9000 
0000b6  2103              MOVS     r1,#3
0000b8  2000              MOVS     r0,#0
0000ba  f7fffffe          BL       dm9k_WriteReg
                  |L1.190|
;;;398    	do 
;;;399    	{
;;;400    		Delay_ms(1);
0000be  2001              MOVS     r0,#1
0000c0  f7fffffe          BL       Delay_ms
;;;401    	}while(dm9k_ReadReg(DM9000_REG_NCR)&1);		//等待DM9000软复位完成
0000c4  2000              MOVS     r0,#0
0000c6  f7fffffe          BL       dm9k_ReadReg
0000ca  07c0              LSLS     r0,r0,#31
0000cc  d1f7              BNE      |L1.190|
;;;402    	dm9k_WriteReg(DM9000_REG_NCR,0x00);	   //第六步:软件复位完成，进入正常工作模式 	
0000ce  2100              MOVS     r1,#0
0000d0  4608              MOV      r0,r1
0000d2  f7fffffe          BL       dm9k_WriteReg
;;;403    		/* 基本记存器相关设置 */
;;;404    	dm9k_WriteReg(DM9000_REG_IMR, DM9000_IMR_OFF); 			/* 开启内存自环模式 */
0000d6  2180              MOVS     r1,#0x80
0000d8  20ff              MOVS     r0,#0xff
0000da  f7fffffe          BL       dm9k_WriteReg
;;;405    	dm9k_WriteReg(DM9000_REG_TCR2, DM9000_TCR2_SET);			/* 设置 LED 显示模式1:全双工亮，半双工灭 */
0000de  2180              MOVS     r1,#0x80
0000e0  202d              MOVS     r0,#0x2d
0000e2  f7fffffe          BL       dm9k_WriteReg
;;;406    	/* 清除多余资讯 */
;;;407    	dm9k_WriteReg(DM9000_REG_NSR, 0x2c);
0000e6  212c              MOVS     r1,#0x2c
0000e8  2001              MOVS     r0,#1
0000ea  f7fffffe          BL       dm9k_WriteReg
;;;408    	dm9k_WriteReg(DM9000_REG_TCR, 0x00);
0000ee  2100              MOVS     r1,#0
0000f0  2002              MOVS     r0,#2
0000f2  f7fffffe          BL       dm9k_WriteReg
;;;409    	dm9k_WriteReg(DM9000_REG_ISR, 0x0f);
0000f6  210f              MOVS     r1,#0xf
0000f8  20fe              MOVS     r0,#0xfe
0000fa  f7fffffe          BL       dm9k_WriteReg
;;;410    	dm9k_WriteReg(DM9000_REG_RCR, DM9000_RCR_SET);			/* 开启 接收工能 */
0000fe  2133              MOVS     r1,#0x33
000100  2005              MOVS     r0,#5
000102  f7fffffe          BL       dm9k_WriteReg
;;;411    	dm9k_WriteReg(DM9000_REG_IMR, DM9000_IMR_OFF);			/* 关闭 中断模式 */
000106  2180              MOVS     r1,#0x80
000108  20ff              MOVS     r0,#0xff
00010a  f7fffffe          BL       dm9k_WriteReg
;;;412    	SendPackOk = 0;
00010e  49b7              LDR      r1,|L1.1004|
000110  2000              MOVS     r0,#0
000112  1f09              SUBS     r1,r1,#4
000114  7008              STRB     r0,[r1,#0]
;;;413    }
000116  bd10              POP      {r4,pc}
;;;414    
                          ENDP

                  DM9000_Initnic PROC
;;;447    */
;;;448    void DM9000_Initnic(void)
000118  b510              PUSH     {r4,lr}
;;;449    {
;;;450    	
;;;451    	dm9k_reset();									//复位DM9000
00011a  f7fffffe          BL       dm9k_reset
;;;452    	
;;;453    	dm9k_WriteReg(DM9000_REG_GPR, DM9000_PHY_OFF);			/* 关闭 PHY ，进行 PHY 设置*/
00011e  2101              MOVS     r1,#1
000120  201f              MOVS     r0,#0x1f
000122  f7fffffe          BL       dm9k_WriteReg
;;;454    	dm9k_phy_write(0x00, 0x8000);					/* 重置 PHY 的寄存器 */
000126  f44f4100          MOV      r1,#0x8000
00012a  2000              MOVS     r0,#0
00012c  f7fffffe          BL       dm9k_phy_write
;;;455    	dm9k_phy_write(0x04, 0x01e1);					/* 设置 自适应模式相容表 */
000130  f24011e1          MOV      r1,#0x1e1
000134  2004              MOVS     r0,#4
000136  f7fffffe          BL       dm9k_phy_write
;;;456    	//dm9k_phy_write(0x00, 0x1000);					/* 设置 基本连接模式 */
;;;457    	/* 连接模式设置
;;;458    	  0x0000 : 固定10M半双工
;;;459    	  0x0100 : 固定10M全双工
;;;460    	  0x2000 : 固定100M半双工
;;;461    	  0x2100 : 固定100M全双工
;;;462    	  0x1000 : 自适应模式
;;;463    	*/
;;;464    	dm9k_phy_write(0x00, 0x1000);				/* 设置 基本连接模式 */
00013a  f44f5180          MOV      r1,#0x1000
00013e  2000              MOVS     r0,#0
000140  f7fffffe          BL       dm9k_phy_write
;;;465    	dm9k_WriteReg(DM9000_REG_GPR, DM9000_PHY_ON);				/* 结束 PHY 设置, 开启 PHY */
000144  2100              MOVS     r1,#0
000146  201f              MOVS     r0,#0x1f
000148  f7fffffe          BL       dm9k_WriteReg
;;;466    	dm9k_hash_table();								/* 设置 DM9000A MAC 及 多播*/
00014c  e8bd4010          POP      {r4,lr}
000150  e7fe              B        dm9k_hash_table
;;;467    	
;;;468    }
;;;469    
                          ENDP

                  DM9K_FSMCConfig PROC
;;;193    */
;;;194    static void DM9K_FSMCConfig(void)
000152  b500              PUSH     {lr}
;;;195    {
000154  b097              SUB      sp,sp,#0x5c
;;;196    	FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;197    	FSMC_NORSRAMTimingInitTypeDef  p;
;;;198    
;;;199    	/*-- FSMC Configuration ------------------------------------------------------*/
;;;200    	/*----------------------- SRAM Bank 3 ----------------------------------------*/
;;;201    	/*-- FSMC Configuration ------------------------------------------------------*/
;;;202    	p.FSMC_AddressSetupTime = 6;		/* 设置为2会出错; 3正常 */
000156  2006              MOVS     r0,#6
;;;203    	p.FSMC_AddressHoldTime = 0;
000158  9001              STR      r0,[sp,#4]
00015a  2000              MOVS     r0,#0
;;;204    	p.FSMC_DataSetupTime = 4;			/* 设置为1出错，2正常 */
00015c  2104              MOVS     r1,#4
00015e  e9cd0102          STRD     r0,r1,[sp,#8]
;;;205    	p.FSMC_BusTurnAroundDuration = 0;
;;;206    	p.FSMC_CLKDivision = 0;
000162  9004              STR      r0,[sp,#0x10]
;;;207    	p.FSMC_DataLatency = 0;
000164  9005              STR      r0,[sp,#0x14]
000166  9006              STR      r0,[sp,#0x18]
000168  e9cd0107          STRD     r0,r1,[sp,#0x1c]
;;;208    	p.FSMC_AccessMode = FSMC_AccessMode_A;
;;;209     
;;;210    //	p.FSMC_AddressSetupTime = 0;		/* 设置为2会出错; 3正常 */
;;;211    //	p.FSMC_AddressHoldTime = 0;
;;;212    //	p.FSMC_DataSetupTime = 3;			/* 设置为1出错，2正常 */
;;;213    //	p.FSMC_BusTurnAroundDuration = 0x00;
;;;214    //	p.FSMC_CLKDivision = 0x00;
;;;215    //	p.FSMC_DataLatency = 0x00;
;;;216    //	p.FSMC_AccessMode = FSMC_AccessMode_A;
;;;217    //	
;;;218    	
;;;219    	
;;;220    	FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM3;
;;;221    	FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
;;;222    	FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM;	// FSMC_MemoryType_PSRAM;
;;;223    	FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
00016c  2110              MOVS     r1,#0x10
00016e  e9cd010a          STRD     r0,r1,[sp,#0x28]
000172  9009              STR      r0,[sp,#0x24]
;;;224    	FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
;;;225    	FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
000174  900c              STR      r0,[sp,#0x30]
;;;226    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000176  900d              STR      r0,[sp,#0x34]
;;;227    	FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
000178  900e              STR      r0,[sp,#0x38]
;;;228    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;229    	FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
00017a  0209              LSLS     r1,r1,#8
00017c  900f              STR      r0,[sp,#0x3c]
00017e  e9cd0110          STRD     r0,r1,[sp,#0x40]
;;;230    	FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
;;;231    	FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
000182  9012              STR      r0,[sp,#0x48]
;;;232    	FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
000184  9013              STR      r0,[sp,#0x4c]
;;;233    	FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &p;
000186  9014              STR      r0,[sp,#0x50]
000188  a801              ADD      r0,sp,#4
;;;234    	FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &p;
00018a  9015              STR      r0,[sp,#0x54]
;;;235    
;;;236    	FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);
00018c  9016              STR      r0,[sp,#0x58]
00018e  a808              ADD      r0,sp,#0x20
000190  f7fffffe          BL       FSMC_NORSRAMInit
;;;237    
;;;238    	/*!< Enable FSMC Bank1_SRAM3 Bank */
;;;239    	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM3, ENABLE);
000194  2101              MOVS     r1,#1
000196  2004              MOVS     r0,#4
000198  f7fffffe          BL       FSMC_NORSRAMCmd
;;;240    	
;;;241    	
;;;242    	
;;;243    //	    FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;244    //    FSMC_NORSRAMTimingInitTypeDef  FSMC_NORSRAMTimingInitStructure;
;;;245    //    FSMC_NORSRAMTimingInitStructure.FSMC_AddressSetupTime = 10;             /* ??????*/
;;;246    //    FSMC_NORSRAMTimingInitStructure.FSMC_AddressHoldTime = 0;      
;;;247    //    FSMC_NORSRAMTimingInitStructure.FSMC_DataSetupTime = 10;                /* ??????*/
;;;248    //    FSMC_NORSRAMTimingInitStructure.FSMC_BusTurnAroundDuration = 0x00;
;;;249    //    FSMC_NORSRAMTimingInitStructure.FSMC_CLKDivision = 0x00;
;;;250    //    FSMC_NORSRAMTimingInitStructure.FSMC_DataLatency = 0x00;
;;;251    //    FSMC_NORSRAMTimingInitStructure.FSMC_AccessMode = FSMC_AccessMode_A;    /* FSMC ????*/
;;;252    
;;;253    //    FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM3;
;;;254    //    FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
;;;255    //    FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;256    //    FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
;;;257    //    FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
;;;258    //    FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
;;;259    //    FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
;;;260    //    FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;261    //    FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
;;;262    //    FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
;;;263    //    FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
;;;264    //    FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
;;;265    //    FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
;;;266    //    FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &FSMC_NORSRAMTimingInitStructure;
;;;267    //    FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure); 
;;;268    //    /* ??FSMC???*/
;;;269    //    FSMC_NORSRAMTimingInitStructure.FSMC_AddressSetupTime = 5;              /* ??????*/
;;;270    //    FSMC_NORSRAMTimingInitStructure.FSMC_AddressHoldTime = 0;      
;;;271    //    FSMC_NORSRAMTimingInitStructure.FSMC_DataSetupTime = 5;                 /* ??????*/
;;;272    //    FSMC_NORSRAMTimingInitStructure.FSMC_BusTurnAroundDuration = 0x00;
;;;273    //    FSMC_NORSRAMTimingInitStructure.FSMC_CLKDivision = 0x00;
;;;274    //    FSMC_NORSRAMTimingInitStructure.FSMC_DataLatency = 0x00;
;;;275    //    FSMC_NORSRAMTimingInitStructure.FSMC_AccessMode = FSMC_AccessMode_A;    /* FSMC????*/
;;;276    //    FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &FSMC_NORSRAMTimingInitStructure; 
;;;277    //	  FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);
;;;278    
;;;279    //	  /*!< Enable FSMC Bank1_SRAM3 Bank */
;;;280    //	  FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM3, ENABLE);		
;;;281    }
00019c  b017              ADD      sp,sp,#0x5c
00019e  bd00              POP      {pc}
;;;282    
                          ENDP

                  DM9K_CtrlLinesConfig PROC
;;;88     */
;;;89     static void DM9K_CtrlLinesConfig(void)
0001a0  e92d41fc          PUSH     {r2-r8,lr}
;;;90     {
;;;91     	GPIO_InitTypeDef GPIO_InitStructure;
;;;92       EXTI_InitTypeDef EXTI_InitStructure;
;;;93       NVIC_InitTypeDef NVIC_InitStructure;
;;;94     	
;;;95     	/* 使能FSMC时钟 */
;;;96     	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
0001a4  2101              MOVS     r1,#1
0001a6  4608              MOV      r0,r1
0001a8  f7fffffe          BL       RCC_AHB3PeriphClockCmd
;;;97     
;;;98     	/* 使能 GPIO时钟 */
;;;99     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA|RCC_AHB1Periph_GPIOC|RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOE | RCC_AHB1Periph_GPIOG, ENABLE);
0001ac  2101              MOVS     r1,#1
0001ae  205d              MOVS     r0,#0x5d
0001b0  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;100      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
0001b4  2101              MOVS     r1,#1
0001b6  0388              LSLS     r0,r1,#14
0001b8  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;101    	/* 设置 PD.00(D2), PD.01(D3), PD.04(NOE), PD.05(NWE), PD.08(D13), PD.09(D14),
;;;102    	 PD.10(D15), PD.14(D0), PD.15(D1) 为复用推挽输出 */
;;;103    
;;;104    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);
0001bc  4e8c              LDR      r6,|L1.1008|
0001be  220c              MOVS     r2,#0xc
0001c0  2100              MOVS     r1,#0
0001c2  4630              MOV      r0,r6
0001c4  f7fffffe          BL       GPIO_PinAFConfig
;;;105    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);
0001c8  220c              MOVS     r2,#0xc
0001ca  2101              MOVS     r1,#1
0001cc  4630              MOV      r0,r6
0001ce  f7fffffe          BL       GPIO_PinAFConfig
;;;106    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FSMC);
0001d2  220c              MOVS     r2,#0xc
0001d4  2104              MOVS     r1,#4
0001d6  4630              MOV      r0,r6
0001d8  f7fffffe          BL       GPIO_PinAFConfig
;;;107    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FSMC);
0001dc  220c              MOVS     r2,#0xc
0001de  2105              MOVS     r1,#5
0001e0  4630              MOV      r0,r6
0001e2  f7fffffe          BL       GPIO_PinAFConfig
;;;108    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FSMC);
0001e6  220c              MOVS     r2,#0xc
0001e8  2108              MOVS     r1,#8
0001ea  4630              MOV      r0,r6
0001ec  f7fffffe          BL       GPIO_PinAFConfig
;;;109    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FSMC);
0001f0  220c              MOVS     r2,#0xc
0001f2  2109              MOVS     r1,#9
0001f4  4630              MOV      r0,r6
0001f6  f7fffffe          BL       GPIO_PinAFConfig
;;;110    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
0001fa  220c              MOVS     r2,#0xc
0001fc  210a              MOVS     r1,#0xa
0001fe  4630              MOV      r0,r6
000200  f7fffffe          BL       GPIO_PinAFConfig
;;;111    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
000204  220c              MOVS     r2,#0xc
000206  210e              MOVS     r1,#0xe
000208  4630              MOV      r0,r6
00020a  f7fffffe          BL       GPIO_PinAFConfig
;;;112    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
00020e  220c              MOVS     r2,#0xc
000210  210f              MOVS     r1,#0xf
000212  4630              MOV      r0,r6
000214  f7fffffe          BL       GPIO_PinAFConfig
;;;113    
;;;114    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 |
000218  f24c7033          MOV      r0,#0xc733
;;;115    	                            GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 |
;;;116    	                            GPIO_Pin_15;
;;;117    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00021c  9000              STR      r0,[sp,#0]
00021e  2002              MOVS     r0,#2
000220  f88d0004          STRB     r0,[sp,#4]
;;;118    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000224  2503              MOVS     r5,#3
000226  f88d5005          STRB     r5,[sp,#5]
;;;119    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00022a  2400              MOVS     r4,#0
00022c  f88d4006          STRB     r4,[sp,#6]
;;;120    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000230  f88d4007          STRB     r4,[sp,#7]
;;;121    	GPIO_Init(GPIOD, &GPIO_InitStructure);
000234  4669              MOV      r1,sp
000236  4630              MOV      r0,r6
000238  f7fffffe          BL       GPIO_Init
;;;122    
;;;123    	/* 设置 PE.07(D4), PE.08(D5), PE.09(D6), PE.10(D7), PE.11(D8), PE.12(D9), PE.13(D10),
;;;124    	 PE.14(D11), PE.15(D12) 为复用推挽输出 */
;;;125    
;;;126    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource4 , GPIO_AF_FSMC);
00023c  4f6d              LDR      r7,|L1.1012|
00023e  220c              MOVS     r2,#0xc
000240  2104              MOVS     r1,#4
000242  4638              MOV      r0,r7
000244  f7fffffe          BL       GPIO_PinAFConfig
;;;127    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource5 , GPIO_AF_FSMC);
000248  220c              MOVS     r2,#0xc
00024a  2105              MOVS     r1,#5
00024c  4638              MOV      r0,r7
00024e  f7fffffe          BL       GPIO_PinAFConfig
;;;128    
;;;129    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FSMC);
000252  220c              MOVS     r2,#0xc
000254  2107              MOVS     r1,#7
000256  4638              MOV      r0,r7
000258  f7fffffe          BL       GPIO_PinAFConfig
;;;130    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FSMC);
00025c  220c              MOVS     r2,#0xc
00025e  2108              MOVS     r1,#8
000260  4638              MOV      r0,r7
000262  f7fffffe          BL       GPIO_PinAFConfig
;;;131    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FSMC);
000266  220c              MOVS     r2,#0xc
000268  2109              MOVS     r1,#9
00026a  4638              MOV      r0,r7
00026c  f7fffffe          BL       GPIO_PinAFConfig
;;;132    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource10 , GPIO_AF_FSMC);
000270  220c              MOVS     r2,#0xc
000272  210a              MOVS     r1,#0xa
000274  4638              MOV      r0,r7
000276  f7fffffe          BL       GPIO_PinAFConfig
;;;133    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource11 , GPIO_AF_FSMC);
00027a  220c              MOVS     r2,#0xc
00027c  210b              MOVS     r1,#0xb
00027e  4638              MOV      r0,r7
000280  f7fffffe          BL       GPIO_PinAFConfig
;;;134    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource12 , GPIO_AF_FSMC);
000284  220c              MOVS     r2,#0xc
000286  4611              MOV      r1,r2
000288  4638              MOV      r0,r7
00028a  f7fffffe          BL       GPIO_PinAFConfig
;;;135    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource13 , GPIO_AF_FSMC);
00028e  220c              MOVS     r2,#0xc
000290  210d              MOVS     r1,#0xd
000292  4638              MOV      r0,r7
000294  f7fffffe          BL       GPIO_PinAFConfig
;;;136    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource14 , GPIO_AF_FSMC);
000298  220c              MOVS     r2,#0xc
00029a  210e              MOVS     r1,#0xe
00029c  4638              MOV      r0,r7
00029e  f7fffffe          BL       GPIO_PinAFConfig
;;;137    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource15 , GPIO_AF_FSMC);
0002a2  220c              MOVS     r2,#0xc
0002a4  210f              MOVS     r1,#0xf
0002a6  4638              MOV      r0,r7
0002a8  f7fffffe          BL       GPIO_PinAFConfig
;;;138    
;;;139    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
0002ac  f64f70b0          MOV      r0,#0xffb0
;;;140    	                            GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 |
;;;141    	                            GPIO_Pin_15;
;;;142    	GPIO_Init(GPIOE, &GPIO_InitStructure);
0002b0  9000              STR      r0,[sp,#0]
0002b2  4669              MOV      r1,sp
0002b4  4638              MOV      r0,r7
0002b6  f7fffffe          BL       GPIO_Init
;;;143    
;;;144    	/* 设置 PD.13(A18 (RS))  为复用推挽输出 */
;;;145    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_FSMC);
0002ba  220c              MOVS     r2,#0xc
0002bc  210d              MOVS     r1,#0xd
0002be  4630              MOV      r0,r6
0002c0  f7fffffe          BL       GPIO_PinAFConfig
;;;146    
;;;147    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
0002c4  f44f5000          MOV      r0,#0x2000
;;;148    	GPIO_Init(GPIOD, &GPIO_InitStructure);
0002c8  9000              STR      r0,[sp,#0]
0002ca  4669              MOV      r1,sp
0002cc  4630              MOV      r0,r6
0002ce  f7fffffe          BL       GPIO_Init
;;;149    
;;;150    	/* 设置 PG10 (CS)) 为复用推挽输出 */
;;;151    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource10, GPIO_AF_FSMC);
0002d2  4e49              LDR      r6,|L1.1016|
0002d4  220c              MOVS     r2,#0xc
0002d6  210a              MOVS     r1,#0xa
0002d8  4630              MOV      r0,r6
0002da  f7fffffe          BL       GPIO_PinAFConfig
;;;152    
;;;153    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
0002de  1531              ASRS     r1,r6,#20
;;;154    	GPIO_Init(GPIOG, &GPIO_InitStructure);
0002e0  9100              STR      r1,[sp,#0]
0002e2  4669              MOV      r1,sp
0002e4  4630              MOV      r0,r6
0002e6  f7fffffe          BL       GPIO_Init
;;;155    
;;;156    //	/* PA15 是DM9000_INT中断输入口(本程序未使用) */
;;;157    //  /* Connect EXTI Line to INT Pin */
;;;158    //  SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource15);
;;;159    	/*dm9000复位硬引脚*/
;;;160    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; 		//PC9 推挽输出 
;;;161    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;//推挽输出
0002ea  2001              MOVS     r0,#1
0002ec  f88d0004          STRB     r0,[sp,#4]
;;;162    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
0002f0  f88d5005          STRB     r5,[sp,#5]
;;;163    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
0002f4  f88d4006          STRB     r4,[sp,#6]
;;;164    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
0002f8  f88d4007          STRB     r4,[sp,#7]
;;;165    	GPIO_Init(GPIOC,&GPIO_InitStructure);
0002fc  4c3f              LDR      r4,|L1.1020|
0002fe  1576              ASRS     r6,r6,#21             ;160
000300  9600              STR      r6,[sp,#0]            ;161
000302  4669              MOV      r1,sp
000304  4620              MOV      r0,r4
000306  f7fffffe          BL       GPIO_Init
;;;166    
;;;167    	DM9000_RST;								//DM9000硬件复位
00030a  4631              MOV      r1,r6
00030c  4620              MOV      r0,r4
00030e  f7fffffe          BL       GPIO_ResetBits
;;;168    	Delay_ms(10);
000312  200a              MOVS     r0,#0xa
000314  f7fffffe          BL       Delay_ms
;;;169    	DM9000_SET; 							//DM9000硬件复位结束
000318  4631              MOV      r1,r6
00031a  4620              MOV      r0,r4
00031c  f7fffffe          BL       GPIO_SetBits
;;;170    	Delay_ms(100);								//一定要有这个延时，让DM9000准备就绪！
000320  2064              MOVS     r0,#0x64
000322  f7fffffe          BL       Delay_ms
;;;171    	
;;;172    //  /* Configure EXTI line */
;;;173    //  EXTI_InitStructure.EXTI_Line = EXTI_Line15;
;;;174    //  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
;;;175    //  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
;;;176    //  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
;;;177    //  EXTI_Init(&EXTI_InitStructure);
;;;178    
;;;179    //  /* Enable and set the EXTI interrupt to priority 1*/
;;;180    //  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
;;;181    //  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;182    //  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;183    //  NVIC_Init(&NVIC_InitStructure);
;;;184    }
000326  e8bd81fc          POP      {r2-r8,pc}
;;;185    
                          ENDP

                  DM9000_Init PROC
;;;70     */
;;;71     void DM9000_Init(void)
00032a  b510              PUSH     {r4,lr}
;;;72     {
;;;73     	DM9K_CtrlLinesConfig();
00032c  f7fffffe          BL       DM9K_CtrlLinesConfig
;;;74     	DM9K_FSMCConfig();
000330  f7fffffe          BL       DM9K_FSMCConfig
;;;75     
;;;76     	s_FSMC_Init_Ok = 1;
000334  492d              LDR      r1,|L1.1004|
000336  2001              MOVS     r0,#1
000338  1f09              SUBS     r1,r1,#4
00033a  7048              STRB     r0,[r1,#1]
;;;77     
;;;78     	DM9000_Initnic();			/* 配置DM9000 */
00033c  e8bd4010          POP      {r4,lr}
000340  e7fe              B        DM9000_Initnic
;;;79     }
;;;80     
                          ENDP

                  dm9k_err_reset PROC
;;;352    */
;;;353    void dm9k_err_reset(void)
000342  b510              PUSH     {r4,lr}
;;;354    {
;;;355     	dm9k_WriteReg(DM9000_REG_NCR,0x03);	   //第三步:软件复位DM9000 
000344  2103              MOVS     r1,#3
000346  2000              MOVS     r0,#0
000348  f7fffffe          BL       dm9k_WriteReg
;;;356    	Delay_us(10); 	
00034c  200a              MOVS     r0,#0xa
00034e  f7fffffe          BL       Delay_us
;;;357    	dm9k_WriteReg(DM9000_REG_NCR,0x03);	   //第五步:第二次软件复位DM9000 
000352  2103              MOVS     r1,#3
000354  2000              MOVS     r0,#0
000356  f7fffffe          BL       dm9k_WriteReg
;;;358    	Delay_us(10); 	
00035a  200a              MOVS     r0,#0xa
00035c  f7fffffe          BL       Delay_us
;;;359    
;;;360    		/* 基本记存器相关设置 */
;;;361    	dm9k_WriteReg(DM9000_REG_IMR, DM9000_IMR_OFF); 			/* 开启内存自环模式 */
000360  2180              MOVS     r1,#0x80
000362  20ff              MOVS     r0,#0xff
000364  f7fffffe          BL       dm9k_WriteReg
;;;362    	dm9k_WriteReg(DM9000_REG_TCR2, DM9000_TCR2_SET);			/* 设置 LED 显示模式1:全双工亮，半双工灭 */
000368  2180              MOVS     r1,#0x80
00036a  202d              MOVS     r0,#0x2d
00036c  f7fffffe          BL       dm9k_WriteReg
;;;363    	/* 清除多余资讯 */
;;;364    	dm9k_WriteReg(DM9000_REG_NSR, 0x2c);
000370  212c              MOVS     r1,#0x2c
000372  2001              MOVS     r0,#1
000374  f7fffffe          BL       dm9k_WriteReg
;;;365    	dm9k_WriteReg(DM9000_REG_TCR, 0x00);
000378  2100              MOVS     r1,#0
00037a  2002              MOVS     r0,#2
00037c  f7fffffe          BL       dm9k_WriteReg
;;;366    	dm9k_WriteReg(DM9000_REG_ISR, 0x0f);
000380  210f              MOVS     r1,#0xf
000382  20fe              MOVS     r0,#0xfe
000384  f7fffffe          BL       dm9k_WriteReg
;;;367    	dm9k_WriteReg(DM9000_REG_RCR, DM9000_RCR_SET);			/* 开启 接收工能 */
000388  2133              MOVS     r1,#0x33
00038a  2005              MOVS     r0,#5
00038c  f7fffffe          BL       dm9k_WriteReg
;;;368    	dm9k_WriteReg(DM9000_REG_IMR, DM9000_IMR_OFF);			/* 关闭 中断模式 */
000390  2180              MOVS     r1,#0x80
000392  20ff              MOVS     r0,#0xff
000394  f7fffffe          BL       dm9k_WriteReg
;;;369    	SendPackOk = 0;
000398  4914              LDR      r1,|L1.1004|
00039a  2000              MOVS     r0,#0
00039c  1f09              SUBS     r1,r1,#4
00039e  7008              STRB     r0,[r1,#0]
;;;370    }
0003a0  bd10              POP      {r4,pc}
;;;371    
                          ENDP

                  dm9k_receive_packet PROC
;;;477    */
;;;478    uint16_t dm9k_receive_packet(void)
0003a2  b570              PUSH     {r4-r6,lr}
;;;479    {
;;;480    	uint16_t ReceiveData[1600];
;;;481    	uint8_t  rx_int_count = 0;
;;;482    	u32  rx_checkbyte;
;;;483    	uint16_t rx_status, rx_length;
;;;484    	uint8_t  jump_packet;
;;;485    	uint16_t i;
;;;486    	uint16_t calc_len;
;;;487    	uint16_t calc_MRR;
;;;488    	uint16_t temp;
;;;489    	do
;;;490    	{
;;;491    		jump_packet = 0;								/* 清除跳包动作 */
;;;492    		dm9k_ReadReg(DM9000_REG_MRCMDX);							/* 读取内存数据，地址不增加 */
;;;493    		/* 计算内存数据位置 */
;;;494    		calc_MRR = (dm9k_ReadReg(DM9000_REG_MRRH) << 8) + dm9k_ReadReg(DM9000_REG_MRRL);
;;;495    		rx_checkbyte = dm9k_ReadReg(DM9000_REG_MRCMDX);			/*  */
;;;496    		if(rx_checkbyte == DM9000_PKT_RDY)				/* 取 */
;;;497    		{
;;;498    			/* 读取封包相关资讯 及 长度 */
;;;499    			NET_REG_ADDR = DM9000_REG_MRCMD;
;;;500    			rx_status = NET_REG_DATA;
0003a4  4b10              LDR      r3,|L1.1000|
0003a6  f5ad6d48          SUB      sp,sp,#0xc80          ;479
0003aa  2500              MOVS     r5,#0                 ;481
                  |L1.940|
0003ac  2200              MOVS     r2,#0                 ;491
0003ae  20f0              MOVS     r0,#0xf0              ;492
0003b0  f7fffffe          BL       dm9k_ReadReg
0003b4  20f4              MOVS     r0,#0xf4              ;494
0003b6  f7fffffe          BL       dm9k_ReadReg
0003ba  4604              MOV      r4,r0                 ;494
0003bc  20f5              MOVS     r0,#0xf5              ;494
0003be  f7fffffe          BL       dm9k_ReadReg
0003c2  eb042000          ADD      r0,r4,r0,LSL #8       ;494
0003c6  b284              UXTH     r4,r0                 ;494
0003c8  20f0              MOVS     r0,#0xf0              ;495
0003ca  f7fffffe          BL       dm9k_ReadReg
0003ce  2801              CMP      r0,#1                 ;496
0003d0  d016              BEQ      |L1.1024|
;;;501    			rx_length = NET_REG_DATA;
;;;502    			/* 若收到超过系统可承受的封包，此包跳过 */
;;;503    			if(rx_length > Max_Ethernet_Lenth)
;;;504    				jump_packet = 1;
;;;505    
;;;506    #ifdef Broadcast_Jump
;;;507    			/* 若收到的广播或多播包超过特定长度，此包跳过 */
;;;508    			if(rx_status & 0x4000)
;;;509    			{
;;;510    				if(rx_length > Max_Broadcast_Lenth)
;;;511    					jump_packet = 1;
;;;512    			}
;;;513    #endif
;;;514    			/* 计算下一个包的指针位 , 若接收长度为奇数，需加一对齐偶字节。*/
;;;515    			/* 若是超过 0x3fff ，则需回归绕到 0x0c00 起始位置 */
;;;516    			calc_MRR += (rx_length + 4);
;;;517    			if(rx_length & 0x01) calc_MRR++;
;;;518    			if(calc_MRR > 0x3fff) calc_MRR -= 0x3400;
;;;519    
;;;520    			if(jump_packet == 0x01)
;;;521    			{
;;;522    				/* 将指针移到下一个包的包头位置 */
;;;523    				dm9k_WriteReg (DM9000_REG_MRRH, (calc_MRR >> 8) & 0xff);
;;;524    				dm9k_WriteReg (DM9000_REG_MRRL, calc_MRR & 0xff );
;;;525    				continue;
;;;526    			}
;;;527    
;;;528    			/* 开始将内存的资料搬到到系统中，每次移动一个 word */
;;;529    			calc_len = (rx_length + 1) >> 1;
;;;530    			for(i = 0 ; i < calc_len ; i++)
;;;531    				ReceiveData[i] = NET_REG_DATA;
;;;532    
;;;533    			/* 将包长回报给 TCP/IP 上层，并减去最後 4 BYTE 的 CRC-32 检核码 */
;;;534    			receiveLen_DM9000 = rx_length - 4;
;;;535          memcpy((unsigned char*)receiveBuffer_DM9000,(uint8_t *)ReceiveData,receiveLen_DM9000);
;;;536    			rx_int_count++;								/* 累计收包次数 */
;;;537    
;;;538    #ifdef FifoPointCheck
;;;539    			if(calc_MRR != ((dm9k_ReadReg(DM9000_REG_MRRH) << 8) + dm9k_ReadReg(DM9000_REG_MRRL)))
;;;540    			{
;;;541    #ifdef Point_Error_Reset
;;;542    				dm9k_reset();								/* 若是指针出错，重置 */
;;;543    				return ReceiveLength;
;;;544    #endif
;;;545    				/*若是指针出错，将指针移到下一个包的包头位置  */
;;;546    				dm9k_WriteReg(DM9000_REG_MRRH, (calc_MRR >> 8) & 0xff);
;;;547    				dm9k_WriteReg(DM9000_REG_MRRL, calc_MRR & 0xff);
;;;548    			}
;;;549    #endif
;;;550    			dm9k_WriteReg(DM9000_REG_MRRH, (calc_MRR >> 8) & 0xff);
;;;551    			dm9k_WriteReg(DM9000_REG_MRRL, calc_MRR & 0xff);
;;;552    			return receiveLen_DM9000;
;;;553    		}
;;;554    		else
;;;555    		{
;;;556    			if(rx_checkbyte == DM9000_PKT_NORDY)		/* 未收到包 */
0003d2  2800              CMP      r0,#0
0003d4  d06d              BEQ      |L1.1202|
;;;557    			{
;;;558    				dm9k_WriteReg(DM9000_REG_ISR, 0x3f);				/*  */
;;;559    			}
;;;560    			else
;;;561    			{
;;;562    				dm9k_err_reset();								/* 接收指针出错，重置 */
0003d6  f7fffffe          BL       dm9k_err_reset
                  |L1.986|
;;;563    			}
;;;564    			return (0);
;;;565    		}
;;;566    	}while(rx_int_count < Max_Int_Count);				/* 是否超过最多接收封包计数 */
;;;567    	return 0;
0003da  2000              MOVS     r0,#0
                  |L1.988|
;;;568    }
0003dc  f50d6d48          ADD      sp,sp,#0xc80
0003e0  bd70              POP      {r4-r6,pc}
0003e2  0000              DCW      0x0000
                  |L1.996|
                          DCD      0x68400000
                  |L1.1000|
                          DCD      0x68480000
                  |L1.1004|
                          DCD      ||.data||+0x4
                  |L1.1008|
                          DCD      0x40020c00
                  |L1.1012|
                          DCD      0x40021000
                  |L1.1016|
                          DCD      0x40021800
                  |L1.1020|
                          DCD      0x40020800
                  |L1.1024|
000400  4963              LDR      r1,|L1.1424|
000402  20f2              MOVS     r0,#0xf2              ;499
000404  8008              STRH     r0,[r1,#0]            ;499
000406  8819              LDRH     r1,[r3,#0]            ;500
000408  8818              LDRH     r0,[r3,#0]            ;501
00040a  f5b06fc0          CMP      r0,#0x600             ;503
00040e  d900              BLS      |L1.1042|
000410  2201              MOVS     r2,#1                 ;504
                  |L1.1042|
000412  0449              LSLS     r1,r1,#17             ;508
000414  d503              BPL      |L1.1054|
000416  f5b07ffa          CMP      r0,#0x1f4             ;510
00041a  d900              BLS      |L1.1054|
00041c  2201              MOVS     r2,#1                 ;511
                  |L1.1054|
00041e  1821              ADDS     r1,r4,r0              ;516
000420  1d09              ADDS     r1,r1,#4              ;516
000422  b28c              UXTH     r4,r1                 ;516
000424  07c1              LSLS     r1,r0,#31             ;517
000426  d001              BEQ      |L1.1068|
000428  1c64              ADDS     r4,r4,#1              ;517
00042a  b2a4              UXTH     r4,r4                 ;517
                  |L1.1068|
00042c  f5b44f80          CMP      r4,#0x4000            ;518
000430  d302              BCC      |L1.1080|
000432  f5a45450          SUB      r4,r4,#0x3400         ;518
000436  b2a4              UXTH     r4,r4                 ;518
                  |L1.1080|
000438  b152              CBZ      r2,|L1.1104|
00043a  0a21              LSRS     r1,r4,#8              ;523
00043c  20f5              MOVS     r0,#0xf5              ;523
00043e  f7fffffe          BL       dm9k_WriteReg
000442  b2e1              UXTB     r1,r4                 ;524
000444  20f4              MOVS     r0,#0xf4              ;524
000446  f7fffffe          BL       dm9k_WriteReg
00044a  2d00              CMP      r5,#0                 ;525
00044c  d0ae              BEQ      |L1.940|
00044e  e7c4              B        |L1.986|
                  |L1.1104|
000450  1c41              ADDS     r1,r0,#1              ;529
000452  084d              LSRS     r5,r1,#1              ;529
000454  2100              MOVS     r1,#0                 ;530
000456  466a              MOV      r2,sp                 ;480
000458  e004              B        |L1.1124|
                  |L1.1114|
00045a  881e              LDRH     r6,[r3,#0]            ;531
00045c  f8226011          STRH     r6,[r2,r1,LSL #1]     ;531
000460  1c49              ADDS     r1,r1,#1              ;531
000462  b289              UXTH     r1,r1                 ;530
                  |L1.1124|
000464  42a9              CMP      r1,r5                 ;530
000466  d3f8              BCC      |L1.1114|
000468  1f00              SUBS     r0,r0,#4              ;530
00046a  4d4a              LDR      r5,|L1.1428|
00046c  b282              UXTH     r2,r0                 ;534
00046e  4669              MOV      r1,sp                 ;535
000470  806a              STRH     r2,[r5,#2]            ;534
000472  4849              LDR      r0,|L1.1432|
000474  f7fffffe          BL       __aeabi_memcpy
000478  20f4              MOVS     r0,#0xf4              ;539
00047a  f7fffffe          BL       dm9k_ReadReg
00047e  4602              MOV      r2,r0                 ;539
000480  20f5              MOVS     r0,#0xf5              ;539
000482  f7fffffe          BL       dm9k_ReadReg
000486  eb022000          ADD      r0,r2,r0,LSL #8       ;539
00048a  42a0              CMP      r0,r4                 ;539
00048c  d007              BEQ      |L1.1182|
00048e  0a21              LSRS     r1,r4,#8              ;546
000490  20f5              MOVS     r0,#0xf5              ;546
000492  f7fffffe          BL       dm9k_WriteReg
000496  b2e1              UXTB     r1,r4                 ;547
000498  20f4              MOVS     r0,#0xf4              ;547
00049a  f7fffffe          BL       dm9k_WriteReg
                  |L1.1182|
00049e  0a21              LSRS     r1,r4,#8              ;550
0004a0  20f5              MOVS     r0,#0xf5              ;550
0004a2  f7fffffe          BL       dm9k_WriteReg
0004a6  b2e1              UXTB     r1,r4                 ;551
0004a8  20f4              MOVS     r0,#0xf4              ;551
0004aa  f7fffffe          BL       dm9k_WriteReg
0004ae  8868              LDRH     r0,[r5,#2]            ;552  ; receiveLen_DM9000
0004b0  e794              B        |L1.988|
                  |L1.1202|
0004b2  213f              MOVS     r1,#0x3f              ;558
0004b4  20fe              MOVS     r0,#0xfe              ;558
0004b6  f7fffffe          BL       dm9k_WriteReg
0004ba  e78e              B        |L1.986|
;;;569    
                          ENDP

                  dm9k_send_packet PROC
;;;577    */
;;;578    void dm9k_send_packet(uint8_t *p_char, uint16_t length)
0004bc  b570              PUSH     {r4-r6,lr}
;;;579    {
0004be  460b              MOV      r3,r1
0004c0  4604              MOV      r4,r0
;;;580    	uint16_t SendLength = length;
;;;581    	uint16_t *SendData = (uint16_t *) p_char;
;;;582    	uint16_t i;
;;;583    	uint16_t calc_len;
;;;584    	__IO uint16_t calc_MWR;
;;;585      uint32_t timer2;
;;;586      
;;;587    	/* 检查 DM9000A 是否还在传送中！若是等待直到传送结束 */
;;;588    	dm9k_WriteReg(DM9000_REG_IMR,DM9000_IMR_OFF);		//关闭网卡中断 
0004c2  2180              MOVS     r1,#0x80
0004c4  20ff              MOVS     r0,#0xff
0004c6  f7fffffe          BL       dm9k_WriteReg
;;;589    //	if(SendPackOk == Max_Send_Pack)
;;;590    //	{
;;;591    //		timer2=bsp_GetTickCount();
;;;592    //		while(dm9k_ReadReg(DM9000_REG_TCR) & DM9000_TCR_SET)
;;;593    //		{
;;;594    //			Delay_us (5);
;;;595    //			if(bsp_GetTickCount()-timer2>=1000)
;;;596    //				 break;
;;;597    //		}
;;;598    //		SendPackOk = 0;
;;;599    //	}
;;;600    
;;;601    //	SendPackOk++;										/* 设置传送计数 */
;;;602    	NET_REG_ADDR = DM9000_REG_MWCMD;
0004ca  4931              LDR      r1,|L1.1424|
0004cc  20f8              MOVS     r0,#0xf8
0004ce  8008              STRH     r0,[r1,#0]
;;;603    	/* 开始将系统的资料搬到到内存中，每次移动一个 word */
;;;604    	calc_len = (SendLength + 1) >> 1;
0004d0  1c58              ADDS     r0,r3,#1
0004d2  0840              LSRS     r0,r0,#1
;;;605    	for(i = 0; i < calc_len; i++)
0004d4  2200              MOVS     r2,#0
;;;606    		NET_REG_DATA = SendData[i];
0004d6  4931              LDR      r1,|L1.1436|
0004d8  e004              B        |L1.1252|
                  |L1.1242|
0004da  f8345012          LDRH     r5,[r4,r2,LSL #1]
0004de  800d              STRH     r5,[r1,#0]
0004e0  1c52              ADDS     r2,r2,#1
0004e2  b292              UXTH     r2,r2                 ;605
                  |L1.1252|
0004e4  4282              CMP      r2,r0                 ;605
0004e6  d3f8              BCC      |L1.1242|
;;;607    		
;;;608    	dm9k_WriteReg(DM9000_REG_TXPLH, (SendLength >> 8) & 0xff);	/* 设置传送封包的长度 */
0004e8  0a19              LSRS     r1,r3,#8
0004ea  20fd              MOVS     r0,#0xfd
0004ec  f7fffffe          BL       dm9k_WriteReg
;;;609    	dm9k_WriteReg(DM9000_REG_TXPLL, SendLength & 0xff);
0004f0  b2d9              UXTB     r1,r3
0004f2  20fc              MOVS     r0,#0xfc
0004f4  f7fffffe          BL       dm9k_WriteReg
;;;610    	dm9k_WriteReg(DM9000_REG_TCR, DM9000_TCR_SET);				/* 进行传送 */
0004f8  2101              MOVS     r1,#1
0004fa  2002              MOVS     r0,#2
0004fc  f7fffffe          BL       dm9k_WriteReg
;;;611    	timer2=bsp_GetTickCount();
000500  f7fffffe          BL       bsp_GetTickCount
000504  4604              MOV      r4,r0
;;;612    	while(dm9k_ReadReg(DM9000_REG_TCR)&0x01)
000506  e004              B        |L1.1298|
                  |L1.1288|
;;;613    	   {  
;;;614    			if(bsp_GetTickCount()-timer2>=100)
000508  f7fffffe          BL       bsp_GetTickCount
00050c  1b00              SUBS     r0,r0,r4
00050e  2864              CMP      r0,#0x64
000510  d204              BCS      |L1.1308|
                  |L1.1298|
000512  2002              MOVS     r0,#2                 ;612
000514  f7fffffe          BL       dm9k_ReadReg
000518  07c0              LSLS     r0,r0,#31             ;612
00051a  d1f5              BNE      |L1.1288|
                  |L1.1308|
;;;615    				 break;
;;;616    		 }
;;;617    	dm9k_WriteReg(DM9000_REG_NSR, 0x2c);
00051c  212c              MOVS     r1,#0x2c
00051e  2001              MOVS     r0,#1
000520  f7fffffe          BL       dm9k_WriteReg
;;;618    	dm9k_WriteReg(DM9000_REG_IMR , DM9000_IMR_OFF);
000524  e8bd4070          POP      {r4-r6,lr}
000528  2180              MOVS     r1,#0x80
00052a  20ff              MOVS     r0,#0xff
00052c  e7fe              B        dm9k_WriteReg
;;;619    //	dm9k_err_reset();
;;;620    	return;
;;;621    }
;;;622    /*
                          ENDP

                  dm9k_interrupt PROC
;;;629    */
;;;630    void  dm9k_interrupt(void)
00052e  b510              PUSH     {r4,lr}
;;;631    {
;;;632    	uint8_t  save_reg;
;;;633    	uint16_t isr_status;
;;;634    
;;;635    	save_reg = NET_REG_ADDR;							/* 暂存所使用的位置 */
000530  4c17              LDR      r4,|L1.1424|
000532  8820              LDRH     r0,[r4,#0]
;;;636    	dm9k_WriteReg(DM9000_REG_IMR , DM9000_IMR_OFF);				/* 关闭 DM9000A 中断 */
000534  2180              MOVS     r1,#0x80
000536  b2c3              UXTB     r3,r0                 ;635
000538  20ff              MOVS     r0,#0xff
00053a  f7fffffe          BL       dm9k_WriteReg
;;;637    	isr_status = dm9k_ReadReg(DM9000_REG_ISR);					/* 取得中断产生值 */
00053e  20fe              MOVS     r0,#0xfe
000540  f7fffffe          BL       dm9k_ReadReg
;;;638    
;;;639    	if (isr_status & DM9000_RX_INTR)
;;;640    	{ 					/* 检查是否为接收中断 */
;;;641    		//dm9k_receive_packet();							/* 执行接收处理程序 */
;;;642    	}
;;;643    	dm9k_WriteReg(DM9000_REG_IMR , DM9000_IMR_SET);				/* 开启 DM9000A 中断 */
000544  2181              MOVS     r1,#0x81
000546  20ff              MOVS     r0,#0xff
000548  f7fffffe          BL       dm9k_WriteReg
;;;644    	NET_REG_ADDR = save_reg;							/* 回复所使用的位置 */
00054c  8023              STRH     r3,[r4,#0]
;;;645    
;;;646    }
00054e  bd10              POP      {r4,pc}
;;;647    /**
                          ENDP

                  dm9k_ReadID PROC
;;;667    */
;;;668    uint32_t dm9k_ReadID(void)
000550  b510              PUSH     {r4,lr}
;;;669    {
;;;670    	uint8_t vid1,vid2,pid1,pid2;
;;;671    
;;;672    	if (s_FSMC_Init_Ok == 0)
000552  4c10              LDR      r4,|L1.1428|
000554  7860              LDRB     r0,[r4,#1]  ; s_FSMC_Init_Ok
000556  b928              CBNZ     r0,|L1.1380|
;;;673    	{
;;;674    		DM9K_CtrlLinesConfig();
000558  f7fffffe          BL       DM9K_CtrlLinesConfig
;;;675    		DM9K_FSMCConfig();
00055c  f7fffffe          BL       DM9K_FSMCConfig
;;;676    
;;;677    		s_FSMC_Init_Ok = 1;
000560  2001              MOVS     r0,#1
000562  7060              STRB     r0,[r4,#1]
                  |L1.1380|
;;;678    	}
;;;679    	vid1 = dm9k_ReadReg(DM9000_REG_VID_L) & 0xFF;
000564  2028              MOVS     r0,#0x28
000566  f7fffffe          BL       dm9k_ReadReg
00056a  4602              MOV      r2,r0
;;;680    	vid2 = dm9k_ReadReg(DM9000_REG_VID_H) & 0xFF;
00056c  2029              MOVS     r0,#0x29
00056e  f7fffffe          BL       dm9k_ReadReg
000572  4603              MOV      r3,r0
;;;681    	pid1 = dm9k_ReadReg(DM9000_REG_PID_L) & 0xFF;
000574  202a              MOVS     r0,#0x2a
000576  f7fffffe          BL       dm9k_ReadReg
00057a  4604              MOV      r4,r0
;;;682    	pid2 = dm9k_ReadReg(DM9000_REG_PID_H) & 0xFF;
00057c  202b              MOVS     r0,#0x2b
00057e  f7fffffe          BL       dm9k_ReadReg
;;;683    	return (vid2 << 24) | (vid1 << 16) | (pid2 << 8) | pid1;
000582  0619              LSLS     r1,r3,#24
000584  ea414102          ORR      r1,r1,r2,LSL #16
000588  ea412000          ORR      r0,r1,r0,LSL #8
00058c  4320              ORRS     r0,r0,r4
;;;684    }
00058e  bd10              POP      {r4,pc}
;;;685    
                          ENDP

                  |L1.1424|
                          DCD      0x68400000
                  |L1.1428|
                          DCD      ||.data||
                  |L1.1432|
                          DCD      ||.bss||
                  |L1.1436|
                          DCD      0x68480000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  receiveBuffer_DM9000
                          %        200

                          AREA ||area_number.4||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.4||, ||.bss||
                  receiveBuffer
                          %        200

                          AREA ||.data||, DATA, ALIGN=1

                  SendPackOk
000000  00                DCB      0x00
                  s_FSMC_Init_Ok
000001  00                DCB      0x00
                  receiveLen_DM9000
000002  0000              DCB      0x00,0x00
                  DEF_MAC_ADDR
000004  01020102          DCB      0x01,0x02,0x01,0x02
000008  0102              DCB      0x01,0x02

                          AREA ||area_number.7||, DATA, ALIGN=1

                          EXPORTAS ||area_number.7||, ||.data||
                  receiveLen
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\HARDWARE\\dm9k_uip.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_dm9k_uip_c_75898a95____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___10_dm9k_uip_c_75898a95____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_dm9k_uip_c_75898a95____REVSH|
#line 144
|__asm___10_dm9k_uip_c_75898a95____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
