; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\ethercatmain.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\ethercatmain.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\FWLIB\STM32F4xx_StdPeriph_Driver\inc -I..\USER -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\ETHERNET -I..\HARDWARE\TIMER -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\RTC -I..\HARDWARE\ADC -I..\HARDWARE\SRAM -I..\HARDWARE\InterTemperate -I..\FWLIB\STM32F4x7_ETH_Driver\inc -I..\MALLOC -I..\USMART -I..\HARDWARE -I..\ETHERCAT -I.\RTE\_LWIP -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS --omf_browse=..\obj\ethercatmain.crf ..\ETHERCAT\ethercatmain.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ecx_pusherror PROC
;;;166     */
;;;167    void ecx_pusherror(ecx_contextt *context, const ec_errort *Ec)
000000  b570              PUSH     {r4-r6,lr}
;;;168    {
;;;169       context->elist->Error[context->elist->head] = *Ec;
000002  6a42              LDR      r2,[r0,#0x24]
000004  2404              MOVS     r4,#4
000006  f9b23000          LDRSH    r3,[r2,#0]
00000a  eb041303          ADD      r3,r4,r3,LSL #4
00000e  441a              ADD      r2,r2,r3
000010  c96a              LDM      r1,{r1,r3,r5,r6}
000012  e882006a          STM      r2,{r1,r3,r5,r6}
;;;170       context->elist->Error[context->elist->head].Signal = TRUE;
000016  6a41              LDR      r1,[r0,#0x24]
000018  2301              MOVS     r3,#1
00001a  f9b12000          LDRSH    r2,[r1,#0]
00001e  eb041202          ADD      r2,r4,r2,LSL #4
;;;171       context->elist->head++;
;;;172       if (context->elist->head > EC_MAXELIST)
000022  2400              MOVS     r4,#0
000024  548b              STRB     r3,[r1,r2]            ;170
000026  6a41              LDR      r1,[r0,#0x24]         ;171
000028  880a              LDRH     r2,[r1,#0]            ;171
00002a  1c52              ADDS     r2,r2,#1              ;171
00002c  b212              SXTH     r2,r2                 ;171
00002e  800a              STRH     r2,[r1,#0]            ;171
000030  6a41              LDR      r1,[r0,#0x24]
000032  2a40              CMP      r2,#0x40
000034  dd00              BLE      |L1.56|
;;;173       {
;;;174          context->elist->head = 0;
000036  800c              STRH     r4,[r1,#0]
                  |L1.56|
;;;175       }
;;;176       if (context->elist->head == context->elist->tail)
000038  6a41              LDR      r1,[r0,#0x24]
00003a  f9b15000          LDRSH    r5,[r1,#0]
00003e  f9b12002          LDRSH    r2,[r1,#2]
000042  4295              CMP      r5,r2
000044  d101              BNE      |L1.74|
000046  1c52              ADDS     r2,r2,#1
;;;177       {
;;;178          context->elist->tail++;
000048  804a              STRH     r2,[r1,#2]
                  |L1.74|
;;;179       }
;;;180       if (context->elist->tail > EC_MAXELIST)
00004a  6a41              LDR      r1,[r0,#0x24]
00004c  f9b12002          LDRSH    r2,[r1,#2]
000050  2a40              CMP      r2,#0x40
000052  dd00              BLE      |L1.86|
;;;181       {
;;;182          context->elist->tail = 0;
000054  804c              STRH     r4,[r1,#2]
                  |L1.86|
;;;183       }
;;;184       *(context->ecaterror) = TRUE;
000056  6ac0              LDR      r0,[r0,#0x2c]
000058  7003              STRB     r3,[r0,#0]
;;;185    }
00005a  bd70              POP      {r4-r6,pc}
;;;186    
                          ENDP

                  ecx_poperror PROC
;;;192     */
;;;193    boolean ecx_poperror(ecx_contextt *context, ec_errort *Ec)
00005c  b5f0              PUSH     {r4-r7,lr}
;;;194    {
;;;195       boolean notEmpty = (context->elist->head != context->elist->tail);
00005e  6a42              LDR      r2,[r0,#0x24]
000060  f9b23000          LDRSH    r3,[r2,#0]
000064  f9b24002          LDRSH    r4,[r2,#2]
000068  42a3              CMP      r3,r4
00006a  d001              BEQ      |L1.112|
00006c  2301              MOVS     r3,#1
00006e  e000              B        |L1.114|
                  |L1.112|
000070  2300              MOVS     r3,#0
                  |L1.114|
;;;196    
;;;197       *Ec = context->elist->Error[context->elist->tail];
000072  2504              MOVS     r5,#4
000074  eb051404          ADD      r4,r5,r4,LSL #4
000078  4422              ADD      r2,r2,r4
00007a  cad4              LDM      r2,{r2,r4,r6,r7}
00007c  e88100d4          STM      r1,{r2,r4,r6,r7}
;;;198       context->elist->Error[context->elist->tail].Signal = FALSE;
000080  6a41              LDR      r1,[r0,#0x24]
000082  2400              MOVS     r4,#0
000084  f9b12002          LDRSH    r2,[r1,#2]
000088  eb051202          ADD      r2,r5,r2,LSL #4
00008c  548c              STRB     r4,[r1,r2]
;;;199       if (notEmpty)
00008e  b14b              CBZ      r3,|L1.164|
;;;200       {
;;;201          context->elist->tail++;
000090  6a42              LDR      r2,[r0,#0x24]
000092  8851              LDRH     r1,[r2,#2]
000094  1c49              ADDS     r1,r1,#1
000096  b209              SXTH     r1,r1
000098  8051              STRH     r1,[r2,#2]
;;;202          if (context->elist->tail > EC_MAXELIST)
00009a  6a40              LDR      r0,[r0,#0x24]
00009c  2940              CMP      r1,#0x40
00009e  dd03              BLE      |L1.168|
;;;203          {
;;;204             context->elist->tail = 0;
0000a0  8044              STRH     r4,[r0,#2]
0000a2  e001              B        |L1.168|
                  |L1.164|
;;;205          }
;;;206       }
;;;207       else
;;;208       {
;;;209          *(context->ecaterror) = FALSE;
0000a4  6ac0              LDR      r0,[r0,#0x2c]
0000a6  7004              STRB     r4,[r0,#0]
                  |L1.168|
;;;210       }
;;;211       return notEmpty;
0000a8  4618              MOV      r0,r3
;;;212    }
0000aa  bdf0              POP      {r4-r7,pc}
;;;213    
                          ENDP

                  ecx_packeterror PROC
;;;221     */
;;;222    void ecx_packeterror(ecx_contextt *context, uint16 Slave, uint16 Index, uint8 SubIdx, uint16 ErrorCode)
0000ac  b53f              PUSH     {r0-r5,lr}
;;;223    {
;;;224       ec_errort Ec;
;;;225    
;;;226       memset(&Ec, 0, sizeof(Ec));
0000ae  2400              MOVS     r4,#0
0000b0  9401              STR      r4,[sp,#4]
0000b2  9d07              LDR      r5,[sp,#0x1c]
0000b4  9400              STR      r4,[sp,#0]
;;;227       Ec.Slave = Slave;
;;;228       Ec.Index = Index;
0000b6  f8ad2004          STRH     r2,[sp,#4]
0000ba  9402              STR      r4,[sp,#8]            ;226
0000bc  9403              STR      r4,[sp,#0xc]          ;227
0000be  f8ad1002          STRH     r1,[sp,#2]            ;227
;;;229       Ec.SubIdx = SubIdx;
0000c2  f88d3006          STRB     r3,[sp,#6]
;;;230       *(context->ecaterror) = TRUE;
0000c6  6ac2              LDR      r2,[r0,#0x2c]
0000c8  2101              MOVS     r1,#1
0000ca  7011              STRB     r1,[r2,#0]
;;;231       Ec.Etype = EC_ERR_TYPE_PACKET_ERROR;
0000cc  2103              MOVS     r1,#3
0000ce  f88d1007          STRB     r1,[sp,#7]
;;;232       Ec.ErrorCode = ErrorCode;
0000d2  f8ad5008          STRH     r5,[sp,#8]
;;;233       ecx_pusherror(context, &Ec);
0000d6  4669              MOV      r1,sp
0000d8  f7fffffe          BL       ecx_pusherror
;;;234    }
0000dc  bd3f              POP      {r0-r5,pc}
;;;235    
                          ENDP

                  ecx_init PROC
;;;287     */
;;;288    int ecx_init(ecx_contextt *context)
0000de  6800              LDR      r0,[r0,#0]
;;;289    {
;;;290       return ecx_setupnic(context->port, FALSE);
0000e0  2100              MOVS     r1,#0
0000e2  f7ffbffe          B.W      ecx_setupnic
;;;291    }
;;;292    /** Initialise lib in redundant NIC mode
                          ENDP

                  ecx_init_redundant PROC
;;;298     */
;;;299    int ecx_init_redundant(ecx_contextt *context, ecx_redportt *redport)
0000e6  b530              PUSH     {r4,r5,lr}
;;;300    {
0000e8  4604              MOV      r4,r0
;;;301       int rval, zbuf;
;;;302       ec_etherheadert *ehp;
;;;303    
;;;304       context->port->redport = redport;
0000ea  6800              LDR      r0,[r0,#0]
0000ec  b085              SUB      sp,sp,#0x14           ;300
0000ee  f5004040          ADD      r0,r0,#0xc000
;;;305       ecx_setupnic(context->port, FALSE);
0000f2  f8c01a88          STR      r1,[r0,#0xa88]
0000f6  2100              MOVS     r1,#0
0000f8  6820              LDR      r0,[r4,#0]
0000fa  f7fffffe          BL       ecx_setupnic
;;;306       rval = ecx_setupnic(context->port, TRUE);
0000fe  2101              MOVS     r1,#1
000100  6820              LDR      r0,[r4,#0]
000102  f7fffffe          BL       ecx_setupnic
000106  4605              MOV      r5,r0
;;;307       /* prepare "dummy" BRD tx frame for redundant operation */
;;;308       ehp = (ec_etherheadert *)&(context->port->txbuf2);
000108  6820              LDR      r0,[r4,#0]
00010a  f24c418c          MOV      r1,#0xc48c
00010e  4408              ADD      r0,r0,r1
;;;309       ehp->sa1 = htons(secMAC[0]);
000110  4afe              LDR      r2,|L1.1292|
;;;310       zbuf = 0;
;;;311       ecx_setupdatagram(context->port, &(context->port->txbuf2), EC_CMD_BRD, 0, 0x0000, 0x0000, 2, &zbuf);
000112  f10d0c04          ADD      r12,sp,#4
000116  ab04              ADD      r3,sp,#0x10
000118  8812              LDRH     r2,[r2,#0]            ;309  ; secMAC
00011a  ba52              REV16    r2,r2                 ;309
00011c  8102              STRH     r2,[r0,#8]            ;309
00011e  2000              MOVS     r0,#0                 ;310
000120  2202              MOVS     r2,#2
000122  9004              STR      r0,[sp,#0x10]
000124  9000              STR      r0,[sp,#0]
000126  e88c000d          STM      r12,{r0,r2,r3}
00012a  6820              LDR      r0,[r4,#0]
00012c  2300              MOVS     r3,#0
00012e  4401              ADD      r1,r1,r0
000130  2207              MOVS     r2,#7
000132  f7fffffe          BL       ecx_setupdatagram
;;;312       context->port->txbuflength2 = ETH_HEADERSIZE + EC_HEADERSIZE + EC_WKCSIZE + 2;
000136  6820              LDR      r0,[r4,#0]
000138  211e              MOVS     r1,#0x1e
00013a  f5004040          ADD      r0,r0,#0xc000
;;;313    
;;;314       return rval;
00013e  f8c01a7c          STR      r1,[r0,#0xa7c]
;;;315    }
000142  b005              ADD      sp,sp,#0x14
000144  4628              MOV      r0,r5                 ;314
000146  bd30              POP      {r4,r5,pc}
;;;316    /** Read one byte from slave EEPROM via cache.
                          ENDP

                  ecx_eeprom_waitnotbusyFP PROC
;;;1167   
;;;1168   uint16 ecx_eeprom_waitnotbusyFP(ecx_contextt *context, uint16 configadr,uint16 *estat, int timeout)
000148  e92d4fff          PUSH     {r0-r11,lr}
;;;1169   {
;;;1170      int wkc, cnt = 0, retval = 0;
00014c  2500              MOVS     r5,#0
00014e  b083              SUB      sp,sp,#0xc            ;1169
000150  4698              MOV      r8,r3                 ;1169
000152  4614              MOV      r4,r2                 ;1169
000154  4681              MOV      r9,r0                 ;1169
000156  462e              MOV      r6,r5
;;;1171      uint32_t timer2;
;;;1172      timer2=bsp_GetTickCount();
000158  f7fffffe          BL       bsp_GetTickCount
00015c  4607              MOV      r7,r0
00015e  46aa              MOV      r10,r5
;;;1173      do
;;;1174      {
;;;1175         if (cnt++)
;;;1176         {
;;;1177            Delay_us(EC_LOCALDELAY);
;;;1178         }
;;;1179         *estat = 0;
;;;1180         wkc=ecx_FPRD(context->port, configadr, ECT_REG_EEPSTAT, sizeof(*estat), estat, EC_TIMEOUTRET);
000160  f44f6bfa          MOV      r11,#0x7d0
                  |L1.356|
000164  1c6d              ADDS     r5,r5,#1
000166  2d01              CMP      r5,#1                 ;1175
000168  d002              BEQ      |L1.368|
00016a  20c8              MOVS     r0,#0xc8              ;1177
00016c  f7fffffe          BL       Delay_us
                  |L1.368|
000170  f8a4a000          STRH     r10,[r4,#0]           ;1179
000174  e9cd4b00          STRD     r4,r11,[sp,#0]        ;1179
000178  2302              MOVS     r3,#2
00017a  f2405202          MOV      r2,#0x502
00017e  f8d90000          LDR      r0,[r9,#0]
000182  9904              LDR      r1,[sp,#0x10]
000184  f7fffffe          BL       ecx_FPRD
;;;1181         *estat = etohs(*estat);
000188  8821              LDRH     r1,[r4,#0]
;;;1182      }
;;;1183      while (((wkc <= 0) || ((*estat & EC_ESTAT_BUSY) > 0)) && ((bsp_GetTickCount()-timer2)<timeout)); /* wait for eeprom ready */
00018a  2800              CMP      r0,#0
00018c  dd01              BLE      |L1.402|
00018e  0408              LSLS     r0,r1,#16
000190  d507              BPL      |L1.418|
                  |L1.402|
000192  f7fffffe          BL       bsp_GetTickCount
000196  1bc1              SUBS     r1,r0,r7
000198  4541              CMP      r1,r8
00019a  d3e3              BCC      |L1.356|
;;;1184      if ((*estat & EC_ESTAT_BUSY) == 0)
00019c  8820              LDRH     r0,[r4,#0]
00019e  0400              LSLS     r0,r0,#16
0001a0  d400              BMI      |L1.420|
                  |L1.418|
;;;1185      {
;;;1186         retval = 1;
0001a2  2601              MOVS     r6,#1
                  |L1.420|
;;;1187      }
;;;1188   
;;;1189      return retval;
;;;1190   }
0001a4  b007              ADD      sp,sp,#0x1c
0001a6  4630              MOV      r0,r6                 ;1189
                  |L1.424|
0001a8  e8bd8ff0          POP      {r4-r11,pc}
;;;1191   
                          ENDP

                  ecx_readeepromFP PROC
;;;1198    */
;;;1199   uint64 ecx_readeepromFP(ecx_contextt *context, uint16 configadr, uint16 eeproma, int timeout)
0001ac  e92d4fff          PUSH     {r0-r11,lr}
;;;1200   {
0001b0  b089              SUB      sp,sp,#0x24
;;;1201      uint16 estat;
;;;1202      uint32 edat32;
;;;1203      uint64 edat64;
;;;1204      ec_eepromt ed;
;;;1205      int wkc, cnt, nackcnt = 0;
0001b2  2600              MOVS     r6,#0
;;;1206   
;;;1207      edat64 = 0;
;;;1208      edat32 = 0;
0001b4  9607              STR      r6,[sp,#0x1c]
0001b6  e9cd6602          STRD     r6,r6,[sp,#8]
0001ba  4693              MOV      r11,r2                ;1200
0001bc  4605              MOV      r5,r0                 ;1200
0001be  4634              MOV      r4,r6
;;;1209      if (ecx_eeprom_waitnotbusyFP(context, configadr, &estat, timeout))
0001c0  aa04              ADD      r2,sp,#0x10
0001c2  9b0c              LDR      r3,[sp,#0x30]
0001c4  990a              LDR      r1,[sp,#0x28]
0001c6  f7fffffe          BL       ecx_eeprom_waitnotbusyFP
0001ca  2800              CMP      r0,#0
0001cc  d075              BEQ      |L1.698|
;;;1210      {
;;;1211         if (estat & EC_ESTAT_EMASK) /* error bits are set */
0001ce  f8bd0010          LDRH     r0,[sp,#0x10]
;;;1212         {
;;;1213            estat = htoes(EC_ECMD_NOP); /* clear error bits */
;;;1214            wkc=ecx_FPWR(context->port, configadr, ECT_REG_EEPCTL, sizeof(estat), &estat, EC_TIMEOUTRET3);
0001d2  f2405702          MOV      r7,#0x502
0001d6  f4104ff0          TST      r0,#0x7800            ;1211
0001da  d00c              BEQ      |L1.502|
0001dc  f2417170          MOV      r1,#0x1770
0001e0  a804              ADD      r0,sp,#0x10
0001e2  e9cd0100          STRD     r0,r1,[sp,#0]
0001e6  f8ad4010          STRH     r4,[sp,#0x10]         ;1213
0001ea  2302              MOVS     r3,#2
0001ec  463a              MOV      r2,r7
0001ee  6828              LDR      r0,[r5,#0]
0001f0  990a              LDR      r1,[sp,#0x28]
0001f2  f7fffffe          BL       ecx_FPWR
                  |L1.502|
;;;1215         }
;;;1216   
;;;1217         do
;;;1218         {
;;;1219            ed.comm = htoes(EC_ECMD_READ);
;;;1220            ed.addr = htoes(eeproma);
;;;1221            ed.d2   = 0x0000;
;;;1222            cnt = 0;
;;;1223            do
;;;1224            {
;;;1225               wkc=ecx_FPWR(context->port, configadr, ECT_REG_EEPCTL, sizeof(ed), &ed, EC_TIMEOUTRET);
0001f6  f44f67fa          MOV      r7,#0x7d0
;;;1226            }
;;;1227            while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
;;;1228            if (wkc)
;;;1229            {
;;;1230               Delay_us(EC_LOCALDELAY);
;;;1231               estat = 0x0000;
;;;1232               if (ecx_eeprom_waitnotbusyFP(context, configadr, &estat, timeout))
;;;1233               {
;;;1234                  if (estat & EC_ESTAT_NACK)
;;;1235                  {
;;;1236                     nackcnt++;
;;;1237                     Delay_us(EC_LOCALDELAY * 5);
;;;1238                  }
;;;1239                  else
;;;1240                  {
;;;1241                     nackcnt = 0;
;;;1242                     if (estat & EC_ESTAT_R64)
;;;1243                     {
;;;1244                        cnt = 0;
;;;1245                        do
;;;1246                        {
;;;1247                           wkc=ecx_FPRD(context->port, configadr, ECT_REG_EEPDAT, sizeof(edat64), &edat64, EC_TIMEOUTRET);
0001fa  f44f6aa1          MOV      r10,#0x508
                  |L1.510|
0001fe  f44f7080          MOV      r0,#0x100             ;1219
000202  f04f0800          MOV      r8,#0                 ;1221
000206  f8ad0014          STRH     r0,[sp,#0x14]         ;1219
00020a  f8adb016          STRH     r11,[sp,#0x16]        ;1220
00020e  f8ad8018          STRH     r8,[sp,#0x18]         ;1221
000212  4644              MOV      r4,r8                 ;1222
000214  f10d0914          ADD      r9,sp,#0x14           ;1204
                  |L1.536|
000218  e9cd9700          STRD     r9,r7,[sp,#0]         ;1204
00021c  2306              MOVS     r3,#6                 ;1225
00021e  f2405202          MOV      r2,#0x502             ;1225
000222  6828              LDR      r0,[r5,#0]            ;1225
000224  990a              LDR      r1,[sp,#0x28]         ;1225
000226  f7fffffe          BL       ecx_FPWR
00022a  2800              CMP      r0,#0                 ;1227
00022c  dc04              BGT      |L1.568|
00022e  4621              MOV      r1,r4                 ;1227
000230  1c64              ADDS     r4,r4,#1              ;1227
000232  2903              CMP      r1,#3                 ;1227
000234  dbf0              BLT      |L1.536|
000236  b348              CBZ      r0,|L1.652|
                  |L1.568|
000238  20c8              MOVS     r0,#0xc8              ;1230
00023a  f7fffffe          BL       Delay_us
00023e  f8ad8010          STRH     r8,[sp,#0x10]         ;1231
000242  aa04              ADD      r2,sp,#0x10           ;1232
000244  4628              MOV      r0,r5                 ;1232
000246  9b0c              LDR      r3,[sp,#0x30]         ;1232
000248  990a              LDR      r1,[sp,#0x28]         ;1232
00024a  f7fffffe          BL       ecx_eeprom_waitnotbusyFP
00024e  b1e8              CBZ      r0,|L1.652|
000250  f8bd0010          LDRH     r0,[sp,#0x10]         ;1234
000254  0481              LSLS     r1,r0,#18             ;1234
000256  d505              BPL      |L1.612|
000258  f44f707a          MOV      r0,#0x3e8             ;1237
00025c  1c76              ADDS     r6,r6,#1              ;1237
00025e  f7fffffe          BL       Delay_us
000262  e027              B        |L1.692|
                  |L1.612|
000264  2600              MOVS     r6,#0                 ;1241
000266  0640              LSLS     r0,r0,#25             ;1242
;;;1248                        }
;;;1249                        while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
;;;1250                     }
;;;1251                     else
;;;1252                     {
;;;1253                        cnt = 0;
000268  4634              MOV      r4,r6
00026a  d510              BPL      |L1.654|
00026c  f10d0808          ADD      r8,sp,#8              ;1247
                  |L1.624|
000270  e9cd8700          STRD     r8,r7,[sp,#0]         ;1247
000274  2308              MOVS     r3,#8                 ;1247
000276  4652              MOV      r2,r10                ;1247
000278  6828              LDR      r0,[r5,#0]            ;1247
00027a  990a              LDR      r1,[sp,#0x28]         ;1247
00027c  f7fffffe          BL       ecx_FPRD
000280  2800              CMP      r0,#0                 ;1249
000282  dc17              BGT      |L1.692|
000284  4620              MOV      r0,r4                 ;1249
000286  1c64              ADDS     r4,r4,#1              ;1249
000288  2803              CMP      r0,#3                 ;1249
00028a  dbf1              BLT      |L1.624|
                  |L1.652|
00028c  e012              B        |L1.692|
                  |L1.654|
;;;1254                        do
;;;1255                        {
;;;1256                           wkc=ecx_FPRD(context->port, configadr, ECT_REG_EEPDAT, sizeof(edat32), &edat32, EC_TIMEOUTRET);
00028e  f10d091c          ADD      r9,sp,#0x1c
                  |L1.658|
000292  e9cd9700          STRD     r9,r7,[sp,#0]
000296  2304              MOVS     r3,#4
000298  4652              MOV      r2,r10
00029a  6828              LDR      r0,[r5,#0]
00029c  990a              LDR      r1,[sp,#0x28]
00029e  f7fffffe          BL       ecx_FPRD
;;;1257                        }
;;;1258                        while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
0002a2  2800              CMP      r0,#0
0002a4  dc03              BGT      |L1.686|
0002a6  4620              MOV      r0,r4
0002a8  1c64              ADDS     r4,r4,#1
0002aa  2803              CMP      r0,#3
0002ac  dbf1              BLT      |L1.658|
                  |L1.686|
;;;1259                        edat64=(uint64)edat32;
0002ae  9907              LDR      r1,[sp,#0x1c]
0002b0  e9cd1802          STRD     r1,r8,[sp,#8]
                  |L1.692|
;;;1260                     }
;;;1261                  }
;;;1262               }
;;;1263            }
;;;1264         }
;;;1265         while ((nackcnt > 0) && (nackcnt < 3));
0002b4  1e70              SUBS     r0,r6,#1
0002b6  2802              CMP      r0,#2
0002b8  d3a1              BCC      |L1.510|
                  |L1.698|
0002ba  e9dd0102          LDRD     r0,r1,[sp,#8]
;;;1266      }
;;;1267   
;;;1268      return edat64;
;;;1269   }
0002be  b00d              ADD      sp,sp,#0x34
0002c0  e772              B        |L1.424|
;;;1270   /** Push index of segmented LRD/LWR/LRW combination.
                          ENDP

                  ecx_eeprom2master PROC
;;;945     */
;;;946    int ecx_eeprom2master(ecx_contextt *context, uint16 slave)
0002c2  e92d4ffe          PUSH     {r1-r11,lr}
;;;947    {
0002c6  4605              MOV      r5,r0
;;;948       int wkc = 1, cnt = 0;
;;;949       uint16 configadr;
;;;950       uint8 eepctl;
;;;951    
;;;952       if ( context->slavelist[slave].eep_pdi )
0002c8  eb0103c1          ADD      r3,r1,r1,LSL #3
0002cc  eb031181          ADD      r1,r3,r1,LSL #6
0002d0  23fb              MOVS     r3,#0xfb
0002d2  686a              LDR      r2,[r5,#4]
0002d4  eb030981          ADD      r9,r3,r1,LSL #2
0002d8  2001              MOVS     r0,#1                 ;948
0002da  f8123009          LDRB     r3,[r2,r9]
0002de  2400              MOVS     r4,#0                 ;948
0002e0  2b00              CMP      r3,#0                 ;947
0002e2  d030              BEQ      |L1.838|
;;;953       {
;;;954          configadr = context->slavelist[slave].configadr;
0002e4  2004              MOVS     r0,#4
0002e6  eb000081          ADD      r0,r0,r1,LSL #2
0002ea  f832b000          LDRH     r11,[r2,r0]
;;;955          eepctl = 2;
0002ee  2002              MOVS     r0,#2
0002f0  f88d0008          STRB     r0,[sp,#8]
;;;956          do
;;;957          {
;;;958             wkc = ecx_FPWR(context->port, configadr, ECT_REG_EEPCFG, sizeof(eepctl), &eepctl , EC_TIMEOUTRET); /* force Eeprom from PDI */
0002f4  f44f67fa          MOV      r7,#0x7d0
0002f8  f44f68a0          MOV      r8,#0x500
                  |L1.764|
0002fc  ae02              ADD      r6,sp,#8
0002fe  e9cd6700          STRD     r6,r7,[sp,#0]
000302  2301              MOVS     r3,#1
000304  4642              MOV      r2,r8
000306  4659              MOV      r1,r11
000308  6828              LDR      r0,[r5,#0]
00030a  f7fffffe          BL       ecx_FPWR
;;;959          }
;;;960          while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
00030e  2800              CMP      r0,#0
000310  dc03              BGT      |L1.794|
000312  4620              MOV      r0,r4
000314  1c64              ADDS     r4,r4,#1
000316  2803              CMP      r0,#3
000318  dbf0              BLT      |L1.764|
                  |L1.794|
;;;961          eepctl = 0;
00031a  f04f0a00          MOV      r10,#0
00031e  f88da008          STRB     r10,[sp,#8]
;;;962          cnt = 0;
000322  4654              MOV      r4,r10
                  |L1.804|
000324  e9cd6700          STRD     r6,r7,[sp,#0]
;;;963          do
;;;964          {
;;;965             wkc = ecx_FPWR(context->port, configadr, ECT_REG_EEPCFG, sizeof(eepctl), &eepctl , EC_TIMEOUTRET); /* set Eeprom to master */
000328  2301              MOVS     r3,#1
00032a  4642              MOV      r2,r8
00032c  4659              MOV      r1,r11
00032e  6828              LDR      r0,[r5,#0]
000330  f7fffffe          BL       ecx_FPWR
;;;966          }
;;;967          while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
000334  2800              CMP      r0,#0
000336  dc03              BGT      |L1.832|
000338  4621              MOV      r1,r4
00033a  1c64              ADDS     r4,r4,#1
00033c  2903              CMP      r1,#3
00033e  dbf1              BLT      |L1.804|
                  |L1.832|
;;;968          context->slavelist[slave].eep_pdi = 0;
000340  686b              LDR      r3,[r5,#4]
000342  f803a009          STRB     r10,[r3,r9]
                  |L1.838|
;;;969       }
;;;970    
;;;971       return wkc;
;;;972    }
000346  e8bd8ffe          POP      {r1-r11,pc}
;;;973    
                          ENDP

                  ecx_siigetbyte PROC
;;;324    //uint8 sdjsdj;
;;;325    uint8 ecx_siigetbyte(ecx_contextt *context, uint16 slave, uint16 address)
00034a  e92d47f0          PUSH     {r4-r10,lr}
;;;326    {
00034e  4604              MOV      r4,r0
;;;327       uint16 configadr, eadr;
;;;328       uint64 edat;
;;;329       uint16 mapw, mapb;
;;;330       int lp,cnt;
;;;331       uint8 retval;
;;;332    
;;;333       retval = 0xff;
;;;334       if (slave != context->esislave) /* not the same slave? */
000350  8c00              LDRH     r0,[r0,#0x20]
000352  460e              MOV      r6,r1                 ;326
000354  27ff              MOVS     r7,#0xff              ;333
000356  4615              MOV      r5,r2                 ;326
000358  42b0              CMP      r0,r6
00035a  d005              BEQ      |L1.872|
;;;335       {
;;;336          memset(context->esimap, 0x00, EC_MAXEEPBITMAP * sizeof(uint32)); /* clear esibuf cache map */
00035c  f44f7100          MOV      r1,#0x200
000360  69e0              LDR      r0,[r4,#0x1c]
000362  f7fffffe          BL       __aeabi_memclr4
;;;337          context->esislave = slave;
000366  8426              STRH     r6,[r4,#0x20]
                  |L1.872|
;;;338       }
;;;339       if (address < EC_MAXEEPBUF)
000368  f5b55f80          CMP      r5,#0x1000
00036c  d20d              BCS      |L1.906|
;;;340       {
;;;341          mapw = address >> 5;
;;;342          mapb = address - (mapw << 5);
;;;343          if (context->esimap[mapw] & (uint32)(1 << mapb))
00036e  69e2              LDR      r2,[r4,#0x1c]
000370  0968              LSRS     r0,r5,#5              ;341
000372  eba51140          SUB      r1,r5,r0,LSL #5       ;342
000376  f8522020          LDR      r2,[r2,r0,LSL #2]
00037a  f04f0901          MOV      r9,#1
00037e  fa09f001          LSL      r0,r9,r1
000382  4202              TST      r2,r0
000384  d004              BEQ      |L1.912|
                  |L1.902|
;;;344          {
;;;345             /* byte is already in buffer */
;;;346             retval = context->esibuf[address];
000386  69a0              LDR      r0,[r4,#0x18]
000388  5d47              LDRB     r7,[r0,r5]
                  |L1.906|
;;;347          }
;;;348          else
;;;349          {
;;;350             /* byte is not in buffer, put it there */
;;;351             configadr = context->slavelist[slave].configadr;
;;;352             ecx_eeprom2master(context, slave); /* set eeprom control to master */
;;;353             eadr = address >> 1;
;;;354             edat = ecx_readeepromFP (context, configadr, eadr, EC_TIMEOUTEEP);
;;;355             /* 8 byte response */
;;;356             if (context->slavelist[slave].eep_8byte)
;;;357             {
;;;358                put_unaligned64(edat, &(context->esibuf[eadr << 1]));
;;;359                cnt = 8;
;;;360             }
;;;361             /* 4 byte response */
;;;362             else
;;;363             {
;;;364                put_unaligned32(edat, &(context->esibuf[eadr << 1]));
;;;365                cnt = 4;
;;;366             }
;;;367             /* find bitmap location */
;;;368             mapw = eadr >> 4;
;;;369             mapb = (eadr << 1) - (mapw << 5);
;;;370             for(lp = 0 ; lp < cnt ; lp++)
;;;371             {
;;;372                /* set bitmap for each byte that is read */
;;;373                context->esimap[mapw] |= (1 << mapb);
;;;374                mapb++;
;;;375                if (mapb > 31)
;;;376                {
;;;377                   mapb = 0;
;;;378                   mapw++;
;;;379                }
;;;380             }
;;;381             retval = context->esibuf[address];
;;;382          }
;;;383       }
;;;384    //   sdjsdj=retval;
;;;385       return retval;
00038a  4638              MOV      r0,r7
                  |L1.908|
;;;386    }
00038c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.912|
000390  eb0601c6          ADD      r1,r6,r6,LSL #3       ;351
000394  eb011786          ADD      r7,r1,r6,LSL #6       ;351
000398  6860              LDR      r0,[r4,#4]            ;351
00039a  2104              MOVS     r1,#4                 ;351
00039c  eb010187          ADD      r1,r1,r7,LSL #2       ;351
0003a0  f8308001          LDRH     r8,[r0,r1]            ;351
0003a4  4631              MOV      r1,r6                 ;352
0003a6  4620              MOV      r0,r4                 ;352
0003a8  f7fffffe          BL       ecx_eeprom2master
0003ac  086e              LSRS     r6,r5,#1              ;353
0003ae  f6446320          MOV      r3,#0x4e20            ;354
0003b2  4632              MOV      r2,r6                 ;354
0003b4  4641              MOV      r1,r8                 ;354
0003b6  4620              MOV      r0,r4                 ;354
0003b8  f7fffffe          BL       ecx_readeepromFP
0003bc  23fa              MOVS     r3,#0xfa              ;356
0003be  6862              LDR      r2,[r4,#4]            ;356
0003c0  eb030387          ADD      r3,r3,r7,LSL #2       ;356
0003c4  5cd2              LDRB     r2,[r2,r3]            ;356
0003c6  b132              CBZ      r2,|L1.982|
0003c8  69a2              LDR      r2,[r4,#0x18]         ;358
0003ca  2708              MOVS     r7,#8                 ;359
0003cc  eb020246          ADD      r2,r2,r6,LSL #1       ;358
0003d0  6010              STR      r0,[r2,#0]            ;358
0003d2  6051              STR      r1,[r2,#4]            ;358
0003d4  e004              B        |L1.992|
                  |L1.982|
0003d6  69a1              LDR      r1,[r4,#0x18]         ;364
0003d8  2704              MOVS     r7,#4                 ;365
0003da  eb010146          ADD      r1,r1,r6,LSL #1       ;364
0003de  6008              STR      r0,[r1,#0]            ;364
                  |L1.992|
0003e0  0931              LSRS     r1,r6,#4              ;368
0003e2  0070              LSLS     r0,r6,#1              ;369
0003e4  eba01041          SUB      r0,r0,r1,LSL #5       ;369
0003e8  b280              UXTH     r0,r0                 ;369
0003ea  2200              MOVS     r2,#0                 ;370
0003ec  464e              MOV      r6,r9                 ;343
0003ee  e010              B        |L1.1042|
                  |L1.1008|
0003f0  69e3              LDR      r3,[r4,#0x1c]         ;373
0003f2  fa06f800          LSL      r8,r6,r0              ;373
0003f6  1c40              ADDS     r0,r0,#1              ;373
0003f8  f853c021          LDR      r12,[r3,r1,LSL #2]    ;373
0003fc  b280              UXTH     r0,r0                 ;374
0003fe  ea4c0c08          ORR      r12,r12,r8            ;373
000402  f843c021          STR      r12,[r3,r1,LSL #2]    ;373
000406  281f              CMP      r0,#0x1f              ;375
000408  d902              BLS      |L1.1040|
00040a  2000              MOVS     r0,#0                 ;377
00040c  1c49              ADDS     r1,r1,#1              ;377
00040e  b289              UXTH     r1,r1                 ;378
                  |L1.1040|
000410  1c52              ADDS     r2,r2,#1              ;378
                  |L1.1042|
000412  42ba              CMP      r2,r7                 ;370
000414  dbec              BLT      |L1.1008|
000416  e7b6              B        |L1.902|
;;;387    
                          ENDP

                  ecx_eeprom2pdi PROC
;;;978     */
;;;979    int ecx_eeprom2pdi(ecx_contextt *context, uint16 slave)
000418  e92d4ffe          PUSH     {r1-r11,lr}
;;;980    {
00041c  4605              MOV      r5,r0
;;;981       int wkc = 1, cnt = 0;
;;;982       uint16 configadr;
;;;983       uint8 eepctl;
;;;984    
;;;985       if ( !context->slavelist[slave].eep_pdi )
00041e  eb0103c1          ADD      r3,r1,r1,LSL #3
000422  eb031181          ADD      r1,r3,r1,LSL #6
000426  23fb              MOVS     r3,#0xfb
000428  686a              LDR      r2,[r5,#4]
00042a  eb030681          ADD      r6,r3,r1,LSL #2
00042e  2001              MOVS     r0,#1                 ;981
000430  5d93              LDRB     r3,[r2,r6]
000432  2400              MOVS     r4,#0                 ;981
000434  2b00              CMP      r3,#0                 ;980
000436  d186              BNE      |L1.838|
;;;986       {
;;;987          configadr = context->slavelist[slave].configadr;
000438  2004              MOVS     r0,#4
00043a  eb000081          ADD      r0,r0,r1,LSL #2
00043e  f8329000          LDRH     r9,[r2,r0]
;;;988          eepctl = 1;
000442  2701              MOVS     r7,#1
000444  f88d7008          STRB     r7,[sp,#8]
;;;989          do
;;;990          {
;;;991             wkc = ecx_FPWR(context->port, configadr, ECT_REG_EEPCFG, sizeof(eepctl), &eepctl , EC_TIMEOUTRET); /* set Eeprom to PDI */
000448  f44f68fa          MOV      r8,#0x7d0
00044c  f44f6aa0          MOV      r10,#0x500
                  |L1.1104|
000450  a902              ADD      r1,sp,#8
000452  e9cd1800          STRD     r1,r8,[sp,#0]
000456  2301              MOVS     r3,#1
000458  4652              MOV      r2,r10
00045a  4649              MOV      r1,r9
00045c  6828              LDR      r0,[r5,#0]
00045e  f7fffffe          BL       ecx_FPWR
;;;992          }
;;;993          while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
000462  2800              CMP      r0,#0
000464  dc03              BGT      |L1.1134|
000466  4621              MOV      r1,r4
000468  1c64              ADDS     r4,r4,#1
00046a  2903              CMP      r1,#3
00046c  dbf0              BLT      |L1.1104|
                  |L1.1134|
;;;994          context->slavelist[slave].eep_pdi = 1;
00046e  6869              LDR      r1,[r5,#4]
000470  558f              STRB     r7,[r1,r6]
;;;995       }
;;;996    
;;;997       return wkc;
;;;998    }
000472  e768              B        |L1.838|
;;;999    
                          ENDP

                  ecx_siifind PROC
;;;393     */
;;;394    int16 ecx_siifind(ecx_contextt *context, uint16 slave, uint16 cat)
000474  e92d47f0          PUSH     {r4-r10,lr}
;;;395    {
000478  4689              MOV      r9,r1
00047a  4615              MOV      r5,r2
00047c  4682              MOV      r10,r0
;;;396       int16 a;
;;;397       uint16 p;
;;;398       uint8 eectl = context->slavelist[slave].eep_pdi;
00047e  eb0902c9          ADD      r2,r9,r9,LSL #3
000482  6841              LDR      r1,[r0,#4]
000484  eb021089          ADD      r0,r2,r9,LSL #6
000488  22fb              MOVS     r2,#0xfb
00048a  eb020080          ADD      r0,r2,r0,LSL #2
;;;399    
;;;400       a = ECT_SII_START << 1;
;;;401       /* read first SII section category */
;;;402       p = ecx_siigetbyte(context, slave, a++);
00048e  2280              MOVS     r2,#0x80
000490  5c0e              LDRB     r6,[r1,r0]            ;398
000492  2781              MOVS     r7,#0x81
000494  4649              MOV      r1,r9
000496  4650              MOV      r0,r10
000498  f7fffffe          BL       ecx_siigetbyte
00049c  4680              MOV      r8,r0
;;;403       p += (ecx_siigetbyte(context, slave, a++) << 8);
00049e  2482              MOVS     r4,#0x82
0004a0  463a              MOV      r2,r7
0004a2  4649              MOV      r1,r9
0004a4  4650              MOV      r0,r10
0004a6  f7fffffe          BL       ecx_siigetbyte
0004aa  eb082000          ADD      r0,r8,r0,LSL #8
;;;404       /* traverse SII while category is not found and not EOF */
;;;405       while ((p != cat) && (p != 0xffff))
0004ae  e020              B        |L1.1266|
                  |L1.1200|
;;;406       {
;;;407          /* read section length */
;;;408          p = ecx_siigetbyte(context, slave, a++);
0004b0  b2a2              UXTH     r2,r4
0004b2  4649              MOV      r1,r9
0004b4  4650              MOV      r0,r10
0004b6  1c64              ADDS     r4,r4,#1
0004b8  f7fffffe          BL       ecx_siigetbyte
0004bc  4607              MOV      r7,r0
;;;409          p += (ecx_siigetbyte(context, slave, a++) << 8);
0004be  b2a2              UXTH     r2,r4
0004c0  4649              MOV      r1,r9
0004c2  4650              MOV      r0,r10
0004c4  1c64              ADDS     r4,r4,#1
0004c6  f7fffffe          BL       ecx_siigetbyte
0004ca  eb072000          ADD      r0,r7,r0,LSL #8
;;;410          /* locate next section category */
;;;411          a += p << 1;
0004ce  eb040440          ADD      r4,r4,r0,LSL #1
;;;412          /* read section category */
;;;413          p = ecx_siigetbyte(context, slave, a++);
0004d2  b2a2              UXTH     r2,r4
0004d4  4649              MOV      r1,r9
0004d6  4650              MOV      r0,r10
0004d8  1c64              ADDS     r4,r4,#1
0004da  f7fffffe          BL       ecx_siigetbyte
;;;414          p += (ecx_siigetbyte(context, slave, a++) << 8);
0004de  b2a2              UXTH     r2,r4
0004e0  4607              MOV      r7,r0                 ;413
0004e2  1c64              ADDS     r4,r4,#1
0004e4  b224              SXTH     r4,r4
0004e6  4649              MOV      r1,r9
0004e8  4650              MOV      r0,r10
0004ea  f7fffffe          BL       ecx_siigetbyte
0004ee  eb072000          ADD      r0,r7,r0,LSL #8
                  |L1.1266|
0004f2  b280              UXTH     r0,r0                 ;403
0004f4  42a8              CMP      r0,r5                 ;405
0004f6  d003              BEQ      |L1.1280|
0004f8  f5a0417f          SUB      r1,r0,#0xff00         ;405
0004fc  39ff              SUBS     r1,r1,#0xff           ;405
0004fe  d1d7              BNE      |L1.1200|
                  |L1.1280|
;;;415       }
;;;416       if (p != cat)
000500  42a8              CMP      r0,r5
000502  d000              BEQ      |L1.1286|
;;;417       {
;;;418          a = 0;
000504  2400              MOVS     r4,#0
                  |L1.1286|
;;;419       }
;;;420       if (eectl)
000506  b136              CBZ      r6,|L1.1302|
;;;421       {
;;;422          ecx_eeprom2pdi(context, slave); /* if eeprom control was previously pdi then restore */
000508  4649              MOV      r1,r9
00050a  e001              B        |L1.1296|
                  |L1.1292|
                          DCD      secMAC
                  |L1.1296|
000510  4650              MOV      r0,r10
000512  f7fffffe          BL       ecx_eeprom2pdi
                  |L1.1302|
;;;423       }
;;;424    
;;;425       return a;
000516  4620              MOV      r0,r4
;;;426    }
000518  e738              B        |L1.908|
;;;427    
                          ENDP

                  ecx_siistring PROC
;;;433     */
;;;434    void ecx_siistring(ecx_contextt *context, char *str, uint16 slave, uint16 Sn)
00051a  e92d5fff          PUSH     {r0-r12,lr}
;;;435    {
00051e  468a              MOV      r10,r1
;;;436       uint16 a,i,j,l,n,ba;
;;;437       char *ptr;
;;;438       uint8 eectl = context->slavelist[slave].eep_pdi;
000520  9800              LDR      r0,[sp,#0]
000522  4699              MOV      r9,r3                 ;435
;;;439    
;;;440       ptr = str;
000524  4655              MOV      r5,r10
000526  6841              LDR      r1,[r0,#4]            ;438
000528  9802              LDR      r0,[sp,#8]            ;438
00052a  eb0002c0          ADD      r2,r0,r0,LSL #3       ;438
00052e  eb021080          ADD      r0,r2,r0,LSL #6       ;438
000532  22fb              MOVS     r2,#0xfb              ;438
000534  eb020080          ADD      r0,r2,r0,LSL #2       ;438
;;;441       a = ecx_siifind (context, slave, ECT_SII_STRING); /* find string section */
000538  220a              MOVS     r2,#0xa
00053a  f811b000          LDRB     r11,[r1,r0]           ;438
00053e  9902              LDR      r1,[sp,#8]
000540  9800              LDR      r0,[sp,#0]
000542  f7fffffe          BL       ecx_siifind
000546  0400              LSLS     r0,r0,#16
000548  0c00              LSRS     r0,r0,#16
;;;442       if (a > 0)
00054a  d034              BEQ      |L1.1462|
00054c  1c80              ADDS     r0,r0,#2
;;;443       {
;;;444          ba = a + 2; /* skip SII section header */
00054e  b282              UXTH     r2,r0
;;;445          n = ecx_siigetbyte(context, slave, ba++); /* read number of strings in section */
000550  1c50              ADDS     r0,r2,#1
000552  b284              UXTH     r4,r0
000554  9902              LDR      r1,[sp,#8]
000556  9800              LDR      r0,[sp,#0]
000558  f7fffffe          BL       ecx_siigetbyte
;;;446          if (Sn <= n) /* is req string available? */
00055c  4581              CMP      r9,r0
00055e  d828              BHI      |L1.1458|
;;;447          {
;;;448             for (i = 1; i <= Sn; i++) /* walk through strings */
000560  2701              MOVS     r7,#1
000562  e024              B        |L1.1454|
                  |L1.1380|
;;;449             {
;;;450                l = ecx_siigetbyte(context, slave, ba++); /* length of this string */
000564  4622              MOV      r2,r4
000566  1c64              ADDS     r4,r4,#1
000568  b2a4              UXTH     r4,r4
00056a  9902              LDR      r1,[sp,#8]
00056c  9800              LDR      r0,[sp,#0]
00056e  f7fffffe          BL       ecx_siigetbyte
000572  4680              MOV      r8,r0
;;;451                if (i < Sn)
000574  454f              CMP      r7,r9
000576  d203              BCS      |L1.1408|
;;;452                {
;;;453                   ba += l;
000578  eb040008          ADD      r0,r4,r8
00057c  b284              UXTH     r4,r0
00057e  e014              B        |L1.1450|
                  |L1.1408|
;;;454                }
;;;455                else
;;;456                {
;;;457                   ptr = str;
000580  4655              MOV      r5,r10
;;;458                   for (j = 1; j <= l; j++) /* copy one string */
000582  2601              MOVS     r6,#1
000584  e00f              B        |L1.1446|
                  |L1.1414|
;;;459                   {
;;;460                      if(j <= EC_MAXNAME)
000586  2e14              CMP      r6,#0x14
000588  d809              BHI      |L1.1438|
;;;461                      {
;;;462                         *ptr = (char)ecx_siigetbyte(context, slave, ba++);
00058a  4622              MOV      r2,r4
00058c  1c64              ADDS     r4,r4,#1
00058e  b2a4              UXTH     r4,r4
000590  9902              LDR      r1,[sp,#8]
000592  9800              LDR      r0,[sp,#0]
000594  f7fffffe          BL       ecx_siigetbyte
000598  f8050b01          STRB     r0,[r5],#1
;;;463                         ptr++;
00059c  e001              B        |L1.1442|
                  |L1.1438|
00059e  1c64              ADDS     r4,r4,#1
;;;464                      }
;;;465                      else
;;;466                      {
;;;467                         ba++;
0005a0  b2a4              UXTH     r4,r4
                  |L1.1442|
0005a2  1c76              ADDS     r6,r6,#1
0005a4  b2b6              UXTH     r6,r6                 ;458
                  |L1.1446|
0005a6  4546              CMP      r6,r8                 ;458
0005a8  d9ed              BLS      |L1.1414|
                  |L1.1450|
0005aa  1c7f              ADDS     r7,r7,#1              ;458
0005ac  b2bf              UXTH     r7,r7                 ;448
                  |L1.1454|
0005ae  454f              CMP      r7,r9                 ;448
0005b0  d9d8              BLS      |L1.1380|
                  |L1.1458|
;;;468                      }
;;;469                   }
;;;470                }
;;;471             }
;;;472             *ptr = 0; /* add zero terminator */
0005b2  2000              MOVS     r0,#0
0005b4  7028              STRB     r0,[r5,#0]
                  |L1.1462|
;;;473          }
;;;474          else
;;;475          {
;;;476             ptr = str;
;;;477             *ptr = 0; /* empty string */
;;;478          }
;;;479       }
;;;480       if (eectl)
0005b6  f1bb0f00          CMP      r11,#0
0005ba  d005              BEQ      |L1.1480|
;;;481       {
;;;482          ecx_eeprom2pdi(context, slave); /* if eeprom control was previously pdi then restore */
0005bc  9902              LDR      r1,[sp,#8]
0005be  9800              LDR      r0,[sp,#0]
0005c0  b004              ADD      sp,sp,#0x10
0005c2  e8bd5ff0          POP      {r4-r12,lr}
0005c6  e7fe              B        ecx_eeprom2pdi
                  |L1.1480|
;;;483       }
;;;484    }
0005c8  e8bd9fff          POP      {r0-r12,pc}
;;;485    
                          ENDP

                  ecx_siiFMMU PROC
;;;491     */
;;;492    uint16 ecx_siiFMMU(ecx_contextt *context, uint16 slave, ec_eepromFMMUt* FMMU)
0005cc  e92d47f0          PUSH     {r4-r10,lr}
;;;493    {
0005d0  460f              MOV      r7,r1
0005d2  4614              MOV      r4,r2
0005d4  4681              MOV      r9,r0
;;;494       uint16  a;
;;;495       uint8 eectl = context->slavelist[slave].eep_pdi;
0005d6  eb0101c7          ADD      r1,r1,r7,LSL #3
0005da  6840              LDR      r0,[r0,#4]
0005dc  eb011187          ADD      r1,r1,r7,LSL #6
0005e0  22fb              MOVS     r2,#0xfb
0005e2  eb020181          ADD      r1,r2,r1,LSL #2
;;;496    
;;;497       FMMU->nFMMU = 0;
;;;498       FMMU->FMMU0 = 0;
;;;499       FMMU->FMMU1 = 0;
;;;500       FMMU->FMMU2 = 0;
;;;501       FMMU->FMMU3 = 0;
;;;502       FMMU->Startpos = ecx_siifind(context, slave, ECT_SII_FMMU);
0005e6  2228              MOVS     r2,#0x28
0005e8  5c46              LDRB     r6,[r0,r1]            ;495
0005ea  2000              MOVS     r0,#0                 ;497
0005ec  70a0              STRB     r0,[r4,#2]            ;497
0005ee  70e0              STRB     r0,[r4,#3]            ;498
0005f0  7120              STRB     r0,[r4,#4]            ;499
0005f2  7160              STRB     r0,[r4,#5]            ;500
0005f4  71a0              STRB     r0,[r4,#6]            ;501
0005f6  4639              MOV      r1,r7
0005f8  4648              MOV      r0,r9
0005fa  f7fffffe          BL       ecx_siifind
0005fe  0402              LSLS     r2,r0,#16
000600  0c12              LSRS     r2,r2,#16
000602  8022              STRH     r2,[r4,#0]
;;;503    
;;;504       if (FMMU->Startpos > 0)
000604  d038              BEQ      |L1.1656|
;;;505       {
;;;506          a = FMMU->Startpos;
;;;507          FMMU->nFMMU = ecx_siigetbyte(context, slave, a++);
000606  1c50              ADDS     r0,r2,#1
000608  b285              UXTH     r5,r0
00060a  4639              MOV      r1,r7
00060c  4648              MOV      r0,r9
00060e  f7fffffe          BL       ecx_siigetbyte
000612  70a0              STRB     r0,[r4,#2]
;;;508          FMMU->nFMMU += (ecx_siigetbyte(context, slave, a++) << 8);
000614  1c68              ADDS     r0,r5,#1
000616  fa1ff880          UXTH     r8,r0
00061a  462a              MOV      r2,r5
00061c  4639              MOV      r1,r7
00061e  4648              MOV      r0,r9
000620  f7fffffe          BL       ecx_siigetbyte
000624  78a1              LDRB     r1,[r4,#2]
;;;509          FMMU->nFMMU *= 2;
;;;510          FMMU->FMMU0 = ecx_siigetbyte(context, slave, a++);
000626  4642              MOV      r2,r8
000628  eb012000          ADD      r0,r1,r0,LSL #8       ;508
00062c  0040              LSLS     r0,r0,#1              ;509
00062e  70a0              STRB     r0,[r4,#2]            ;509
000630  f1080001          ADD      r0,r8,#1
000634  b285              UXTH     r5,r0
000636  4639              MOV      r1,r7
000638  4648              MOV      r0,r9
00063a  f7fffffe          BL       ecx_siigetbyte
00063e  70e0              STRB     r0,[r4,#3]
;;;511          FMMU->FMMU1 = ecx_siigetbyte(context, slave, a++);
000640  1c68              ADDS     r0,r5,#1
000642  fa1ff880          UXTH     r8,r0
000646  462a              MOV      r2,r5
000648  4639              MOV      r1,r7
00064a  4648              MOV      r0,r9
00064c  f7fffffe          BL       ecx_siigetbyte
000650  7120              STRB     r0,[r4,#4]
;;;512          if (FMMU->nFMMU > 2)
000652  78a0              LDRB     r0,[r4,#2]
000654  2802              CMP      r0,#2
000656  d90f              BLS      |L1.1656|
;;;513          {
;;;514             FMMU->FMMU2 = ecx_siigetbyte(context, slave, a++);
000658  4642              MOV      r2,r8
00065a  f1080801          ADD      r8,r8,#1
00065e  fa1ff588          UXTH     r5,r8
000662  4639              MOV      r1,r7
000664  4648              MOV      r0,r9
000666  f7fffffe          BL       ecx_siigetbyte
00066a  7160              STRB     r0,[r4,#5]
;;;515             FMMU->FMMU3 = ecx_siigetbyte(context, slave, a++);
00066c  462a              MOV      r2,r5
00066e  4639              MOV      r1,r7
000670  4648              MOV      r0,r9
000672  f7fffffe          BL       ecx_siigetbyte
000676  71a0              STRB     r0,[r4,#6]
                  |L1.1656|
;;;516          }
;;;517       }
;;;518       if (eectl)
000678  b11e              CBZ      r6,|L1.1666|
;;;519       {
;;;520          ecx_eeprom2pdi(context, slave); /* if eeprom control was previously pdi then restore */
00067a  4639              MOV      r1,r7
00067c  4648              MOV      r0,r9
00067e  f7fffffe          BL       ecx_eeprom2pdi
                  |L1.1666|
;;;521       }
;;;522    
;;;523       return FMMU->nFMMU;
000682  78a0              LDRB     r0,[r4,#2]
;;;524    }
000684  e682              B        |L1.908|
;;;525    
                          ENDP

                  ecx_siiSM PROC
;;;531     */
;;;532    uint16 ecx_siiSM(ecx_contextt *context, uint16 slave, ec_eepromSMt* SM)
000686  e92d47f0          PUSH     {r4-r10,lr}
;;;533    {
00068a  4689              MOV      r9,r1
00068c  4614              MOV      r4,r2
00068e  4682              MOV      r10,r0
;;;534       uint16 a,w;
;;;535       uint8 eectl = context->slavelist[slave].eep_pdi;
000690  eb0902c9          ADD      r2,r9,r9,LSL #3
000694  6841              LDR      r1,[r0,#4]
000696  eb021089          ADD      r0,r2,r9,LSL #6
00069a  22fb              MOVS     r2,#0xfb
00069c  eb020080          ADD      r0,r2,r0,LSL #2
;;;536    
;;;537       SM->nSM = 0;
;;;538       SM->Startpos = ecx_siifind(context, slave, ECT_SII_SM);
0006a0  2229              MOVS     r2,#0x29
0006a2  5c0e              LDRB     r6,[r1,r0]            ;535
0006a4  2000              MOVS     r0,#0                 ;537
0006a6  70a0              STRB     r0,[r4,#2]            ;537
0006a8  4649              MOV      r1,r9
0006aa  4650              MOV      r0,r10
0006ac  f7fffffe          BL       ecx_siifind
0006b0  0402              LSLS     r2,r0,#16
0006b2  0c12              LSRS     r2,r2,#16
0006b4  8022              STRH     r2,[r4,#0]
;;;539       if (SM->Startpos > 0)
0006b6  d057              BEQ      |L1.1896|
;;;540       {
;;;541          a = SM->Startpos;
;;;542          w = ecx_siigetbyte(context, slave, a++);
0006b8  1c50              ADDS     r0,r2,#1
0006ba  b285              UXTH     r5,r0
0006bc  4649              MOV      r1,r9
0006be  4650              MOV      r0,r10
0006c0  f7fffffe          BL       ecx_siigetbyte
0006c4  4607              MOV      r7,r0
;;;543          w += (ecx_siigetbyte(context, slave, a++) << 8);
0006c6  1c68              ADDS     r0,r5,#1
0006c8  fa1ff880          UXTH     r8,r0
0006cc  462a              MOV      r2,r5
0006ce  4649              MOV      r1,r9
0006d0  4650              MOV      r0,r10
0006d2  f7fffffe          BL       ecx_siigetbyte
0006d6  eb072000          ADD      r0,r7,r0,LSL #8
;;;544          SM->nSM = (w / 4);
0006da  0880              LSRS     r0,r0,#2
0006dc  70a0              STRB     r0,[r4,#2]
;;;545          SM->PhStart = ecx_siigetbyte(context, slave, a++);
0006de  f1080001          ADD      r0,r8,#1
0006e2  b285              UXTH     r5,r0
0006e4  4642              MOV      r2,r8
0006e6  4649              MOV      r1,r9
0006e8  4650              MOV      r0,r10
0006ea  f7fffffe          BL       ecx_siigetbyte
0006ee  80a0              STRH     r0,[r4,#4]
;;;546          SM->PhStart += (ecx_siigetbyte(context, slave, a++) << 8);
0006f0  1c68              ADDS     r0,r5,#1
0006f2  b287              UXTH     r7,r0
0006f4  462a              MOV      r2,r5
0006f6  4649              MOV      r1,r9
0006f8  4650              MOV      r0,r10
0006fa  f7fffffe          BL       ecx_siigetbyte
0006fe  88a1              LDRH     r1,[r4,#4]
;;;547          SM->Plength = ecx_siigetbyte(context, slave, a++);
000700  463a              MOV      r2,r7
000702  eb012000          ADD      r0,r1,r0,LSL #8       ;546
000706  80a0              STRH     r0,[r4,#4]            ;546
000708  1c78              ADDS     r0,r7,#1
00070a  b285              UXTH     r5,r0
00070c  4649              MOV      r1,r9
00070e  4650              MOV      r0,r10
000710  f7fffffe          BL       ecx_siigetbyte
000714  80e0              STRH     r0,[r4,#6]
;;;548          SM->Plength += (ecx_siigetbyte(context, slave, a++) << 8);
000716  1c68              ADDS     r0,r5,#1
000718  b287              UXTH     r7,r0
00071a  462a              MOV      r2,r5
00071c  4649              MOV      r1,r9
00071e  4650              MOV      r0,r10
000720  f7fffffe          BL       ecx_siigetbyte
000724  88e1              LDRH     r1,[r4,#6]
;;;549          SM->Creg = ecx_siigetbyte(context, slave, a++);
000726  463a              MOV      r2,r7
000728  eb012000          ADD      r0,r1,r0,LSL #8       ;548
00072c  80e0              STRH     r0,[r4,#6]            ;548
00072e  1c78              ADDS     r0,r7,#1
000730  b285              UXTH     r5,r0
000732  4649              MOV      r1,r9
000734  4650              MOV      r0,r10
000736  f7fffffe          BL       ecx_siigetbyte
00073a  7220              STRB     r0,[r4,#8]
;;;550          SM->Sreg = ecx_siigetbyte(context, slave, a++);
00073c  1c68              ADDS     r0,r5,#1
00073e  b287              UXTH     r7,r0
000740  462a              MOV      r2,r5
000742  4649              MOV      r1,r9
000744  4650              MOV      r0,r10
000746  f7fffffe          BL       ecx_siigetbyte
00074a  7260              STRB     r0,[r4,#9]
;;;551          SM->Activate = ecx_siigetbyte(context, slave, a++);
00074c  1c78              ADDS     r0,r7,#1
00074e  b285              UXTH     r5,r0
000750  463a              MOV      r2,r7
000752  4649              MOV      r1,r9
000754  4650              MOV      r0,r10
000756  f7fffffe          BL       ecx_siigetbyte
00075a  72a0              STRB     r0,[r4,#0xa]
;;;552          SM->PDIctrl = ecx_siigetbyte(context, slave, a++);
00075c  462a              MOV      r2,r5
00075e  4649              MOV      r1,r9
000760  4650              MOV      r0,r10
000762  f7fffffe          BL       ecx_siigetbyte
000766  72e0              STRB     r0,[r4,#0xb]
                  |L1.1896|
;;;553       }
;;;554       if (eectl)
000768  b11e              CBZ      r6,|L1.1906|
;;;555       {
;;;556          ecx_eeprom2pdi(context, slave); /* if eeprom control was previously pdi then restore */
00076a  4649              MOV      r1,r9
00076c  4650              MOV      r0,r10
00076e  f7fffffe          BL       ecx_eeprom2pdi
                  |L1.1906|
;;;557       }
;;;558    
;;;559       return SM->nSM;
000772  78a0              LDRB     r0,[r4,#2]
;;;560    }
000774  e60a              B        |L1.908|
;;;561    
                          ENDP

                  ecx_siiSMnext PROC
;;;568     */
;;;569    uint16 ecx_siiSMnext(ecx_contextt *context, uint16 slave, ec_eepromSMt* SM, uint16 n)
000776  e92d47f0          PUSH     {r4-r10,lr}
;;;570    {
00077a  460f              MOV      r7,r1
00077c  4614              MOV      r4,r2
00077e  4681              MOV      r9,r0
;;;571       uint16 a;
;;;572       uint16 retVal = 0;
;;;573       uint8 eectl = context->slavelist[slave].eep_pdi;
000780  eb0101c7          ADD      r1,r1,r7,LSL #3
000784  6840              LDR      r0,[r0,#4]
000786  eb011187          ADD      r1,r1,r7,LSL #6
00078a  22fb              MOVS     r2,#0xfb
00078c  eb020181          ADD      r1,r2,r1,LSL #2
000790  2500              MOVS     r5,#0                 ;572
000792  5c46              LDRB     r6,[r0,r1]
;;;574    
;;;575       if (n < SM->nSM)
000794  78a0              LDRB     r0,[r4,#2]
000796  4298              CMP      r0,r3
000798  d94e              BLS      |L1.2104|
;;;576       {
;;;577          a = SM->Startpos + 2 + (n * 8);
00079a  8820              LDRH     r0,[r4,#0]
00079c  2102              MOVS     r1,#2
00079e  eb0101c3          ADD      r1,r1,r3,LSL #3
0007a2  4408              ADD      r0,r0,r1
0007a4  b282              UXTH     r2,r0
;;;578          SM->PhStart = ecx_siigetbyte(context, slave, a++);
0007a6  1c50              ADDS     r0,r2,#1
0007a8  fa1ff880          UXTH     r8,r0
0007ac  4639              MOV      r1,r7
0007ae  4648              MOV      r0,r9
0007b0  f7fffffe          BL       ecx_siigetbyte
0007b4  80a0              STRH     r0,[r4,#4]
;;;579          SM->PhStart += (ecx_siigetbyte(context, slave, a++) << 8);
0007b6  f1080001          ADD      r0,r8,#1
0007ba  b285              UXTH     r5,r0
0007bc  4642              MOV      r2,r8
0007be  4639              MOV      r1,r7
0007c0  4648              MOV      r0,r9
0007c2  f7fffffe          BL       ecx_siigetbyte
0007c6  88a1              LDRH     r1,[r4,#4]
;;;580          SM->Plength = ecx_siigetbyte(context, slave, a++);
0007c8  462a              MOV      r2,r5
0007ca  eb012000          ADD      r0,r1,r0,LSL #8       ;579
0007ce  80a0              STRH     r0,[r4,#4]            ;579
0007d0  1c68              ADDS     r0,r5,#1
0007d2  fa1ff880          UXTH     r8,r0
0007d6  4639              MOV      r1,r7
0007d8  4648              MOV      r0,r9
0007da  f7fffffe          BL       ecx_siigetbyte
0007de  80e0              STRH     r0,[r4,#6]
;;;581          SM->Plength += (ecx_siigetbyte(context, slave, a++) << 8);
0007e0  4642              MOV      r2,r8
0007e2  1c50              ADDS     r0,r2,#1
0007e4  b285              UXTH     r5,r0
0007e6  4639              MOV      r1,r7
0007e8  4648              MOV      r0,r9
0007ea  f7fffffe          BL       ecx_siigetbyte
0007ee  88e1              LDRH     r1,[r4,#6]
;;;582          SM->Creg = ecx_siigetbyte(context, slave, a++);
0007f0  462a              MOV      r2,r5
0007f2  eb012000          ADD      r0,r1,r0,LSL #8       ;581
0007f6  80e0              STRH     r0,[r4,#6]            ;581
0007f8  1c68              ADDS     r0,r5,#1
0007fa  fa1ff880          UXTH     r8,r0
0007fe  4639              MOV      r1,r7
000800  4648              MOV      r0,r9
000802  f7fffffe          BL       ecx_siigetbyte
000806  7220              STRB     r0,[r4,#8]
;;;583          SM->Sreg = ecx_siigetbyte(context, slave, a++);
000808  4642              MOV      r2,r8
00080a  1c50              ADDS     r0,r2,#1
00080c  b285              UXTH     r5,r0
00080e  4639              MOV      r1,r7
000810  4648              MOV      r0,r9
000812  f7fffffe          BL       ecx_siigetbyte
000816  7260              STRB     r0,[r4,#9]
;;;584          SM->Activate = ecx_siigetbyte(context, slave, a++);
000818  1c68              ADDS     r0,r5,#1
00081a  fa1ff880          UXTH     r8,r0
00081e  462a              MOV      r2,r5
000820  4639              MOV      r1,r7
000822  4648              MOV      r0,r9
000824  f7fffffe          BL       ecx_siigetbyte
000828  72a0              STRB     r0,[r4,#0xa]
;;;585          SM->PDIctrl = ecx_siigetbyte(context, slave, a++);
00082a  4642              MOV      r2,r8
00082c  4639              MOV      r1,r7
00082e  4648              MOV      r0,r9
000830  f7fffffe          BL       ecx_siigetbyte
000834  72e0              STRB     r0,[r4,#0xb]
;;;586          retVal = 1;
000836  2501              MOVS     r5,#1
                  |L1.2104|
;;;587       }
;;;588       if (eectl)
000838  b11e              CBZ      r6,|L1.2114|
;;;589       {
;;;590          ecx_eeprom2pdi(context, slave); /* if eeprom control was previously pdi then restore */
00083a  4639              MOV      r1,r7
00083c  4648              MOV      r0,r9
00083e  f7fffffe          BL       ecx_eeprom2pdi
                  |L1.2114|
;;;591       }
;;;592    
;;;593       return retVal;
000842  4628              MOV      r0,r5
;;;594    }
000844  e5a2              B        |L1.908|
;;;595    
                          ENDP

                  ecx_siiPDO PROC
;;;602     */
;;;603    int ecx_siiPDO(ecx_contextt *context, uint16 slave, ec_eepromPDOt* PDO, uint8 t)
000846  e92d5fff          PUSH     {r0-r12,lr}
;;;604    {
00084a  4614              MOV      r4,r2
;;;605       uint16 a , w, c, e, er, Size;
;;;606       uint8 eectl = context->slavelist[slave].eep_pdi;
00084c  9800              LDR      r0,[sp,#0]
;;;607    
;;;608       Size = 0;
00084e  f04f0900          MOV      r9,#0
;;;609       PDO->nPDO = 0;
000852  464f              MOV      r7,r9
000854  6841              LDR      r1,[r0,#4]            ;606
000856  9801              LDR      r0,[sp,#4]            ;606
000858  eb0002c0          ADD      r2,r0,r0,LSL #3       ;606
00085c  eb021080          ADD      r0,r2,r0,LSL #6       ;606
000860  22fb              MOVS     r2,#0xfb              ;606
000862  eb020080          ADD      r0,r2,r0,LSL #2       ;606
000866  f811a000          LDRB     r10,[r1,r0]           ;606
00086a  f8a49004          STRH     r9,[r4,#4]
;;;610       PDO->Length = 0;
00086e  f8a49002          STRH     r9,[r4,#2]
;;;611       PDO->Index[1] = 0;
000872  f8a49008          STRH     r9,[r4,#8]
;;;612       for (c = 0 ; c < EC_MAXSM ; c++) PDO->SMbitsize[c] = 0;
000876  4648              MOV      r0,r9
                  |L1.2168|
000878  eb040140          ADD      r1,r4,r0,LSL #1
00087c  1c40              ADDS     r0,r0,#1
00087e  b280              UXTH     r0,r0
000880  f8a17c06          STRH     r7,[r1,#0xc06]
000884  2808              CMP      r0,#8
000886  d3f7              BCC      |L1.2168|
;;;613       if (t > 1)
000888  2b01              CMP      r3,#1
00088a  d900              BLS      |L1.2190|
;;;614          t = 1;
00088c  2301              MOVS     r3,#1
                  |L1.2190|
;;;615       PDO->Startpos = ecx_siifind(context, slave, ECT_SII_PDO + t);
00088e  e9dd0100          LDRD     r0,r1,[sp,#0]
000892  f1030232          ADD      r2,r3,#0x32
000896  f7fffffe          BL       ecx_siifind
00089a  0402              LSLS     r2,r0,#16
00089c  0c12              LSRS     r2,r2,#16
00089e  8022              STRH     r2,[r4,#0]
;;;616       if (PDO->Startpos > 0)
0008a0  d07e              BEQ      |L1.2464|
;;;617       {
;;;618          a = PDO->Startpos;
;;;619          w = ecx_siigetbyte(context, slave, a++);
0008a2  1c50              ADDS     r0,r2,#1
0008a4  b286              UXTH     r6,r0
0008a6  e9dd0100          LDRD     r0,r1,[sp,#0]
0008aa  f7fffffe          BL       ecx_siigetbyte
0008ae  4680              MOV      r8,r0
;;;620          w += (ecx_siigetbyte(context, slave, a++) << 8);
0008b0  1c70              ADDS     r0,r6,#1
0008b2  b285              UXTH     r5,r0
0008b4  e9dd0100          LDRD     r0,r1,[sp,#0]
0008b8  4632              MOV      r2,r6
0008ba  f7fffffe          BL       ecx_siigetbyte
0008be  eb082000          ADD      r0,r8,r0,LSL #8
;;;621          PDO->Length = w;
0008c2  8060              STRH     r0,[r4,#2]
;;;622          c = 1;
0008c4  2601              MOVS     r6,#1
0008c6  46bb              MOV      r11,r7
                  |L1.2248|
;;;623          /* traverse through all PDOs */
;;;624          do
;;;625          {
;;;626             PDO->nPDO++;
0008c8  88a0              LDRH     r0,[r4,#4]
;;;627             PDO->Index[PDO->nPDO] = ecx_siigetbyte(context, slave, a++);
0008ca  462a              MOV      r2,r5
0008cc  1c40              ADDS     r0,r0,#1              ;626
0008ce  80a0              STRH     r0,[r4,#4]            ;626
0008d0  e9dd0100          LDRD     r0,r1,[sp,#0]
0008d4  1c6d              ADDS     r5,r5,#1
0008d6  b2af              UXTH     r7,r5
0008d8  f7fffffe          BL       ecx_siigetbyte
0008dc  88a1              LDRH     r1,[r4,#4]
;;;628             PDO->Index[PDO->nPDO] += (ecx_siigetbyte(context, slave, a++) << 8);
0008de  463a              MOV      r2,r7
0008e0  eb040141          ADD      r1,r4,r1,LSL #1       ;627
0008e4  80c8              STRH     r0,[r1,#6]            ;627
0008e6  1c78              ADDS     r0,r7,#1
0008e8  b285              UXTH     r5,r0
0008ea  e9dd0100          LDRD     r0,r1,[sp,#0]
0008ee  f7fffffe          BL       ecx_siigetbyte
0008f2  88a1              LDRH     r1,[r4,#4]
;;;629             PDO->BitSize[PDO->nPDO] = 0;
;;;630             c++;
;;;631             e = ecx_siigetbyte(context, slave, a++);
0008f4  1c76              ADDS     r6,r6,#1
0008f6  eb040141          ADD      r1,r4,r1,LSL #1       ;628
0008fa  88ca              LDRH     r2,[r1,#6]            ;628
0008fc  eb022000          ADD      r0,r2,r0,LSL #8       ;628
000900  80c8              STRH     r0,[r1,#6]            ;628
000902  88a1              LDRH     r1,[r4,#4]            ;629
000904  1c68              ADDS     r0,r5,#1
000906  eb040141          ADD      r1,r4,r1,LSL #1       ;629
00090a  b287              UXTH     r7,r0
00090c  f8a1b806          STRH     r11,[r1,#0x806]       ;629
000910  e9dd0100          LDRD     r0,r1,[sp,#0]
000914  462a              MOV      r2,r5
000916  f7fffffe          BL       ecx_siigetbyte
00091a  4680              MOV      r8,r0
;;;632             PDO->SyncM[PDO->nPDO] = ecx_siigetbyte(context, slave, a++);
00091c  e9dd0100          LDRD     r0,r1,[sp,#0]
000920  463a              MOV      r2,r7
000922  1c7d              ADDS     r5,r7,#1
000924  f7fffffe          BL       ecx_siigetbyte
000928  88a1              LDRH     r1,[r4,#4]
00092a  1d2d              ADDS     r5,r5,#4
00092c  eb040141          ADD      r1,r4,r1,LSL #1
;;;633             a += 4;
000930  1cb6              ADDS     r6,r6,#2
000932  f8a10406          STRH     r0,[r1,#0x406]        ;632
000936  b2ad              UXTH     r5,r5
;;;634             c += 2;
000938  b2b6              UXTH     r6,r6
;;;635             if (PDO->SyncM[PDO->nPDO] < EC_MAXSM) /* active and in range SM? */
00093a  2808              CMP      r0,#8
00093c  d234              BCS      |L1.2472|
;;;636             {
;;;637                /* read all entries defined in PDO */
;;;638                for (er = 1; er <= e; er++)
00093e  2701              MOVS     r7,#1
000940  e014              B        |L1.2412|
                  |L1.2370|
;;;639                {
;;;640                   c += 4;
000942  1d6d              ADDS     r5,r5,#5
;;;641                   a += 5;
;;;642                   PDO->BitSize[PDO->nPDO] += ecx_siigetbyte(context, slave, a++);
000944  e9dd0100          LDRD     r0,r1,[sp,#0]
000948  1d36              ADDS     r6,r6,#4              ;638
00094a  b2aa              UXTH     r2,r5                 ;641
00094c  b2b6              UXTH     r6,r6                 ;640
00094e  1c55              ADDS     r5,r2,#1
000950  f7fffffe          BL       ecx_siigetbyte
000954  88a1              LDRH     r1,[r4,#4]
000956  1cad              ADDS     r5,r5,#2
000958  eb040141          ADD      r1,r4,r1,LSL #1
;;;643                   a += 2;
00095c  1c7f              ADDS     r7,r7,#1
00095e  f8b12806          LDRH     r2,[r1,#0x806]        ;642
000962  b2ad              UXTH     r5,r5
000964  4410              ADD      r0,r0,r2              ;642
000966  f8a10806          STRH     r0,[r1,#0x806]        ;642
00096a  b2bf              UXTH     r7,r7                 ;638
                  |L1.2412|
00096c  4547              CMP      r7,r8                 ;638
00096e  d9e8              BLS      |L1.2370|
;;;644                }
;;;645                PDO->SMbitsize[ PDO->SyncM[PDO->nPDO] ] += PDO->BitSize[PDO->nPDO];
000970  88a0              LDRH     r0,[r4,#4]
000972  eb040040          ADD      r0,r4,r0,LSL #1
000976  f8b01406          LDRH     r1,[r0,#0x406]
00097a  f8b00806          LDRH     r0,[r0,#0x806]
00097e  eb040141          ADD      r1,r4,r1,LSL #1
000982  f8b12c06          LDRH     r2,[r1,#0xc06]
000986  4410              ADD      r0,r0,r2
000988  f8a10c06          STRH     r0,[r1,#0xc06]
;;;646                Size += PDO->BitSize[PDO->nPDO];
00098c  88a0              LDRH     r0,[r4,#4]
00098e  eb040040          ADD      r0,r4,r0,LSL #1
000992  f8b01806          LDRH     r1,[r0,#0x806]
000996  eb010009          ADD      r0,r1,r9
00099a  fa1ff980          UXTH     r9,r0
00099e  e000              B        |L1.2466|
                  |L1.2464|
0009a0  e011              B        |L1.2502|
                  |L1.2466|
0009a2  1c76              ADDS     r6,r6,#1
;;;647                c++;
0009a4  b2b6              UXTH     r6,r6
0009a6  e006              B        |L1.2486|
                  |L1.2472|
;;;648             }
;;;649             else /* PDO deactivated because SM is 0xff or > EC_MAXSM */
;;;650             {
;;;651                c += 4 * e;
0009a8  eb060088          ADD      r0,r6,r8,LSL #2
;;;652                a += 8 * e;
0009ac  eb0501c8          ADD      r1,r5,r8,LSL #3
0009b0  1c40              ADDS     r0,r0,#1
0009b2  b28d              UXTH     r5,r1
;;;653                c++;
0009b4  b286              UXTH     r6,r0
                  |L1.2486|
;;;654             }
;;;655             if (PDO->nPDO >= (EC_MAXEEPDO - 1))
0009b6  88a0              LDRH     r0,[r4,#4]
0009b8  f5b07fff          CMP      r0,#0x1fe
0009bc  d900              BLS      |L1.2496|
;;;656             {
;;;657                c = PDO->Length; /* limit number of PDO entries in buffer */
0009be  8866              LDRH     r6,[r4,#2]
                  |L1.2496|
;;;658             }
;;;659          }
;;;660          while (c < PDO->Length);
0009c0  8860              LDRH     r0,[r4,#2]
0009c2  42b0              CMP      r0,r6
0009c4  d880              BHI      |L1.2248|
                  |L1.2502|
;;;661       }
;;;662       if (eectl)
0009c6  f1ba0f00          CMP      r10,#0
0009ca  d003              BEQ      |L1.2516|
0009cc  e9dd0100          LDRD     r0,r1,[sp,#0]
;;;663       {
;;;664          ecx_eeprom2pdi(context, slave); /* if eeprom control was previously pdi then restore */
0009d0  f7fffffe          BL       ecx_eeprom2pdi
                  |L1.2516|
;;;665       }
;;;666    
;;;667       return (Size);
;;;668    }
0009d4  b004              ADD      sp,sp,#0x10
0009d6  4648              MOV      r0,r9                 ;667
0009d8  e8bd9ff0          POP      {r4-r12,pc}
;;;669    
                          ENDP

                  ecx_statecheck PROC
;;;678     */
;;;679    uint16 ecx_statecheck(ecx_contextt *context, uint16 slave, uint16 reqstate, int timeout)
0009dc  e92d4fff          PUSH     {r0-r11,lr}
;;;680    {
0009e0  4604              MOV      r4,r0
;;;681       uint16 configadr, state, rval;
;;;682       ec_alstatust slstat;
;;;683       uint32_t timer2;
;;;684       if ( slave > *(context->slavecount) )
0009e2  6880              LDR      r0,[r0,#8]
0009e4  460e              MOV      r6,r1                 ;680
0009e6  b087              SUB      sp,sp,#0x1c           ;680
0009e8  6800              LDR      r0,[r0,#0]
0009ea  4690              MOV      r8,r2                 ;680
0009ec  42b0              CMP      r0,r6
0009ee  da03              BGE      |L1.2552|
;;;685       {
;;;686          return 0;
0009f0  2000              MOVS     r0,#0
                  |L1.2546|
;;;687       }
;;;688       timer2=bsp_GetTickCount();
;;;689       configadr = context->slavelist[slave].configadr;
;;;690       do
;;;691       {
;;;692          if (slave < 1)
;;;693          {
;;;694             rval = 0;
;;;695             ecx_BRD(context->port, 0, ECT_REG_ALSTAT, sizeof(rval), &rval , EC_TIMEOUTRET);
;;;696             rval = etohs(rval);
;;;697          }
;;;698          else
;;;699          {
;;;700             slstat.alstatus = 0;
;;;701             slstat.alstatuscode = 0;
;;;702             ecx_FPRD(context->port, configadr, ECT_REG_ALSTAT, sizeof(slstat), &slstat, EC_TIMEOUTRET);
;;;703             rval = etohs(slstat.alstatus);
;;;704             context->slavelist[slave].ALstatuscode = etohs(slstat.alstatuscode);
;;;705          }
;;;706          state = rval & 0x000f; /* read slave status */
;;;707          if (state != reqstate)
;;;708          {
;;;709             Delay_us(1000);
;;;710          }
;;;711       }
;;;712       while ((state != reqstate) && ((bsp_GetTickCount()-timer2)<timeout));
;;;713       context->slavelist[slave].state = rval;
;;;714       return state;
;;;715    }
0009f2  b00b              ADD      sp,sp,#0x2c
                  |L1.2548|
0009f4  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.2552|
0009f8  f7fffffe          BL       bsp_GetTickCount
0009fc  4681              MOV      r9,r0                 ;688
0009fe  eb0601c6          ADD      r1,r6,r6,LSL #3       ;689
000a02  eb011786          ADD      r7,r1,r6,LSL #6       ;689
000a06  6860              LDR      r0,[r4,#4]            ;689
000a08  2104              MOVS     r1,#4                 ;689
000a0a  eb010187          ADD      r1,r1,r7,LSL #2       ;689
000a0e  5a40              LDRH     r0,[r0,r1]            ;689
000a10  f04f0a00          MOV      r10,#0                ;689
000a14  f44f6bfa          MOV      r11,#0x7d0            ;695
000a18  9005              STR      r0,[sp,#0x14]         ;695
                  |L1.2586|
000a1a  b396              CBZ      r6,|L1.2690|
000a1c  a902              ADD      r1,sp,#8              ;702
000a1e  e9cd1b00          STRD     r1,r11,[sp,#0]        ;702
000a22  f8ada008          STRH     r10,[sp,#8]           ;700
000a26  f8ada00c          STRH     r10,[sp,#0xc]         ;701
000a2a  2306              MOVS     r3,#6                 ;702
000a2c  f44f7298          MOV      r2,#0x130             ;702
000a30  6820              LDR      r0,[r4,#0]            ;702
000a32  9905              LDR      r1,[sp,#0x14]         ;702
000a34  f7fffffe          BL       ecx_FPRD
000a38  f8bd0008          LDRH     r0,[sp,#8]            ;703
000a3c  f8ad0010          STRH     r0,[sp,#0x10]         ;703
000a40  6861              LDR      r1,[r4,#4]            ;704
000a42  2202              MOVS     r2,#2                 ;704
000a44  f8bd000c          LDRH     r0,[sp,#0xc]          ;704
000a48  eb020287          ADD      r2,r2,r7,LSL #2       ;704
000a4c  5288              STRH     r0,[r1,r2]            ;704
                  |L1.2638|
000a4e  f8bd0010          LDRH     r0,[sp,#0x10]         ;706
000a52  f000050f          AND      r5,r0,#0xf            ;706
000a56  4545              CMP      r5,r8                 ;707
000a58  d003              BEQ      |L1.2658|
000a5a  f44f707a          MOV      r0,#0x3e8             ;709
000a5e  f7fffffe          BL       Delay_us
                  |L1.2658|
000a62  4545              CMP      r5,r8                 ;712
000a64  d006              BEQ      |L1.2676|
000a66  f7fffffe          BL       bsp_GetTickCount
000a6a  eba00109          SUB      r1,r0,r9              ;712
000a6e  980a              LDR      r0,[sp,#0x28]         ;712
000a70  4281              CMP      r1,r0                 ;712
000a72  d3d2              BCC      |L1.2586|
                  |L1.2676|
000a74  6861              LDR      r1,[r4,#4]            ;713
000a76  f8bd0010          LDRH     r0,[sp,#0x10]         ;713
000a7a  f8210027          STRH     r0,[r1,r7,LSL #2]     ;713
000a7e  4628              MOV      r0,r5                 ;714
000a80  e7b7              B        |L1.2546|
                  |L1.2690|
000a82  e7ff              B        |L1.2692|
                  |L1.2692|
000a84  a904              ADD      r1,sp,#0x10           ;695
000a86  e9cd1b00          STRD     r1,r11,[sp,#0]        ;695
000a8a  f8ada010          STRH     r10,[sp,#0x10]        ;694
000a8e  2302              MOVS     r3,#2                 ;695
000a90  f44f7298          MOV      r2,#0x130             ;695
000a94  2100              MOVS     r1,#0                 ;695
000a96  6820              LDR      r0,[r4,#0]            ;695
000a98  f7fffffe          BL       ecx_BRD
000a9c  e7d7              B        |L1.2638|
;;;716    
                          ENDP

                  ec_nextmbxcnt PROC
;;;721     */
;;;722    uint8 ec_nextmbxcnt(uint8 cnt)
000a9e  1c40              ADDS     r0,r0,#1
;;;723    {
;;;724       cnt++;
000aa0  b2c0              UXTB     r0,r0
;;;725       if (cnt > 7)
000aa2  2807              CMP      r0,#7
000aa4  d900              BLS      |L1.2728|
;;;726       {
;;;727          cnt = 1; /* wrap around to 1, not 0 */
000aa6  2001              MOVS     r0,#1
                  |L1.2728|
;;;728       }
;;;729    
;;;730       return cnt;
;;;731    }
000aa8  4770              BX       lr
;;;732    
                          ENDP

                  ec_clearmbx PROC
;;;735     */
;;;736    void ec_clearmbx(ec_mbxbuft *Mbx)
000aaa  f24051ce          MOV      r1,#0x5ce
;;;737    {
;;;738        memset(Mbx, 0x00, EC_MAXMBX);
000aae  f7ffbffe          B.W      __aeabi_memclr
;;;739    }
;;;740    
                          ENDP

                  ecx_mbxempty PROC
;;;746     */
;;;747    int ecx_mbxempty(ecx_contextt *context, uint16 slave, int timeout)
000ab2  e92d4ffe          PUSH     {r1-r11,lr}
;;;748    {
000ab6  4615              MOV      r5,r2
000ab8  460c              MOV      r4,r1
000aba  4607              MOV      r7,r0
;;;749       uint16 configadr;
;;;750       uint8 SMstat;
;;;751       int wkc;
;;;752       uint32_t timer2;
;;;753       timer2=bsp_GetTickCount();
000abc  f7fffffe          BL       bsp_GetTickCount
000ac0  4606              MOV      r6,r0
;;;754    
;;;755       configadr = context->slavelist[slave].configadr;
000ac2  eb0401c4          ADD      r1,r4,r4,LSL #3
000ac6  6878              LDR      r0,[r7,#4]
000ac8  eb011184          ADD      r1,r1,r4,LSL #6
000acc  2204              MOVS     r2,#4
000ace  eb020181          ADD      r1,r2,r1,LSL #2
000ad2  f830a001          LDRH     r10,[r0,r1]
000ad6  f04f0800          MOV      r8,#0
;;;756       do
;;;757       {
;;;758          SMstat = 0;
;;;759          wkc = ecx_FPRD(context->port, configadr, ECT_REG_SM0STAT, sizeof(SMstat), &SMstat, EC_TIMEOUTRET);
000ada  f44f69fa          MOV      r9,#0x7d0
000ade  f6400b05          MOV      r11,#0x805
                  |L1.2786|
000ae2  a902              ADD      r1,sp,#8
000ae4  e9cd1900          STRD     r1,r9,[sp,#0]
000ae8  f88d8008          STRB     r8,[sp,#8]            ;758
000aec  2301              MOVS     r3,#1
000aee  465a              MOV      r2,r11
000af0  4651              MOV      r1,r10
000af2  6838              LDR      r0,[r7,#0]
000af4  f7fffffe          BL       ecx_FPRD
000af8  4604              MOV      r4,r0
;;;760          SMstat = etohs(SMstat);
000afa  f89d0008          LDRB     r0,[sp,#8]
;;;761          if (((SMstat & 0x08) != 0) && (timeout > EC_LOCALDELAY))
000afe  0700              LSLS     r0,r0,#28
000b00  d504              BPL      |L1.2828|
000b02  2dc8              CMP      r5,#0xc8
000b04  dd02              BLE      |L1.2828|
;;;762          {
;;;763             Delay_us(EC_LOCALDELAY);
000b06  20c8              MOVS     r0,#0xc8
000b08  f7fffffe          BL       Delay_us
                  |L1.2828|
;;;764          }
;;;765       }
;;;766       while (((wkc <= 0) || ((SMstat & 0x08) != 0)) && ( (bsp_GetTickCount()-timer2)<timeout));
000b0c  2c00              CMP      r4,#0
000b0e  dd03              BLE      |L1.2840|
000b10  f89d0008          LDRB     r0,[sp,#8]
000b14  0700              LSLS     r0,r0,#28
000b16  d50a              BPL      |L1.2862|
                  |L1.2840|
000b18  f7fffffe          BL       bsp_GetTickCount
000b1c  1b80              SUBS     r0,r0,r6
000b1e  42a8              CMP      r0,r5
000b20  d3df              BCC      |L1.2786|
;;;767    
;;;768       if ((wkc > 0) && ((SMstat & 0x08) == 0))
000b22  2c00              CMP      r4,#0
000b24  dd05              BLE      |L1.2866|
000b26  f89d0008          LDRB     r0,[sp,#8]
000b2a  0700              LSLS     r0,r0,#28
000b2c  d401              BMI      |L1.2866|
                  |L1.2862|
;;;769       {
;;;770          return 1;
000b2e  2001              MOVS     r0,#1
;;;771       }
;;;772    
;;;773       return 0;
;;;774    }
000b30  e409              B        |L1.838|
                  |L1.2866|
000b32  2000              MOVS     r0,#0                 ;773
000b34  e407              B        |L1.838|
;;;775    
                          ENDP

                  ecx_mbxsend PROC
;;;782     */
;;;783    int ecx_mbxsend(ecx_contextt *context, uint16 slave,ec_mbxbuft *mbx, int timeout)
000b36  e92d47fc          PUSH     {r2-r10,lr}
;;;784    {
000b3a  4691              MOV      r9,r2
000b3c  4604              MOV      r4,r0
;;;785       uint16 mbxwo,mbxl,configadr;
;;;786       int wkc;
;;;787    
;;;788       wkc = 0;
;;;789       configadr = context->slavelist[slave].configadr;
000b3e  eb0102c1          ADD      r2,r1,r1,LSL #3
000b42  6840              LDR      r0,[r0,#4]
000b44  eb021581          ADD      r5,r2,r1,LSL #6
000b48  2204              MOVS     r2,#4
000b4a  eb020285          ADD      r2,r2,r5,LSL #2
000b4e  f8308002          LDRH     r8,[r0,r2]
;;;790       mbxl = context->slavelist[slave].mbx_l;
000b52  22c0              MOVS     r2,#0xc0
000b54  eb020285          ADD      r2,r2,r5,LSL #2
000b58  5a86              LDRH     r6,[r0,r2]
000b5a  2700              MOVS     r7,#0                 ;788
;;;791       if ((mbxl > 0) && (mbxl <= EC_MAXMBX))
000b5c  1e70              SUBS     r0,r6,#1
000b5e  f24052cd          MOV      r2,#0x5cd
000b62  4290              CMP      r0,r2
000b64  d813              BHI      |L1.2958|
;;;792       {
;;;793          if (ecx_mbxempty(context, slave, timeout))
000b66  461a              MOV      r2,r3
000b68  4620              MOV      r0,r4
000b6a  f7fffffe          BL       ecx_mbxempty
000b6e  b170              CBZ      r0,|L1.2958|
;;;794          {
;;;795             mbxwo = context->slavelist[slave].mbx_wo;
000b70  6860              LDR      r0,[r4,#4]
000b72  21c2              MOVS     r1,#0xc2
000b74  eb010185          ADD      r1,r1,r5,LSL #2
000b78  5a42              LDRH     r2,[r0,r1]
;;;796             /* write slave in mailbox */
;;;797             wkc = ecx_FPWR(context->port, configadr, mbxwo, mbxl, mbx, EC_TIMEOUTRET3);
000b7a  f2417170          MOV      r1,#0x1770
000b7e  e9cd9100          STRD     r9,r1,[sp,#0]
000b82  4633              MOV      r3,r6
000b84  4641              MOV      r1,r8
000b86  6820              LDR      r0,[r4,#0]
000b88  f7fffffe          BL       ecx_FPWR
000b8c  4607              MOV      r7,r0
                  |L1.2958|
;;;798    		 
;;;799          }
;;;800          else
;;;801          {
;;;802             wkc = 0;
;;;803          }
;;;804       }
;;;805    
;;;806       return wkc;
000b8e  4638              MOV      r0,r7
;;;807    }
000b90  e8bd87fc          POP      {r2-r10,pc}
;;;808    
                          ENDP

                  ecx_mbxreceive PROC
;;;816     */
;;;817    int ecx_mbxreceive(ecx_contextt *context, uint16 slave, ec_mbxbuft *mbx, int timeout)
000b94  e92d4ff0          PUSH     {r4-r11,lr}
;;;818    {
000b98  4689              MOV      r9,r1
000b9a  4616              MOV      r6,r2
000b9c  4604              MOV      r4,r0
;;;819       uint16 mbxro,mbxl,configadr;
;;;820       int wkc=0;
;;;821       int wkc2;
;;;822       uint16 SMstat;
;;;823       uint8 SMcontr;
;;;824       ec_mbxheadert *mbxh;
;;;825       ec_emcyt *EMp;
;;;826       ec_mbxerrort *MBXEp;
;;;827       uint32_t timer2[4];
;;;828       
;;;829    	
;;;830       configadr = context->slavelist[slave].configadr;
000b9e  eb0902c9          ADD      r2,r9,r9,LSL #3
000ba2  6841              LDR      r1,[r0,#4]
000ba4  b08b              SUB      sp,sp,#0x2c           ;818
000ba6  eb021089          ADD      r0,r2,r9,LSL #6
000baa  2204              MOVS     r2,#4
000bac  9002              STR      r0,[sp,#8]
000bae  eb020080          ADD      r0,r2,r0,LSL #2
000bb2  5a08              LDRH     r0,[r1,r0]
000bb4  9007              STR      r0,[sp,#0x1c]
;;;831       mbxl = context->slavelist[slave].mbx_rl;
000bb6  9802              LDR      r0,[sp,#8]
000bb8  22c4              MOVS     r2,#0xc4
000bba  eb020080          ADD      r0,r2,r0,LSL #2
000bbe  5a08              LDRH     r0,[r1,r0]
;;;832       if ((mbxl > 0) && (mbxl <= EC_MAXMBX))
000bc0  9005              STR      r0,[sp,#0x14]
000bc2  2700              MOVS     r7,#0                 ;820
000bc4  f24051cd          MOV      r1,#0x5cd
000bc8  1e40              SUBS     r0,r0,#1
000bca  461d              MOV      r5,r3                 ;818
000bcc  4288              CMP      r0,r1
000bce  d84c              BHI      |L1.3178|
;;;833       {
;;;834    	    timer2[0]=bsp_GetTickCount();
000bd0  f7fffffe          BL       bsp_GetTickCount
000bd4  4682              MOV      r10,r0
000bd6  46bb              MOV      r11,r7
;;;835          wkc = 0;
;;;836          do /* wait for read mailbox available */
;;;837          {
;;;838             SMstat = 0;
;;;839             wkc = ecx_FPRD(context->port, configadr, ECT_REG_SM1STAT, sizeof(SMstat), &SMstat, EC_TIMEOUTRET);
000bd8  f44f68fa          MOV      r8,#0x7d0
                  |L1.3036|
000bdc  a904              ADD      r1,sp,#0x10
000bde  e9cd1800          STRD     r1,r8,[sp,#0]
000be2  f8adb010          STRH     r11,[sp,#0x10]        ;838
000be6  2302              MOVS     r3,#2
000be8  f640020d          MOV      r2,#0x80d
000bec  6820              LDR      r0,[r4,#0]
000bee  9907              LDR      r1,[sp,#0x1c]
000bf0  f7fffffe          BL       ecx_FPRD
000bf4  4607              MOV      r7,r0
;;;840    				 SMstat = etohs(SMstat);
000bf6  f8bd0010          LDRH     r0,[sp,#0x10]
;;;841             if (((SMstat & 0x08) == 0) && (timeout > EC_LOCALDELAY))
000bfa  0700              LSLS     r0,r0,#28
000bfc  d404              BMI      |L1.3080|
000bfe  2dc8              CMP      r5,#0xc8
000c00  dd02              BLE      |L1.3080|
;;;842             {
;;;843                Delay_us(EC_LOCALDELAY);
000c02  20c8              MOVS     r0,#0xc8
000c04  f7fffffe          BL       Delay_us
                  |L1.3080|
;;;844             }
;;;845          }
;;;846          while (((wkc <= 0) || ((SMstat & 0x08) == 0)) && (bsp_GetTickCount()-timer2[0]<timeout));
000c08  2f00              CMP      r7,#0
000c0a  dd03              BLE      |L1.3092|
000c0c  f8bd0010          LDRH     r0,[sp,#0x10]
000c10  0700              LSLS     r0,r0,#28
000c12  d40b              BMI      |L1.3116|
                  |L1.3092|
000c14  f7fffffe          BL       bsp_GetTickCount
000c18  eba0000a          SUB      r0,r0,r10
000c1c  42a8              CMP      r0,r5
000c1e  d3dd              BCC      |L1.3036|
;;;847          if ((wkc > 0) && ((SMstat & 0x08) > 0)) /* read mailbox available ? */
000c20  2f00              CMP      r7,#0
000c22  dd7c              BLE      |L1.3358|
000c24  f8bd0010          LDRH     r0,[sp,#0x10]
000c28  0700              LSLS     r0,r0,#28
000c2a  d578              BPL      |L1.3358|
                  |L1.3116|
;;;848          {
;;;849             mbxro = context->slavelist[slave].mbx_ro;
000c2c  6861              LDR      r1,[r4,#4]
000c2e  9802              LDR      r0,[sp,#8]
000c30  22c6              MOVS     r2,#0xc6
000c32  eb020080          ADD      r0,r2,r0,LSL #2
000c36  5a08              LDRH     r0,[r1,r0]
;;;850             mbxh = (ec_mbxheadert *)mbx;
;;;851    		     timer2[3]=bsp_GetTickCount();
000c38  9609              STR      r6,[sp,#0x24]
000c3a  9006              STR      r0,[sp,#0x18]
000c3c  f7fffffe          BL       bsp_GetTickCount
000c40  900a              STR      r0,[sp,#0x28]
                  |L1.3138|
;;;852             do
;;;853             {
;;;854                wkc = ecx_FPRD(context->port, configadr, mbxro, mbxl, mbx, EC_TIMEOUTRET); /* get mailbox */
000c42  f44f68fa          MOV      r8,#0x7d0
000c46  e9cd6800          STRD     r6,r8,[sp,#0]
000c4a  e9dd2106          LDRD     r2,r1,[sp,#0x18]
000c4e  6820              LDR      r0,[r4,#0]
000c50  9b05              LDR      r3,[sp,#0x14]
000c52  f7fffffe          BL       ecx_FPRD
000c56  1e07              SUBS     r7,r0,#0
;;;855    					 if ((wkc > 0) && ((mbxh->mbxtype & 0x0f) == 0x00)) /* Mailbox error response? */
000c58  dd4c              BLE      |L1.3316|
000c5a  9809              LDR      r0,[sp,#0x24]
000c5c  7940              LDRB     r0,[r0,#5]
000c5e  0701              LSLS     r1,r0,#28
000c60  d004              BEQ      |L1.3180|
;;;856                {
;;;857                   MBXEp = (ec_mbxerrort *)mbx;
;;;858                   ecx_mbxerror(context, slave, etohs(MBXEp->Detail));
;;;859                   wkc = 0; /* prevent emergency to cascade up, it is already handled. */
;;;860                }
;;;861                else if ((wkc > 0) && ((mbxh->mbxtype & 0x0f) == 0x03)) /* CoE response? */
000c62  f000000f          AND      r0,r0,#0xf
000c66  2803              CMP      r0,#3
000c68  d016              BEQ      |L1.3224|
                  |L1.3178|
000c6a  e0a8              B        |L1.3518|
                  |L1.3180|
000c6c  8933              LDRH     r3,[r6,#8]            ;858
000c6e  f8cdb004          STR      r11,[sp,#4]           ;858
000c72  f8adb004          STRH     r11,[sp,#4]           ;858
000c76  f8cdb000          STR      r11,[sp,#0]           ;858
000c7a  f8cdb008          STR      r11,[sp,#8]           ;858
000c7e  f88db006          STRB     r11,[sp,#6]           ;858
000c82  2109              MOVS     r1,#9                 ;858
000c84  4620              MOV      r0,r4                 ;858
000c86  f8cdb00c          STR      r11,[sp,#0xc]         ;858
000c8a  f8ad9002          STRH     r9,[sp,#2]            ;858
000c8e  f88d1007          STRB     r1,[sp,#7]            ;858
000c92  f8ad3008          STRH     r3,[sp,#8]            ;858
000c96  e028              B        |L1.3306|
                  |L1.3224|
;;;862                {
;;;863                   EMp = (ec_emcyt *)mbx;
;;;864                   if ((etohs(EMp->CANOpen) >> 12) == 0x01) /* Emergency request? */
000c98  88f1              LDRH     r1,[r6,#6]
000c9a  f04f0e01          MOV      lr,#1
000c9e  ebbe3f11          CMP      lr,r1,LSR #12
000ca2  d17c              BNE      |L1.3486|
;;;865                   {
;;;866                      ecx_mbxemergencyerror(context, slave, etohs(EMp->ErrorCode), EMp->ErrorReg,
000ca4  f8b6a008          LDRH     r10,[r6,#8]
000ca8  7ab2              LDRB     r2,[r6,#0xa]
000caa  f896800b          LDRB     r8,[r6,#0xb]
000cae  89b7              LDRH     r7,[r6,#0xc]
000cb0  f8b6c00e          LDRH     r12,[r6,#0xe]
000cb4  f8cdb004          STR      r11,[sp,#4]
000cb8  f8cdb008          STR      r11,[sp,#8]
000cbc  f8cdb00c          STR      r11,[sp,#0xc]
000cc0  f8adb004          STRH     r11,[sp,#4]
000cc4  f8ada008          STRH     r10,[sp,#8]
000cc8  f8cdb000          STR      r11,[sp,#0]
000ccc  f88db006          STRB     r11,[sp,#6]
000cd0  f88d200a          STRB     r2,[sp,#0xa]
000cd4  f8ad700c          STRH     r7,[sp,#0xc]
000cd8  4620              MOV      r0,r4
000cda  f8ad9002          STRH     r9,[sp,#2]
000cde  f88de007          STRB     lr,[sp,#7]
000ce2  f88d800b          STRB     r8,[sp,#0xb]
000ce6  f8adc00e          STRH     r12,[sp,#0xe]
                  |L1.3306|
000cea  4669              MOV      r1,sp
000cec  f7fffffe          BL       ecx_pusherror
000cf0  2700              MOVS     r7,#0                 ;859
000cf2  e05b              B        |L1.3500|
                  |L1.3316|
;;;867                              EMp->bData, etohs(EMp->w1), etohs(EMp->w2));
;;;868                      wkc = 0; /* prevent emergency to cascade up, it is already handled. */
;;;869                   }
;;;870                }
;;;871                else
;;;872                {
;;;873                   if (wkc <= 0) /* read mailbox lost */
;;;874                   {
;;;875                      SMstat ^= 0x0200; /* toggle repeat request */
;;;876                      SMstat = htoes(SMstat);
;;;877                      wkc2 = ecx_FPWR(context->port, configadr, ECT_REG_SM1STAT, sizeof(SMstat), &SMstat, EC_TIMEOUTRET);
000cf4  a904              ADD      r1,sp,#0x10
000cf6  f8bd0010          LDRH     r0,[sp,#0x10]         ;875
000cfa  e9cd1800          STRD     r1,r8,[sp,#0]
000cfe  f4807000          EOR      r0,r0,#0x200          ;875
000d02  f8ad0010          STRH     r0,[sp,#0x10]         ;876
000d06  2302              MOVS     r3,#2
000d08  f640020d          MOV      r2,#0x80d
000d0c  6820              LDR      r0,[r4,#0]
000d0e  9907              LDR      r1,[sp,#0x1c]
000d10  f7fffffe          BL       ecx_FPWR
;;;878    								 SMstat = etohs(SMstat);
;;;879    				        timer2[1]=bsp_GetTickCount();
000d14  f7fffffe          BL       bsp_GetTickCount
000d18  4682              MOV      r10,r0
                  |L1.3354|
;;;880                      do /* wait for toggle ack */
;;;881                      {
;;;882                         wkc2 = ecx_FPRD(context->port, configadr, ECT_REG_SM1CONTR, sizeof(SMcontr), &SMcontr, EC_TIMEOUTRET);
000d1a  a908              ADD      r1,sp,#0x20
000d1c  e000              B        |L1.3360|
                  |L1.3358|
000d1e  e04d              B        |L1.3516|
                  |L1.3360|
000d20  e9cd1800          STRD     r1,r8,[sp,#0]
000d24  2301              MOVS     r3,#1
000d26  f640020f          MOV      r2,#0x80f
000d2a  6820              LDR      r0,[r4,#0]
000d2c  9907              LDR      r1,[sp,#0x1c]
000d2e  f7fffffe          BL       ecx_FPRD
;;;883    									} while (((wkc2 <= 0) || ((SMcontr & 0x02) != (HI_BYTE(SMstat) & 0x02))) && (bsp_GetTickCount()-timer2[1]<timeout));
000d32  2800              CMP      r0,#0
000d34  dd0a              BLE      |L1.3404|
000d36  f89d0020          LDRB     r0,[sp,#0x20]
000d3a  f8bd2010          LDRH     r2,[sp,#0x10]
000d3e  f0000102          AND      r1,r0,#2
000d42  2002              MOVS     r0,#2
000d44  ea002012          AND      r0,r0,r2,LSR #8
000d48  4281              CMP      r1,r0
000d4a  d005              BEQ      |L1.3416|
                  |L1.3404|
000d4c  f7fffffe          BL       bsp_GetTickCount
000d50  eba0000a          SUB      r0,r0,r10
000d54  42a8              CMP      r0,r5
000d56  d3e0              BCC      |L1.3354|
                  |L1.3416|
;;;884                 timer2[2]=bsp_GetTickCount();
000d58  f7fffffe          BL       bsp_GetTickCount
000d5c  4682              MOV      r10,r0
                  |L1.3422|
;;;885    				   do /* wait for read mailbox available */
;;;886                      {
;;;887                         wkc2 = ecx_FPRD(context->port, configadr, ECT_REG_SM1STAT, sizeof(SMstat), &SMstat, EC_TIMEOUTRET);
000d5e  f44f61fa          MOV      r1,#0x7d0
000d62  a804              ADD      r0,sp,#0x10
000d64  e9cd0100          STRD     r0,r1,[sp,#0]
000d68  2302              MOVS     r3,#2
000d6a  f640020d          MOV      r2,#0x80d
000d6e  6820              LDR      r0,[r4,#0]
000d70  9907              LDR      r1,[sp,#0x1c]
000d72  f7fffffe          BL       ecx_FPRD
000d76  4680              MOV      r8,r0
;;;888    										SMstat = etohs(SMstat);
000d78  f8bd0010          LDRH     r0,[sp,#0x10]
;;;889                         if (((SMstat & 0x08) == 0) && (timeout > EC_LOCALDELAY))
000d7c  0700              LSLS     r0,r0,#28
000d7e  d404              BMI      |L1.3466|
000d80  2dc8              CMP      r5,#0xc8
000d82  dd02              BLE      |L1.3466|
;;;890                         {
;;;891                            Delay_us(EC_LOCALDELAY);
000d84  20c8              MOVS     r0,#0xc8
000d86  f7fffffe          BL       Delay_us
                  |L1.3466|
;;;892                         }
;;;893                      } while (((wkc2 <= 0) || ((SMstat & 0x08) == 0)) && (bsp_GetTickCount()-timer2[2]<timeout));
000d8a  f1b80f00          CMP      r8,#0
000d8e  dd03              BLE      |L1.3480|
000d90  f8bd0010          LDRH     r0,[sp,#0x10]
000d94  0700              LSLS     r0,r0,#28
000d96  d407              BMI      |L1.3496|
                  |L1.3480|
000d98  f7fffffe          BL       bsp_GetTickCount
000d9c  e000              B        |L1.3488|
                  |L1.3486|
000d9e  e00c              B        |L1.3514|
                  |L1.3488|
000da0  eba0000a          SUB      r0,r0,r10
000da4  42a8              CMP      r0,r5
000da6  d3da              BCC      |L1.3422|
                  |L1.3496|
;;;894                   }
;;;895                }
;;;896             } while ((wkc <= 0) && (bsp_GetTickCount()-timer2[3]<timeout)); /* if WKC<=0 repeat */
000da8  2f00              CMP      r7,#0
000daa  dc08              BGT      |L1.3518|
                  |L1.3500|
000dac  f7fffffe          BL       bsp_GetTickCount
000db0  990a              LDR      r1,[sp,#0x28]
000db2  1a40              SUBS     r0,r0,r1
000db4  42a8              CMP      r0,r5
000db6  f4ffaf44          BCC      |L1.3138|
                  |L1.3514|
000dba  e000              B        |L1.3518|
                  |L1.3516|
;;;897          }
;;;898          else /* no read mailbox available */
;;;899          {
;;;900              wkc = 0;
000dbc  2700              MOVS     r7,#0
                  |L1.3518|
;;;901          }
;;;902       }
;;;903    
;;;904       return wkc;
000dbe  4638              MOV      r0,r7
;;;905    }
000dc0  e617              B        |L1.2546|
;;;906    
                          ENDP

                  ecx_readeeprom PROC
;;;913     */
;;;914    uint32 ecx_readeeprom(ecx_contextt *context, uint16 slave, uint16 eeproma, int timeout)
000dc2  e92d41f0          PUSH     {r4-r8,lr}
;;;915    {
000dc6  461e              MOV      r6,r3
000dc8  4617              MOV      r7,r2
000dca  460c              MOV      r4,r1
000dcc  4605              MOV      r5,r0
;;;916       uint16 configadr;
;;;917    
;;;918       ecx_eeprom2master(context, slave); /* set eeprom control to master */
000dce  f7fffffe          BL       ecx_eeprom2master
;;;919       configadr = context->slavelist[slave].configadr;
000dd2  eb0401c4          ADD      r1,r4,r4,LSL #3
000dd6  eb011184          ADD      r1,r1,r4,LSL #6
000dda  2204              MOVS     r2,#4
000ddc  6868              LDR      r0,[r5,#4]
000dde  eb020181          ADD      r1,r2,r1,LSL #2
;;;920    
;;;921       return ((uint32)ecx_readeepromFP(context, configadr, eeproma, timeout));
000de2  4633              MOV      r3,r6
000de4  5a41              LDRH     r1,[r0,r1]            ;919
000de6  463a              MOV      r2,r7
000de8  4628              MOV      r0,r5
000dea  f7fffffe          BL       ecx_readeepromFP
;;;922    }
000dee  e8bd81f0          POP      {r4-r8,pc}
;;;923    
                          ENDP

                  ecx_writeeepromFP PROC
;;;1501    */
;;;1502   int ecx_writeeepromFP(ecx_contextt *context, uint16 configadr, uint16 eeproma, uint16 data, int timeout)
000df2  e92d4fff          PUSH     {r0-r11,lr}
;;;1503   {
000df6  b085              SUB      sp,sp,#0x14
;;;1504      uint16 estat;
;;;1505      ec_eepromt ed;
;;;1506      int wkc, rval = 0, cnt = 0, nackcnt = 0;
000df8  f04f0a00          MOV      r10,#0
000dfc  4606              MOV      r6,r0                 ;1503
000dfe  4655              MOV      r5,r10
;;;1507   
;;;1508      if (ecx_eeprom_waitnotbusyFP(context, configadr, &estat, timeout))
000e00  aa02              ADD      r2,sp,#8
000e02  9b12              LDR      r3,[sp,#0x48]
000e04  9906              LDR      r1,[sp,#0x18]
000e06  f7fffffe          BL       ecx_eeprom_waitnotbusyFP
000e0a  2800              CMP      r0,#0
000e0c  d062              BEQ      |L1.3796|
;;;1509      {
;;;1510         if (estat & EC_ESTAT_EMASK) /* error bits are set */
000e0e  f8bd0008          LDRH     r0,[sp,#8]
000e12  46d3              MOV      r11,r10
000e14  f4104ff0          TST      r0,#0x7800
000e18  d00d              BEQ      |L1.3638|
;;;1511         {
;;;1512            estat = htoes(EC_ECMD_NOP); /* clear error bits */
;;;1513            wkc = ecx_FPWR(context->port, configadr, ECT_REG_EEPCTL, sizeof(estat), &estat, EC_TIMEOUTRET3);
000e1a  f2417170          MOV      r1,#0x1770
000e1e  a802              ADD      r0,sp,#8
000e20  e9cd0100          STRD     r0,r1,[sp,#0]
000e24  f8adb008          STRH     r11,[sp,#8]           ;1512
000e28  2302              MOVS     r3,#2
000e2a  f2405202          MOV      r2,#0x502
000e2e  6830              LDR      r0,[r6,#0]
000e30  9906              LDR      r1,[sp,#0x18]
000e32  f7fffffe          BL       ecx_FPWR
                  |L1.3638|
;;;1514         }
;;;1515         do
;;;1516         {
;;;1517            cnt = 0;
;;;1518            do
;;;1519            {
;;;1520               wkc = ecx_FPWR(context->port, configadr, ECT_REG_EEPDAT, sizeof(data), &data, EC_TIMEOUTRET);
000e36  f44f67fa          MOV      r7,#0x7d0
                  |L1.3642|
000e3a  2400              MOVS     r4,#0                 ;1517
000e3c  f10d0820          ADD      r8,sp,#0x20
000e40  f44f69a1          MOV      r9,#0x508
                  |L1.3652|
000e44  e9cd8700          STRD     r8,r7,[sp,#0]
000e48  2302              MOVS     r3,#2
000e4a  464a              MOV      r2,r9
000e4c  6830              LDR      r0,[r6,#0]
000e4e  9906              LDR      r1,[sp,#0x18]
000e50  f7fffffe          BL       ecx_FPWR
;;;1521            }
;;;1522            while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
000e54  2800              CMP      r0,#0
000e56  dc03              BGT      |L1.3680|
000e58  4620              MOV      r0,r4
000e5a  1c64              ADDS     r4,r4,#1
000e5c  2803              CMP      r0,#3
000e5e  dbf1              BLT      |L1.3652|
                  |L1.3680|
;;;1523            ed.comm = EC_ECMD_WRITE;
000e60  f2402001          MOV      r0,#0x201
000e64  f8ad000c          STRH     r0,[sp,#0xc]
;;;1524            ed.addr = eeproma;
000e68  9807              LDR      r0,[sp,#0x1c]
000e6a  f8ad000e          STRH     r0,[sp,#0xe]
;;;1525            ed.d2   = 0x0000;
000e6e  46d8              MOV      r8,r11
000e70  f8adb010          STRH     r11,[sp,#0x10]
;;;1526            cnt = 0;
000e74  2400              MOVS     r4,#0
000e76  f10d090c          ADD      r9,sp,#0xc            ;1505
                  |L1.3706|
000e7a  e9cd9700          STRD     r9,r7,[sp,#0]         ;1505
;;;1527            do
;;;1528            {
;;;1529               wkc = ecx_FPWR(context->port, configadr, ECT_REG_EEPCTL, sizeof(ed), &ed, EC_TIMEOUTRET);
000e7e  2306              MOVS     r3,#6
000e80  f2405202          MOV      r2,#0x502
000e84  6830              LDR      r0,[r6,#0]
000e86  9906              LDR      r1,[sp,#0x18]
000e88  f7fffffe          BL       ecx_FPWR
;;;1530            }
;;;1531            while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
000e8c  2800              CMP      r0,#0
000e8e  dc04              BGT      |L1.3738|
000e90  4621              MOV      r1,r4
000e92  1c64              ADDS     r4,r4,#1
000e94  2903              CMP      r1,#3
000e96  dbf0              BLT      |L1.3706|
;;;1532            if (wkc)
000e98  b1c8              CBZ      r0,|L1.3790|
                  |L1.3738|
;;;1533            {
;;;1534               Delay_us(EC_LOCALDELAY * 2);
000e9a  f44f70c8          MOV      r0,#0x190
000e9e  f7fffffe          BL       Delay_us
;;;1535               estat = 0x0000;
000ea2  f8ad8008          STRH     r8,[sp,#8]
;;;1536               if (ecx_eeprom_waitnotbusyFP(context, configadr, &estat, timeout))
000ea6  aa02              ADD      r2,sp,#8
000ea8  4630              MOV      r0,r6
000eaa  9b12              LDR      r3,[sp,#0x48]
000eac  9906              LDR      r1,[sp,#0x18]
000eae  f7fffffe          BL       ecx_eeprom_waitnotbusyFP
000eb2  b160              CBZ      r0,|L1.3790|
;;;1537               {
;;;1538                  if (estat & EC_ESTAT_NACK)
000eb4  f8bd0008          LDRH     r0,[sp,#8]
000eb8  0480              LSLS     r0,r0,#18
000eba  d505              BPL      |L1.3784|
;;;1539                  {
;;;1540                     nackcnt++;
;;;1541                     Delay_us(EC_LOCALDELAY * 5);
000ebc  f44f707a          MOV      r0,#0x3e8
000ec0  1c6d              ADDS     r5,r5,#1
000ec2  f7fffffe          BL       Delay_us
000ec6  e002              B        |L1.3790|
                  |L1.3784|
;;;1542                  }
;;;1543                  else
;;;1544                  {
;;;1545                     nackcnt = 0;
000ec8  2500              MOVS     r5,#0
;;;1546                     rval = 1;
000eca  f04f0a01          MOV      r10,#1
                  |L1.3790|
;;;1547                  }
;;;1548               }
;;;1549            }
;;;1550         }
;;;1551         while ((nackcnt > 0) && (nackcnt < 3));
000ece  1e68              SUBS     r0,r5,#1
000ed0  2802              CMP      r0,#2
000ed2  d3b2              BCC      |L1.3642|
                  |L1.3796|
;;;1552      }
;;;1553   
;;;1554      return rval;
000ed4  4650              MOV      r0,r10
                  |L1.3798|
;;;1555   }
000ed6  b009              ADD      sp,sp,#0x24
000ed8  e58c              B        |L1.2548|
;;;1556   
                          ENDP

                  ecx_writeeeprom PROC
;;;931     */
;;;932    int ecx_writeeeprom(ecx_contextt *context, uint16 slave, uint16 eeproma, uint16 data, int timeout)
000eda  e92d43f8          PUSH     {r3-r9,lr}
;;;933    {
000ede  461f              MOV      r7,r3
000ee0  4690              MOV      r8,r2
000ee2  460c              MOV      r4,r1
000ee4  4605              MOV      r5,r0
;;;934       uint16 configadr;
;;;935    
;;;936       ecx_eeprom2master(context, slave); /* set eeprom control to master */
000ee6  9e08              LDR      r6,[sp,#0x20]
000ee8  f7fffffe          BL       ecx_eeprom2master
;;;937       configadr = context->slavelist[slave].configadr;
000eec  eb0401c4          ADD      r1,r4,r4,LSL #3
000ef0  eb011184          ADD      r1,r1,r4,LSL #6
000ef4  2204              MOVS     r2,#4
000ef6  6868              LDR      r0,[r5,#4]
000ef8  eb020181          ADD      r1,r2,r1,LSL #2
;;;938       return (ecx_writeeepromFP(context, configadr, eeproma, data, timeout));
000efc  463b              MOV      r3,r7
000efe  5a41              LDRH     r1,[r0,r1]            ;937
000f00  4642              MOV      r2,r8
000f02  4628              MOV      r0,r5
000f04  9600              STR      r6,[sp,#0]
000f06  f7fffffe          BL       ecx_writeeepromFP
;;;939    }
000f0a  e8bd83f8          POP      {r3-r9,pc}
;;;940    
                          ENDP

                  ecx_eeprom_waitnotbusyAP PROC
;;;999    
;;;1000   uint16 ecx_eeprom_waitnotbusyAP(ecx_contextt *context, uint16 aiadr,uint16 *estat, int timeout)
000f0e  e92d4fff          PUSH     {r0-r11,lr}
;;;1001   {
;;;1002      int wkc, cnt = 0, retval = 0;
000f12  2500              MOVS     r5,#0
000f14  b083              SUB      sp,sp,#0xc            ;1001
000f16  4698              MOV      r8,r3                 ;1001
000f18  4614              MOV      r4,r2                 ;1001
000f1a  4681              MOV      r9,r0                 ;1001
000f1c  462e              MOV      r6,r5
;;;1003      uint32_t timer2;
;;;1004      timer2=bsp_GetTickCount();
000f1e  f7fffffe          BL       bsp_GetTickCount
000f22  4607              MOV      r7,r0
000f24  46aa              MOV      r10,r5
;;;1005      do
;;;1006      {
;;;1007         if (cnt++)
;;;1008         {
;;;1009            Delay_us(EC_LOCALDELAY);
;;;1010         }
;;;1011         *estat = 0;
;;;1012         wkc=ecx_APRD(context->port, aiadr, ECT_REG_EEPSTAT, sizeof(*estat), estat, EC_TIMEOUTRET);
000f26  f44f6bfa          MOV      r11,#0x7d0
                  |L1.3882|
000f2a  1c6d              ADDS     r5,r5,#1
000f2c  2d01              CMP      r5,#1                 ;1007
000f2e  d002              BEQ      |L1.3894|
000f30  20c8              MOVS     r0,#0xc8              ;1009
000f32  f7fffffe          BL       Delay_us
                  |L1.3894|
000f36  f8a4a000          STRH     r10,[r4,#0]           ;1011
000f3a  e9cd4b00          STRD     r4,r11,[sp,#0]        ;1011
000f3e  2302              MOVS     r3,#2
000f40  f2405202          MOV      r2,#0x502
000f44  f8d90000          LDR      r0,[r9,#0]
000f48  9904              LDR      r1,[sp,#0x10]
000f4a  f7fffffe          BL       ecx_APRD
;;;1013         *estat = etohs(*estat);
000f4e  8821              LDRH     r1,[r4,#0]
;;;1014      }
;;;1015      while (((wkc <= 0) || ((*estat & EC_ESTAT_BUSY) > 0)) && ((bsp_GetTickCount()-timer2)<timeout)); /* wait for eeprom ready */
000f50  2800              CMP      r0,#0
000f52  dd01              BLE      |L1.3928|
000f54  0408              LSLS     r0,r1,#16
000f56  d507              BPL      |L1.3944|
                  |L1.3928|
000f58  f7fffffe          BL       bsp_GetTickCount
000f5c  1bc1              SUBS     r1,r0,r7
000f5e  4541              CMP      r1,r8
000f60  d3e3              BCC      |L1.3882|
;;;1016      if ((*estat & EC_ESTAT_BUSY) == 0)
000f62  8820              LDRH     r0,[r4,#0]
000f64  0400              LSLS     r0,r0,#16
000f66  d400              BMI      |L1.3946|
                  |L1.3944|
;;;1017      {
;;;1018         retval = 1;
000f68  2601              MOVS     r6,#1
                  |L1.3946|
;;;1019      }
;;;1020   
;;;1021      return retval;
000f6a  4630              MOV      r0,r6
;;;1022   }
000f6c  b007              ADD      sp,sp,#0x1c
000f6e  e541              B        |L1.2548|
;;;1023   
                          ENDP

                  ecx_readeepromAP PROC
;;;1030    */
;;;1031   uint64 ecx_readeepromAP(ecx_contextt *context, uint16 aiadr, uint16 eeproma, int timeout)
000f70  e92d4fff          PUSH     {r0-r11,lr}
;;;1032   {
000f74  b089              SUB      sp,sp,#0x24
;;;1033      uint16 estat;
;;;1034      uint32 edat32;
;;;1035      uint64 edat64;
;;;1036      ec_eepromt ed;
;;;1037      int wkc, cnt, nackcnt = 0;
000f76  2600              MOVS     r6,#0
;;;1038   
;;;1039      edat64 = 0;
;;;1040      edat32 = 0;
000f78  9607              STR      r6,[sp,#0x1c]
000f7a  e9cd6602          STRD     r6,r6,[sp,#8]
000f7e  4693              MOV      r11,r2                ;1032
000f80  4605              MOV      r5,r0                 ;1032
000f82  4634              MOV      r4,r6
;;;1041      if (ecx_eeprom_waitnotbusyAP(context, aiadr, &estat, timeout))
000f84  aa04              ADD      r2,sp,#0x10
000f86  9b0c              LDR      r3,[sp,#0x30]
000f88  990a              LDR      r1,[sp,#0x28]
000f8a  f7fffffe          BL       ecx_eeprom_waitnotbusyAP
000f8e  2800              CMP      r0,#0
000f90  d075              BEQ      |L1.4222|
;;;1042      {
;;;1043         if (estat & EC_ESTAT_EMASK) /* error bits are set */
000f92  f8bd0010          LDRH     r0,[sp,#0x10]
;;;1044         {
;;;1045            estat = htoes(EC_ECMD_NOP); /* clear error bits */
;;;1046            wkc = ecx_APWR(context->port, aiadr, ECT_REG_EEPCTL, sizeof(estat), &estat, EC_TIMEOUTRET3);
000f96  f2405702          MOV      r7,#0x502
000f9a  f4104ff0          TST      r0,#0x7800            ;1043
000f9e  d00c              BEQ      |L1.4026|
000fa0  f2417170          MOV      r1,#0x1770
000fa4  a804              ADD      r0,sp,#0x10
000fa6  e9cd0100          STRD     r0,r1,[sp,#0]
000faa  f8ad4010          STRH     r4,[sp,#0x10]         ;1045
000fae  2302              MOVS     r3,#2
000fb0  463a              MOV      r2,r7
000fb2  6828              LDR      r0,[r5,#0]
000fb4  990a              LDR      r1,[sp,#0x28]
000fb6  f7fffffe          BL       ecx_APWR
                  |L1.4026|
;;;1047         }
;;;1048   
;;;1049         do
;;;1050         {
;;;1051            ed.comm = htoes(EC_ECMD_READ);
;;;1052            ed.addr = htoes(eeproma);
;;;1053            ed.d2   = 0x0000;
;;;1054            cnt = 0;
;;;1055            do
;;;1056            {
;;;1057               wkc = ecx_APWR(context->port, aiadr, ECT_REG_EEPCTL, sizeof(ed), &ed, EC_TIMEOUTRET);
000fba  f44f67fa          MOV      r7,#0x7d0
;;;1058            }
;;;1059            while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
;;;1060            if (wkc)
;;;1061            {
;;;1062               Delay_us(EC_LOCALDELAY);
;;;1063               estat = 0x0000;
;;;1064               if (ecx_eeprom_waitnotbusyAP(context, aiadr, &estat, timeout))
;;;1065               {
;;;1066                  if (estat & EC_ESTAT_NACK)
;;;1067                  {
;;;1068                     nackcnt++;
;;;1069                     Delay_us(EC_LOCALDELAY * 5);
;;;1070                  }
;;;1071                  else
;;;1072                  {
;;;1073                     nackcnt = 0;
;;;1074                     if (estat & EC_ESTAT_R64)
;;;1075                     {
;;;1076                        cnt = 0;
;;;1077                        do
;;;1078                        {
;;;1079                           wkc = ecx_APRD(context->port, aiadr, ECT_REG_EEPDAT, sizeof(edat64), &edat64, EC_TIMEOUTRET);
000fbe  f44f6aa1          MOV      r10,#0x508
                  |L1.4034|
000fc2  f44f7080          MOV      r0,#0x100             ;1051
000fc6  f04f0800          MOV      r8,#0                 ;1053
000fca  f8ad0014          STRH     r0,[sp,#0x14]         ;1051
000fce  f8adb016          STRH     r11,[sp,#0x16]        ;1052
000fd2  f8ad8018          STRH     r8,[sp,#0x18]         ;1053
000fd6  4644              MOV      r4,r8                 ;1054
000fd8  f10d0914          ADD      r9,sp,#0x14           ;1036
                  |L1.4060|
000fdc  e9cd9700          STRD     r9,r7,[sp,#0]         ;1036
000fe0  2306              MOVS     r3,#6                 ;1057
000fe2  f2405202          MOV      r2,#0x502             ;1057
000fe6  6828              LDR      r0,[r5,#0]            ;1057
000fe8  990a              LDR      r1,[sp,#0x28]         ;1057
000fea  f7fffffe          BL       ecx_APWR
000fee  2800              CMP      r0,#0                 ;1059
000ff0  dc04              BGT      |L1.4092|
000ff2  4621              MOV      r1,r4                 ;1059
000ff4  1c64              ADDS     r4,r4,#1              ;1059
000ff6  2903              CMP      r1,#3                 ;1059
000ff8  dbf0              BLT      |L1.4060|
000ffa  b348              CBZ      r0,|L1.4176|
                  |L1.4092|
000ffc  20c8              MOVS     r0,#0xc8              ;1062
000ffe  f7fffffe          BL       Delay_us
001002  f8ad8010          STRH     r8,[sp,#0x10]         ;1063
001006  aa04              ADD      r2,sp,#0x10           ;1064
001008  4628              MOV      r0,r5                 ;1064
00100a  9b0c              LDR      r3,[sp,#0x30]         ;1064
00100c  990a              LDR      r1,[sp,#0x28]         ;1064
00100e  f7fffffe          BL       ecx_eeprom_waitnotbusyAP
001012  b1e8              CBZ      r0,|L1.4176|
001014  f8bd0010          LDRH     r0,[sp,#0x10]         ;1066
001018  0481              LSLS     r1,r0,#18             ;1066
00101a  d505              BPL      |L1.4136|
00101c  f44f707a          MOV      r0,#0x3e8             ;1069
001020  1c76              ADDS     r6,r6,#1              ;1069
001022  f7fffffe          BL       Delay_us
001026  e027              B        |L1.4216|
                  |L1.4136|
001028  2600              MOVS     r6,#0                 ;1073
00102a  0640              LSLS     r0,r0,#25             ;1074
;;;1080                        }
;;;1081                        while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
;;;1082                     }
;;;1083                     else
;;;1084                     {
;;;1085                        cnt = 0;
00102c  4634              MOV      r4,r6
00102e  d510              BPL      |L1.4178|
001030  f10d0808          ADD      r8,sp,#8              ;1079
                  |L1.4148|
001034  e9cd8700          STRD     r8,r7,[sp,#0]         ;1079
001038  2308              MOVS     r3,#8                 ;1079
00103a  4652              MOV      r2,r10                ;1079
00103c  6828              LDR      r0,[r5,#0]            ;1079
00103e  990a              LDR      r1,[sp,#0x28]         ;1079
001040  f7fffffe          BL       ecx_APRD
001044  2800              CMP      r0,#0                 ;1081
001046  dc17              BGT      |L1.4216|
001048  4620              MOV      r0,r4                 ;1081
00104a  1c64              ADDS     r4,r4,#1              ;1081
00104c  2803              CMP      r0,#3                 ;1081
00104e  dbf1              BLT      |L1.4148|
                  |L1.4176|
001050  e012              B        |L1.4216|
                  |L1.4178|
;;;1086                        do
;;;1087                        {
;;;1088                           wkc = ecx_APRD(context->port, aiadr, ECT_REG_EEPDAT, sizeof(edat32), &edat32, EC_TIMEOUTRET);
001052  f10d091c          ADD      r9,sp,#0x1c
                  |L1.4182|
001056  e9cd9700          STRD     r9,r7,[sp,#0]
00105a  2304              MOVS     r3,#4
00105c  4652              MOV      r2,r10
00105e  6828              LDR      r0,[r5,#0]
001060  990a              LDR      r1,[sp,#0x28]
001062  f7fffffe          BL       ecx_APRD
;;;1089                        }
;;;1090                        while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
001066  2800              CMP      r0,#0
001068  dc03              BGT      |L1.4210|
00106a  4620              MOV      r0,r4
00106c  1c64              ADDS     r4,r4,#1
00106e  2803              CMP      r0,#3
001070  dbf1              BLT      |L1.4182|
                  |L1.4210|
;;;1091                        edat64=(uint64)edat32;
001072  9907              LDR      r1,[sp,#0x1c]
001074  e9cd1802          STRD     r1,r8,[sp,#8]
                  |L1.4216|
;;;1092                     }
;;;1093                  }
;;;1094               }
;;;1095            }
;;;1096         }
;;;1097         while ((nackcnt > 0) && (nackcnt < 3));
001078  1e70              SUBS     r0,r6,#1
00107a  2802              CMP      r0,#2
00107c  d3a1              BCC      |L1.4034|
                  |L1.4222|
00107e  e9dd0102          LDRD     r0,r1,[sp,#8]
;;;1098      }
;;;1099   
;;;1100      return edat64;
;;;1101   }
001082  b00d              ADD      sp,sp,#0x34
001084  e4b6              B        |L1.2548|
;;;1102   
                          ENDP

                  ecx_writeeepromAP PROC
;;;1110    */
;;;1111   int ecx_writeeepromAP(ecx_contextt *context, uint16 aiadr, uint16 eeproma, uint16 data, int timeout)
001086  e92d4fff          PUSH     {r0-r11,lr}
;;;1112   {
00108a  b085              SUB      sp,sp,#0x14
;;;1113      uint16 estat;
;;;1114      ec_eepromt ed;
;;;1115      int wkc, rval = 0, cnt = 0, nackcnt = 0;
00108c  f04f0a00          MOV      r10,#0
001090  4606              MOV      r6,r0                 ;1112
001092  4655              MOV      r5,r10
;;;1116   
;;;1117      if (ecx_eeprom_waitnotbusyAP(context, aiadr, &estat, timeout))
001094  aa02              ADD      r2,sp,#8
001096  9b12              LDR      r3,[sp,#0x48]
001098  9906              LDR      r1,[sp,#0x18]
00109a  f7fffffe          BL       ecx_eeprom_waitnotbusyAP
00109e  2800              CMP      r0,#0
0010a0  d062              BEQ      |L1.4456|
;;;1118      {
;;;1119         if (estat & EC_ESTAT_EMASK) /* error bits are set */
0010a2  f8bd0008          LDRH     r0,[sp,#8]
0010a6  46d3              MOV      r11,r10
0010a8  f4104ff0          TST      r0,#0x7800
0010ac  d00d              BEQ      |L1.4298|
;;;1120         {
;;;1121            estat = htoes(EC_ECMD_NOP); /* clear error bits */
;;;1122            wkc = ecx_APWR(context->port, aiadr, ECT_REG_EEPCTL, sizeof(estat), &estat, EC_TIMEOUTRET3);
0010ae  f2417170          MOV      r1,#0x1770
0010b2  a802              ADD      r0,sp,#8
0010b4  e9cd0100          STRD     r0,r1,[sp,#0]
0010b8  f8adb008          STRH     r11,[sp,#8]           ;1121
0010bc  2302              MOVS     r3,#2
0010be  f2405202          MOV      r2,#0x502
0010c2  6830              LDR      r0,[r6,#0]
0010c4  9906              LDR      r1,[sp,#0x18]
0010c6  f7fffffe          BL       ecx_APWR
                  |L1.4298|
;;;1123         }
;;;1124         do
;;;1125         {
;;;1126            cnt = 0;
;;;1127            do
;;;1128            {
;;;1129               wkc = ecx_APWR(context->port, aiadr, ECT_REG_EEPDAT, sizeof(data), &data, EC_TIMEOUTRET);
0010ca  f44f67fa          MOV      r7,#0x7d0
                  |L1.4302|
0010ce  2400              MOVS     r4,#0                 ;1126
0010d0  f10d0820          ADD      r8,sp,#0x20
0010d4  f44f69a1          MOV      r9,#0x508
                  |L1.4312|
0010d8  e9cd8700          STRD     r8,r7,[sp,#0]
0010dc  2302              MOVS     r3,#2
0010de  464a              MOV      r2,r9
0010e0  6830              LDR      r0,[r6,#0]
0010e2  9906              LDR      r1,[sp,#0x18]
0010e4  f7fffffe          BL       ecx_APWR
;;;1130            }
;;;1131            while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
0010e8  2800              CMP      r0,#0
0010ea  dc03              BGT      |L1.4340|
0010ec  4620              MOV      r0,r4
0010ee  1c64              ADDS     r4,r4,#1
0010f0  2803              CMP      r0,#3
0010f2  dbf1              BLT      |L1.4312|
                  |L1.4340|
;;;1132   
;;;1133            ed.comm = EC_ECMD_WRITE;
0010f4  f2402001          MOV      r0,#0x201
0010f8  f8ad000c          STRH     r0,[sp,#0xc]
;;;1134            ed.addr = eeproma;
0010fc  9807              LDR      r0,[sp,#0x1c]
0010fe  f8ad000e          STRH     r0,[sp,#0xe]
;;;1135            ed.d2   = 0x0000;
001102  46d8              MOV      r8,r11
001104  f8adb010          STRH     r11,[sp,#0x10]
;;;1136            cnt = 0;
001108  2400              MOVS     r4,#0
00110a  f10d090c          ADD      r9,sp,#0xc            ;1114
                  |L1.4366|
00110e  e9cd9700          STRD     r9,r7,[sp,#0]         ;1114
;;;1137            do
;;;1138            {
;;;1139               wkc = ecx_APWR(context->port, aiadr, ECT_REG_EEPCTL, sizeof(ed), &ed, EC_TIMEOUTRET);
001112  2306              MOVS     r3,#6
001114  f2405202          MOV      r2,#0x502
001118  6830              LDR      r0,[r6,#0]
00111a  9906              LDR      r1,[sp,#0x18]
00111c  f7fffffe          BL       ecx_APWR
;;;1140            }
;;;1141            while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
001120  2800              CMP      r0,#0
001122  dc04              BGT      |L1.4398|
001124  4621              MOV      r1,r4
001126  1c64              ADDS     r4,r4,#1
001128  2903              CMP      r1,#3
00112a  dbf0              BLT      |L1.4366|
;;;1142            if (wkc)
00112c  b1c8              CBZ      r0,|L1.4450|
                  |L1.4398|
;;;1143            {
;;;1144               Delay_us(EC_LOCALDELAY * 2);
00112e  f44f70c8          MOV      r0,#0x190
001132  f7fffffe          BL       Delay_us
;;;1145               estat = 0x0000;
001136  f8ad8008          STRH     r8,[sp,#8]
;;;1146               if (ecx_eeprom_waitnotbusyAP(context, aiadr, &estat, timeout))
00113a  aa02              ADD      r2,sp,#8
00113c  4630              MOV      r0,r6
00113e  9b12              LDR      r3,[sp,#0x48]
001140  9906              LDR      r1,[sp,#0x18]
001142  f7fffffe          BL       ecx_eeprom_waitnotbusyAP
001146  b160              CBZ      r0,|L1.4450|
;;;1147               {
;;;1148                  if (estat & EC_ESTAT_NACK)
001148  f8bd0008          LDRH     r0,[sp,#8]
00114c  0480              LSLS     r0,r0,#18
00114e  d505              BPL      |L1.4444|
;;;1149                  {
;;;1150                     nackcnt++;
;;;1151                     Delay_us(EC_LOCALDELAY * 5);
001150  f44f707a          MOV      r0,#0x3e8
001154  1c6d              ADDS     r5,r5,#1
001156  f7fffffe          BL       Delay_us
00115a  e002              B        |L1.4450|
                  |L1.4444|
;;;1152                  }
;;;1153                  else
;;;1154                  {
;;;1155                     nackcnt = 0;
00115c  2500              MOVS     r5,#0
;;;1156                     rval = 1;
00115e  f04f0a01          MOV      r10,#1
                  |L1.4450|
;;;1157                  }
;;;1158               }
;;;1159            }
;;;1160   
;;;1161         }
;;;1162         while ((nackcnt > 0) && (nackcnt < 3));
001162  1e68              SUBS     r0,r5,#1
001164  2802              CMP      r0,#2
001166  d3b2              BCC      |L1.4302|
                  |L1.4456|
;;;1163      }
;;;1164   
;;;1165      return rval;
001168  4650              MOV      r0,r10
;;;1166   }
00116a  e6b4              B        |L1.3798|
;;;1167   
                          ENDP

                  ecx_pushindex PROC
;;;1275    */
;;;1276   static void ecx_pushindex(ecx_contextt *context, uint8 idx, void *data, uint16 length)
00116c  b530              PUSH     {r4,r5,lr}
;;;1277   {
;;;1278      if(context->idxstack->pushed < EC_MAXBUF)
00116e  6a85              LDR      r5,[r0,#0x28]
001170  782c              LDRB     r4,[r5,#0]
001172  2c10              CMP      r4,#0x10
001174  d211              BCS      |L1.4506|
;;;1279      {
;;;1280         context->idxstack->idx[context->idxstack->pushed] = idx;
001176  442c              ADD      r4,r4,r5
;;;1281         context->idxstack->data[context->idxstack->pushed] = data;
001178  2514              MOVS     r5,#0x14
00117a  70a1              STRB     r1,[r4,#2]            ;1280
00117c  6a81              LDR      r1,[r0,#0x28]
00117e  780c              LDRB     r4,[r1,#0]
001180  eb050484          ADD      r4,r5,r4,LSL #2
001184  510a              STR      r2,[r1,r4]
;;;1282         context->idxstack->length[context->idxstack->pushed] = length;
001186  6a81              LDR      r1,[r0,#0x28]
001188  2454              MOVS     r4,#0x54
00118a  780a              LDRB     r2,[r1,#0]
00118c  eb040242          ADD      r2,r4,r2,LSL #1
001190  528b              STRH     r3,[r1,r2]
;;;1283         context->idxstack->pushed++;
001192  6a80              LDR      r0,[r0,#0x28]
001194  7801              LDRB     r1,[r0,#0]
001196  1c49              ADDS     r1,r1,#1
001198  7001              STRB     r1,[r0,#0]
                  |L1.4506|
;;;1284      }
;;;1285   }
00119a  bd30              POP      {r4,r5,pc}
;;;1286   /** Pull index of segmented LRD/LWR/LRW combination.
                          ENDP

                  ecx_readeeprom1 PROC
;;;1562    */
;;;1563   void ecx_readeeprom1(ecx_contextt *context, uint16 slave, uint16 eeproma)
00119c  e92d43f0          PUSH     {r4-r9,lr}
;;;1564   {
0011a0  b085              SUB      sp,sp,#0x14
0011a2  4690              MOV      r8,r2
0011a4  460e              MOV      r6,r1
0011a6  4605              MOV      r5,r0
;;;1565      uint16 configadr, estat;
;;;1566      ec_eepromt ed;
;;;1567      int wkc, cnt = 0;
0011a8  2400              MOVS     r4,#0
;;;1568   
;;;1569      ecx_eeprom2master(context, slave); /* set eeprom control to master */
0011aa  f7fffffe          BL       ecx_eeprom2master
;;;1570      configadr = context->slavelist[slave].configadr;
0011ae  eb0601c6          ADD      r1,r6,r6,LSL #3
0011b2  6868              LDR      r0,[r5,#4]
0011b4  eb011186          ADD      r1,r1,r6,LSL #6
0011b8  2204              MOVS     r2,#4
0011ba  eb020181          ADD      r1,r2,r1,LSL #2
0011be  5a40              LDRH     r0,[r0,r1]
;;;1571      if (ecx_eeprom_waitnotbusyFP(context, configadr, &estat, EC_TIMEOUTEEP))
0011c0  f6446320          MOV      r3,#0x4e20
0011c4  4681              MOV      r9,r0                 ;1570
0011c6  4601              MOV      r1,r0
0011c8  aa04              ADD      r2,sp,#0x10
0011ca  4628              MOV      r0,r5
0011cc  f7fffffe          BL       ecx_eeprom_waitnotbusyFP
0011d0  2800              CMP      r0,#0
0011d2  d02e              BEQ      |L1.4658|
;;;1572      {
;;;1573         if (estat & EC_ESTAT_EMASK) /* error bits are set */
0011d4  f8bd0010          LDRH     r0,[sp,#0x10]
0011d8  4626              MOV      r6,r4
0011da  f4104ff0          TST      r0,#0x7800
;;;1574         {
;;;1575            estat = htoes(EC_ECMD_NOP); /* clear error bits */
;;;1576            wkc = ecx_FPWR(context->port, configadr, ECT_REG_EEPCTL, sizeof(estat), &estat, EC_TIMEOUTRET3);
0011de  f2405702          MOV      r7,#0x502
0011e2  d00c              BEQ      |L1.4606|
0011e4  f2417170          MOV      r1,#0x1770
0011e8  a804              ADD      r0,sp,#0x10
0011ea  e9cd0100          STRD     r0,r1,[sp,#0]
0011ee  f8ad6010          STRH     r6,[sp,#0x10]         ;1575
0011f2  2302              MOVS     r3,#2
0011f4  463a              MOV      r2,r7
0011f6  4649              MOV      r1,r9
0011f8  6828              LDR      r0,[r5,#0]
0011fa  f7fffffe          BL       ecx_FPWR
                  |L1.4606|
;;;1577         }
;;;1578         ed.comm = htoes(EC_ECMD_READ);
0011fe  f44f7080          MOV      r0,#0x100
001202  f8ad0008          STRH     r0,[sp,#8]
;;;1579         ed.addr = htoes(eeproma);
001206  f8ad800a          STRH     r8,[sp,#0xa]
;;;1580         ed.d2   = 0x0000;
00120a  f8ad600c          STRH     r6,[sp,#0xc]
00120e  46b8              MOV      r8,r7                 ;1576
001210  ae02              ADD      r6,sp,#8              ;1566
;;;1581         do
;;;1582         {
;;;1583            wkc = ecx_FPWR(context->port, configadr, ECT_REG_EEPCTL, sizeof(ed), &ed, EC_TIMEOUTRET);
001212  f44f67fa          MOV      r7,#0x7d0
                  |L1.4630|
001216  e9cd6700          STRD     r6,r7,[sp,#0]
00121a  2306              MOVS     r3,#6
00121c  4642              MOV      r2,r8
00121e  4649              MOV      r1,r9
001220  6828              LDR      r0,[r5,#0]
001222  f7fffffe          BL       ecx_FPWR
;;;1584         }
;;;1585         while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
001226  2800              CMP      r0,#0
001228  dc03              BGT      |L1.4658|
00122a  4620              MOV      r0,r4
00122c  1c64              ADDS     r4,r4,#1
00122e  2803              CMP      r0,#3
001230  dbf1              BLT      |L1.4630|
                  |L1.4658|
;;;1586      }
;;;1587   }
001232  b005              ADD      sp,sp,#0x14
001234  e8bd83f0          POP      {r4-r9,pc}
;;;1588   
                          ENDP

                  ecx_readeeprom2 PROC
;;;1595    */
;;;1596   uint32 ecx_readeeprom2(ecx_contextt *context, uint16 slave, int timeout)
001238  e92d47ff          PUSH     {r0-r10,lr}
;;;1597   {
;;;1598      uint16 estat, configadr;
;;;1599      uint32 edat;
;;;1600      int wkc, cnt = 0;
;;;1601   
;;;1602      configadr = context->slavelist[slave].configadr;
00123c  eb0103c1          ADD      r3,r1,r1,LSL #3
001240  eb031181          ADD      r1,r3,r1,LSL #6
001244  4605              MOV      r5,r0                 ;1597
001246  2304              MOVS     r3,#4
001248  6840              LDR      r0,[r0,#4]
00124a  eb030181          ADD      r1,r3,r1,LSL #2
00124e  2400              MOVS     r4,#0                 ;1600
001250  f8308001          LDRH     r8,[r0,r1]
;;;1603      edat = 0;
;;;1604      estat = 0x0000;
;;;1605      if (ecx_eeprom_waitnotbusyFP(context, configadr, &estat, timeout))
001254  4613              MOV      r3,r2
001256  9402              STR      r4,[sp,#8]            ;1604
001258  f8ad400c          STRH     r4,[sp,#0xc]          ;1604
00125c  aa03              ADD      r2,sp,#0xc
00125e  4641              MOV      r1,r8
001260  4628              MOV      r0,r5
001262  f7fffffe          BL       ecx_eeprom_waitnotbusyFP
001266  b190              CBZ      r0,|L1.4750|
;;;1606      {
;;;1607         do
;;;1608         {
;;;1609             wkc = ecx_FPRD(context->port, configadr, ECT_REG_EEPDAT, sizeof(edat), &edat, EC_TIMEOUTRET);
001268  f44f66fa          MOV      r6,#0x7d0
00126c  af02              ADD      r7,sp,#8
00126e  f44f69a1          MOV      r9,#0x508
                  |L1.4722|
001272  e9cd7600          STRD     r7,r6,[sp,#0]
001276  2304              MOVS     r3,#4
001278  464a              MOV      r2,r9
00127a  4641              MOV      r1,r8
00127c  6828              LDR      r0,[r5,#0]
00127e  f7fffffe          BL       ecx_FPRD
;;;1610         }
;;;1611         while ((wkc <= 0) && (cnt++ < EC_DEFAULTRETRIES));
001282  2800              CMP      r0,#0
001284  dc03              BGT      |L1.4750|
001286  4620              MOV      r0,r4
001288  1c64              ADDS     r4,r4,#1
00128a  2803              CMP      r0,#3
00128c  dbf1              BLT      |L1.4722|
                  |L1.4750|
;;;1612      }
;;;1613   
;;;1614      return edat;
00128e  9802              LDR      r0,[sp,#8]
;;;1615   }
001290  b004              ADD      sp,sp,#0x10
001292  e8bd87f0          POP      {r4-r10,pc}
;;;1616   #ifdef EC_VER1
                          ENDP

                  ec_init PROC
;;;1617   
;;;1618   int ec_init(void)  //更改；不需要传参数
001296  48ff              LDR      r0,|L1.5780|
;;;1619   {
001298  b510              PUSH     {r4,lr}
;;;1620   	 if(socket_mode==1)
00129a  7800              LDRB     r0,[r0,#0]  ; socket_mode
00129c  2801              CMP      r0,#1
00129e  d002              BEQ      |L1.4774|
;;;1621         ecx_init(&ecx_context);
;;;1622   	 else if(socket_mode==2)
0012a0  2802              CMP      r0,#2
0012a2  d004              BEQ      |L1.4782|
0012a4  e007              B        |L1.4790|
                  |L1.4774|
0012a6  48fc              LDR      r0,|L1.5784|
0012a8  f7fffffe          BL       ecx_init
0012ac  e003              B        |L1.4790|
                  |L1.4782|
;;;1623        ecx_init_redundant(&ecx_context,&ecx_redport);
0012ae  49fb              LDR      r1,|L1.5788|
0012b0  48f9              LDR      r0,|L1.5784|
0012b2  f7fffffe          BL       ecx_init_redundant
                  |L1.4790|
;;;1624   	 return 0;
0012b6  2000              MOVS     r0,#0
;;;1625   }
0012b8  bd10              POP      {r4,pc}
;;;1626   uint16 ec_statecheck(uint16 slave, uint16 reqstate, int timeout)
                          ENDP

                  ec_statecheck PROC
0012ba  4613              MOV      r3,r2
;;;1627   {
;;;1628      return ecx_statecheck (&ecx_context, slave, reqstate, timeout);
0012bc  460a              MOV      r2,r1
0012be  4601              MOV      r1,r0
0012c0  48f5              LDR      r0,|L1.5784|
0012c2  f7ffbffe          B.W      ecx_statecheck
;;;1629   }
;;;1630   
                          ENDP

                  ecx_FPRD_multi PROC
;;;1638   }
;;;1639   int ecx_FPRD_multi(ecx_contextt *context, int n, uint16 *configlst, ec_alstatust *slstatlst, int timeout)
0012c6  e92d4ff0          PUSH     {r4-r11,lr}
;;;1640   {
;;;1641      int wkc;
;;;1642      uint8 idx;
;;;1643      ecx_portt *port;
;;;1644      int sldatapos[MAX_FPRD_MULTI];
;;;1645      int slcnt;
;;;1646   
;;;1647      port = context->port;
;;;1648      idx = ecx_getindex(port);
0012ca  f8d09000          LDR      r9,[r0,#0]
0012ce  b0c7              SUB      sp,sp,#0x11c          ;1640
0012d0  461d              MOV      r5,r3                 ;1640
0012d2  4690              MOV      r8,r2                 ;1640
0012d4  460e              MOV      r6,r1                 ;1640
0012d6  4648              MOV      r0,r9
0012d8  f7fffffe          BL       ecx_getindex
0012dc  b2c0              UXTB     r0,r0
;;;1649      slcnt = 0;
;;;1650      ecx_setupdatagram(port, &(port->txbuf[idx]), EC_CMD_FPRD, idx,
0012de  9045              STR      r0,[sp,#0x114]
0012e0  f8b82000          LDRH     r2,[r8,#0]
0012e4  f04f0a06          MOV      r10,#6
0012e8  f44f7b98          MOV      r11,#0x130
0012ec  e9cd2b00          STRD     r2,r11,[sp,#0]
0012f0  e9cda502          STRD     r10,r5,[sp,#8]
0012f4  9845              LDR      r0,[sp,#0x114]
0012f6  2400              MOVS     r4,#0                 ;1649
0012f8  f24021f7          MOV      r1,#0x2f7
0012fc  fb10f001          SMULBB   r0,r0,r1
001300  eb090140          ADD      r1,r9,r0,LSL #1
001304  9046              STR      r0,[sp,#0x118]
001306  f246506c          MOV      r0,#0x656c
00130a  180f              ADDS     r7,r1,r0
00130c  2204              MOVS     r2,#4
00130e  4639              MOV      r1,r7
001310  4648              MOV      r0,r9
001312  9b45              LDR      r3,[sp,#0x114]
001314  f7fffffe          BL       ecx_setupdatagram
;;;1651         *(configlst + slcnt), ECT_REG_ALSTAT, sizeof(ec_alstatust), slstatlst + slcnt);
;;;1652      sldatapos[slcnt] = EC_HEADERSIZE;
001318  200c              MOVS     r0,#0xc
00131a  f10d0b14          ADD      r11,sp,#0x14
;;;1653      while(++slcnt < (n - 1))
00131e  f1a60a01          SUB      r10,r6,#1
001322  9005              STR      r0,[sp,#0x14]
001324  e016              B        |L1.4948|
                  |L1.4902|
;;;1654      {
;;;1655         sldatapos[slcnt] = ecx_adddatagram(port, &(port->txbuf[idx]), EC_CMD_FPRD, idx, TRUE,
001326  f44f7298          MOV      r2,#0x130
00132a  f8383014          LDRH     r3,[r8,r4,LSL #1]
00132e  eb040044          ADD      r0,r4,r4,LSL #1
001332  9202              STR      r2,[sp,#8]
001334  eb050040          ADD      r0,r5,r0,LSL #1
001338  2106              MOVS     r1,#6
00133a  e9cd1003          STRD     r1,r0,[sp,#0xc]
00133e  2001              MOVS     r0,#1
001340  e9cd0300          STRD     r0,r3,[sp,#0]
001344  4639              MOV      r1,r7
001346  2204              MOVS     r2,#4
001348  4648              MOV      r0,r9
00134a  9b45              LDR      r3,[sp,#0x114]
00134c  f7fffffe          BL       ecx_adddatagram
001350  f84b0024          STR      r0,[r11,r4,LSL #2]
                  |L1.4948|
001354  1c64              ADDS     r4,r4,#1
001356  4554              CMP      r4,r10                ;1653
001358  dbe5              BLT      |L1.4902|
;;;1656                               *(configlst + slcnt), ECT_REG_ALSTAT, sizeof(ec_alstatust), slstatlst + slcnt);
;;;1657      }
;;;1658      if(slcnt < n)
00135a  42b4              CMP      r4,r6
00135c  da15              BGE      |L1.5002|
;;;1659      {
;;;1660         sldatapos[slcnt] = ecx_adddatagram(port, &(port->txbuf[idx]), EC_CMD_FPRD, idx, FALSE,
00135e  eb040044          ADD      r0,r4,r4,LSL #1
001362  eb050040          ADD      r0,r5,r0,LSL #1
001366  2206              MOVS     r2,#6
001368  f8381014          LDRH     r1,[r8,r4,LSL #1]
00136c  e9cd2003          STRD     r2,r0,[sp,#0xc]
001370  f44f7398          MOV      r3,#0x130
001374  2000              MOVS     r0,#0
001376  e88d000b          STM      sp,{r0,r1,r3}
00137a  4639              MOV      r1,r7
00137c  2204              MOVS     r2,#4
00137e  4648              MOV      r0,r9
001380  9b45              LDR      r3,[sp,#0x114]
001382  f7fffffe          BL       ecx_adddatagram
001386  f84b0024          STR      r0,[r11,r4,LSL #2]
                  |L1.5002|
;;;1661                               *(configlst + slcnt), ECT_REG_ALSTAT, sizeof(ec_alstatust), slstatlst + slcnt);
;;;1662      }
;;;1663      wkc = ecx_srconfirm(port, idx, timeout);
00138a  4648              MOV      r0,r9
00138c  9a50              LDR      r2,[sp,#0x140]
00138e  9945              LDR      r1,[sp,#0x114]
001390  f7fffffe          BL       ecx_srconfirm
001394  0004              MOVS     r4,r0
;;;1664      if (wkc >= 0)
001396  d418              BMI      |L1.5066|
;;;1665      {
;;;1666         for(slcnt = 0 ; slcnt < n ; slcnt++)
001398  2200              MOVS     r2,#0
;;;1667         {
;;;1668            memcpy(slstatlst + slcnt, &(port->rxbuf[idx][sldatapos[slcnt]]), sizeof(ec_alstatust));
00139a  9846              LDR      r0,[sp,#0x118]
00139c  2118              MOVS     r1,#0x18
00139e  465f              MOV      r7,r11                ;1644
0013a0  eb010340          ADD      r3,r1,r0,LSL #1
0013a4  e00f              B        |L1.5062|
                  |L1.5030|
0013a6  f8571022          LDR      r1,[r7,r2,LSL #2]
0013aa  eb010009          ADD      r0,r1,r9
0013ae  4418              ADD      r0,r0,r3
0013b0  eb020142          ADD      r1,r2,r2,LSL #1
0013b4  eb050141          ADD      r1,r5,r1,LSL #1
0013b8  f8d0c000          LDR      r12,[r0,#0]
0013bc  f8c1c000          STR      r12,[r1,#0]
0013c0  8880              LDRH     r0,[r0,#4]
0013c2  8088              STRH     r0,[r1,#4]
0013c4  1c52              ADDS     r2,r2,#1
                  |L1.5062|
0013c6  42b2              CMP      r2,r6                 ;1666
0013c8  dbed              BLT      |L1.5030|
                  |L1.5066|
;;;1669         }
;;;1670      }
;;;1671      ecx_setbufstat(port, idx, EC_BUF_EMPTY);
0013ca  2200              MOVS     r2,#0
0013cc  4648              MOV      r0,r9
0013ce  9945              LDR      r1,[sp,#0x114]
0013d0  f7fffffe          BL       ecx_setbufstat
;;;1672      return wkc;
;;;1673   }
0013d4  b047              ADD      sp,sp,#0x11c
0013d6  4620              MOV      r0,r4                 ;1672
                  |L1.5080|
0013d8  e8bd8ff0          POP      {r4-r11,pc}
;;;1674   /** Read all slave states in ec_slave.
                          ENDP

                  ecx_readstate PROC
;;;1677    */
;;;1678   int ecx_readstate(ecx_contextt *context)
0013dc  e92d4ff0          PUSH     {r4-r11,lr}
;;;1679   {
0013e0  f5ad7d03          SUB      sp,sp,#0x20c
;;;1680      uint16 slave, fslave, lslave, configadr, lowest, rval, bitwisestate;
;;;1681      ec_alstatust sl[MAX_FPRD_MULTI];
;;;1682      uint16 slca[MAX_FPRD_MULTI];
;;;1683      boolean noerrorflag, allslavessamestate;
;;;1684      boolean allslavespresent = FALSE;
0013e4  2600              MOVS     r6,#0
0013e6  4604              MOV      r4,r0                 ;1679
;;;1685      int wkc;
;;;1686   
;;;1687      /* Try to establish the state of all slaves sending only one broadcast datagram.
;;;1688       * This way a number of datagrams equal to the number of slaves will be sent only if needed.*/
;;;1689      rval = 0;
0013e8  f8ad6208          STRH     r6,[sp,#0x208]
;;;1690      wkc = ecx_BRD(context->port, 0, ECT_REG_ALSTAT, sizeof(rval), &rval, EC_TIMEOUTRET);
0013ec  f44f61fa          MOV      r1,#0x7d0
0013f0  a882              ADD      r0,sp,#0x208
0013f2  e9cd0100          STRD     r0,r1,[sp,#0]
0013f6  4635              MOV      r5,r6                 ;1689
0013f8  2302              MOVS     r3,#2
0013fa  f44f7298          MOV      r2,#0x130
0013fe  4631              MOV      r1,r6
001400  6820              LDR      r0,[r4,#0]
001402  f7fffffe          BL       ecx_BRD
;;;1691   
;;;1692      if(wkc >= *(context->slavecount))
001406  68a1              LDR      r1,[r4,#8]
001408  6809              LDR      r1,[r1,#0]
00140a  4281              CMP      r1,r0
00140c  dc00              BGT      |L1.5136|
;;;1693      {
;;;1694         allslavespresent = TRUE;
00140e  2601              MOVS     r6,#1
                  |L1.5136|
;;;1695      }
;;;1696   
;;;1697      rval = etohs(rval);
001410  f8bd0208          LDRH     r0,[sp,#0x208]
;;;1698      bitwisestate = (rval & 0x0f);
001414  f000070f          AND      r7,r0,#0xf
;;;1699   
;;;1700      if ((rval & EC_STATE_ERROR) == 0)
001418  06c0              LSLS     r0,r0,#27
00141a  d403              BMI      |L1.5156|
;;;1701      {
;;;1702         noerrorflag = TRUE;
;;;1703         context->slavelist[0].ALstatuscode = 0;
00141c  6860              LDR      r0,[r4,#4]
00141e  2101              MOVS     r1,#1                 ;1702
001420  8045              STRH     r5,[r0,#2]
001422  e000              B        |L1.5158|
                  |L1.5156|
;;;1704      }   
;;;1705      else
;;;1706      {
;;;1707         noerrorflag = FALSE;
001424  2100              MOVS     r1,#0
                  |L1.5158|
;;;1708      }
;;;1709   
;;;1710      switch (bitwisestate)
001426  2f09              CMP      r7,#9
001428  d20a              BCS      |L1.5184|
00142a  e8dff007          TBB      [pc,r7]
00142e  0905              DCB      0x09,0x05
001430  05050509          DCB      0x05,0x05,0x05,0x09
001434  09090500          DCB      0x09,0x09,0x05,0x00
;;;1711      {
;;;1712         case EC_STATE_INIT:
;;;1713         case EC_STATE_PRE_OP:
;;;1714         case EC_STATE_BOOT:
;;;1715         case EC_STATE_SAFE_OP:
;;;1716         case EC_STATE_OPERATIONAL:
;;;1717            allslavessamestate = TRUE;
;;;1718            context->slavelist[0].state = bitwisestate;
001438  6862              LDR      r2,[r4,#4]
00143a  2001              MOVS     r0,#1                 ;1717
00143c  8017              STRH     r7,[r2,#0]
;;;1719            break;
00143e  e000              B        |L1.5186|
                  |L1.5184|
;;;1720         default:
;;;1721            allslavessamestate = FALSE;
001440  2000              MOVS     r0,#0
                  |L1.5186|
001442  f04f0b02          MOV      r11,#2                ;1690
;;;1722            break;
;;;1723      }
;;;1724       
;;;1725      if (noerrorflag && allslavessamestate && allslavespresent)
001446  b1b1              CBZ      r1,|L1.5238|
001448  b1a8              CBZ      r0,|L1.5238|
00144a  b1a6              CBZ      r6,|L1.5238|
;;;1726      {
;;;1727         /* No slave has toggled the error flag so the alstatuscode
;;;1728          * (even if different from 0) should be ignored and
;;;1729          * the slaves have reached the same state so the internal state
;;;1730          * can be updated without sending any datagram. */
;;;1731         for (slave = 1; slave <= *(context->slavecount); slave++)
00144c  2001              MOVS     r0,#1
00144e  465a              MOV      r2,r11                ;1690
001450  e00c              B        |L1.5228|
                  |L1.5202|
;;;1732         {
;;;1733            context->slavelist[slave].ALstatuscode = 0x0000;
001452  eb0001c0          ADD      r1,r0,r0,LSL #3
001456  6863              LDR      r3,[r4,#4]
001458  eb011180          ADD      r1,r1,r0,LSL #6
00145c  eb020681          ADD      r6,r2,r1,LSL #2
001460  539d              STRH     r5,[r3,r6]
;;;1734            context->slavelist[slave].state = bitwisestate;
001462  6863              LDR      r3,[r4,#4]
001464  1c40              ADDS     r0,r0,#1
001466  b280              UXTH     r0,r0                 ;1731
001468  f8237021          STRH     r7,[r3,r1,LSL #2]
                  |L1.5228|
00146c  68a1              LDR      r1,[r4,#8]            ;1731
00146e  6809              LDR      r1,[r1,#0]            ;1731
001470  4281              CMP      r1,r0                 ;1731
001472  daee              BGE      |L1.5202|
001474  e06d              B        |L1.5458|
                  |L1.5238|
;;;1735         }
;;;1736         lowest = bitwisestate;
;;;1737      }
;;;1738      else
;;;1739      {
;;;1740         /* Not all slaves have the same state or at least one is in error so one datagram per slave
;;;1741          * is needed. */
;;;1742         context->slavelist[0].ALstatuscode = 0;
001476  6861              LDR      r1,[r4,#4]
001478  2000              MOVS     r0,#0
;;;1743         lowest = 0xff;
00147a  27ff              MOVS     r7,#0xff
00147c  8048              STRH     r0,[r1,#2]            ;1742
;;;1744         fslave = 1;
00147e  2501              MOVS     r5,#1
001480  f10d0908          ADD      r9,sp,#8              ;1681
;;;1745         do
;;;1746         {
;;;1747            lslave = *(context->slavecount);
;;;1748            if ((lslave - fslave) >= MAX_FPRD_MULTI)
;;;1749            {
;;;1750               lslave = fslave + MAX_FPRD_MULTI - 1;
;;;1751            }
;;;1752            for (slave = fslave; slave <= lslave; slave++)
;;;1753            {
;;;1754               const ec_alstatust zero = { 0, 0, 0 };
;;;1755   
;;;1756               configadr = context->slavelist[slave].configadr;
001484  f04f0a04          MOV      r10,#4
                  |L1.5256|
001488  68a0              LDR      r0,[r4,#8]            ;1747
00148a  8800              LDRH     r0,[r0,#0]            ;1747
00148c  b286              UXTH     r6,r0                 ;1747
00148e  1b70              SUBS     r0,r6,r5              ;1748
001490  2840              CMP      r0,#0x40              ;1748
001492  db02              BLT      |L1.5274|
001494  f105003f          ADD      r0,r5,#0x3f           ;1750
001498  b286              UXTH     r6,r0                 ;1750
                  |L1.5274|
00149a  4628              MOV      r0,r5                 ;1752
00149c  f04f0800          MOV      r8,#0                 ;1752
0014a0  aa62              ADD      r2,sp,#0x188          ;1682
0014a2  e019              B        |L1.5336|
                  |L1.5284|
0014a4  f8cd8000          STR      r8,[sp,#0]            ;1754
0014a8  f8cd8004          STR      r8,[sp,#4]
0014ac  eb0001c0          ADD      r1,r0,r0,LSL #3
0014b0  6863              LDR      r3,[r4,#4]
0014b2  eb011c80          ADD      r12,r1,r0,LSL #6
0014b6  eb0a018c          ADD      r1,r10,r12,LSL #2
0014ba  5a5b              LDRH     r3,[r3,r1]
;;;1757               slca[slave - fslave] = configadr;
0014bc  1b41              SUBS     r1,r0,r5
;;;1758               sl[slave - fslave] = zero;
0014be  1c40              ADDS     r0,r0,#1
0014c0  f8223011          STRH     r3,[r2,r1,LSL #1]     ;1757
0014c4  eb010341          ADD      r3,r1,r1,LSL #1
0014c8  eb090143          ADD      r1,r9,r3,LSL #1
0014cc  b280              UXTH     r0,r0                 ;1752
0014ce  f8c18000          STR      r8,[r1,#0]
0014d2  f8bd3004          LDRH     r3,[sp,#4]
0014d6  808b              STRH     r3,[r1,#4]
                  |L1.5336|
0014d8  42b0              CMP      r0,r6                 ;1752
0014da  d9e3              BLS      |L1.5284|
;;;1759            }
;;;1760            ecx_FPRD_multi(context, (lslave - fslave) + 1, &(slca[0]), &(sl[0]), EC_TIMEOUTRET3);
0014dc  f2417070          MOV      r0,#0x1770
0014e0  1b71              SUBS     r1,r6,r5
0014e2  9000              STR      r0,[sp,#0]
0014e4  ab02              ADD      r3,sp,#8
0014e6  aa62              ADD      r2,sp,#0x188
0014e8  4620              MOV      r0,r4
0014ea  1c49              ADDS     r1,r1,#1
0014ec  f7fffffe          BL       ecx_FPRD_multi
;;;1761            for (slave = fslave; slave <= lslave; slave++)
0014f0  4628              MOV      r0,r5
0014f2  e024              B        |L1.5438|
                  |L1.5364|
;;;1762            {
;;;1763               configadr = context->slavelist[slave].configadr;
;;;1764               rval = etohs(sl[slave - fslave].alstatus);
0014f4  1b42              SUBS     r2,r0,r5
0014f6  eb020242          ADD      r2,r2,r2,LSL #1
0014fa  eb0001c0          ADD      r1,r0,r0,LSL #3       ;1763
0014fe  f8398012          LDRH     r8,[r9,r2,LSL #1]
001502  6863              LDR      r3,[r4,#4]
;;;1765               context->slavelist[slave].ALstatuscode = etohs(sl[slave - fslave].alstatuscode);
001504  eb090242          ADD      r2,r9,r2,LSL #1
001508  eb011180          ADD      r1,r1,r0,LSL #6       ;1763
00150c  f8ad8208          STRH     r8,[sp,#0x208]        ;1764
001510  8892              LDRH     r2,[r2,#4]
001512  eb0b0c81          ADD      r12,r11,r1,LSL #2
001516  f823200c          STRH     r2,[r3,r12]
;;;1766               if ((rval & 0xf) < lowest)
00151a  f8bd3208          LDRH     r3,[sp,#0x208]
00151e  f003020f          AND      r2,r3,#0xf
001522  42ba              CMP      r2,r7
001524  d200              BCS      |L1.5416|
;;;1767               {
;;;1768                  lowest = (rval & 0xf);
001526  4617              MOV      r7,r2
                  |L1.5416|
;;;1769               }
;;;1770               context->slavelist[slave].state = rval;
001528  6862              LDR      r2,[r4,#4]
00152a  f8223021          STRH     r3,[r2,r1,LSL #2]
;;;1771               context->slavelist[0].ALstatuscode |= context->slavelist[slave].ALstatuscode;
00152e  6861              LDR      r1,[r4,#4]
001530  f831200c          LDRH     r2,[r1,r12]
001534  884b              LDRH     r3,[r1,#2]
001536  431a              ORRS     r2,r2,r3
001538  1c40              ADDS     r0,r0,#1
00153a  804a              STRH     r2,[r1,#2]
00153c  b280              UXTH     r0,r0                 ;1761
                  |L1.5438|
00153e  42b0              CMP      r0,r6                 ;1761
001540  d9d8              BLS      |L1.5364|
;;;1772            }
;;;1773            fslave = lslave + 1;
001542  1c70              ADDS     r0,r6,#1
001544  b285              UXTH     r5,r0
;;;1774         } while (lslave < *(context->slavecount));
001546  68a0              LDR      r0,[r4,#8]
001548  6800              LDR      r0,[r0,#0]
00154a  42b0              CMP      r0,r6
00154c  dc9c              BGT      |L1.5256|
;;;1775         context->slavelist[0].state = lowest;
00154e  6860              LDR      r0,[r4,#4]
001550  8007              STRH     r7,[r0,#0]
                  |L1.5458|
;;;1776      }
;;;1777     
;;;1778      return lowest;
001552  4638              MOV      r0,r7
;;;1779   }
001554  f50d7d03          ADD      sp,sp,#0x20c
001558  e73e              B        |L1.5080|
;;;1780   /** Receive processdata from slaves.
                          ENDP

                  ec_readstate PROC
;;;1634    */
;;;1635   int ec_readstate(void)
00155a  484f              LDR      r0,|L1.5784|
;;;1636   {
;;;1637      return ecx_readstate (&ecx_context);
00155c  e7fe              B        ecx_readstate
;;;1638   }
;;;1639   int ecx_FPRD_multi(ecx_contextt *context, int n, uint16 *configlst, ec_alstatust *slstatlst, int timeout)
                          ENDP

                  ecx_receive_processdata_group PROC
;;;1788    */
;;;1789   int ecx_receive_processdata_group(ecx_contextt *context, uint8 group, int timeout)
00155e  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1790   {
001562  b082              SUB      sp,sp,#8
;;;1791      int pos, idx;
;;;1792      int wkc = 0, wkc2;
001564  2500              MOVS     r5,#0
;;;1793      uint16 le_wkc = 0;
001566  f8ad5000          STRH     r5,[sp,#0]
00156a  4604              MOV      r4,r0                 ;1790
;;;1794      int64 le_DCtime;
;;;1795      boolean first = FALSE;
;;;1796   
;;;1797      if(context->grouplist[group].hasdc)
00156c  6902              LDR      r2,[r0,#0x10]
00156e  eb010081          ADD      r0,r1,r1,LSL #2
001572  eb001141          ADD      r1,r0,r1,LSL #5
001576  2014              MOVS     r0,#0x14
001578  eb0000c1          ADD      r0,r0,r1,LSL #3
00157c  46a8              MOV      r8,r5                 ;1795
00157e  5c10              LDRB     r0,[r2,r0]
001580  b108              CBZ      r0,|L1.5510|
;;;1798      {
;;;1799         first = TRUE;
001582  f04f0801          MOV      r8,#1
                  |L1.5510|
;;;1800      }
;;;1801      /* get first index */
;;;1802      pos = ecx_pullindex(context);
001586  4620              MOV      r0,r4
001588  f7fffffe          BL       ecx_pullindex
00158c  4607              MOV      r7,r0
;;;1803      /* read the same number of frames as send */
;;;1804      while (pos >= 0)
;;;1805      {
;;;1806         idx = context->idxstack->idx[pos];
;;;1807         wkc2 = ecx_waitinframe(context->port, context->idxstack->idx[pos], timeout);
;;;1808         /* check if there is input data in frame */
;;;1809         if (wkc2 > EC_NOFRAME)
;;;1810         {
;;;1811            if((context->port->rxbuf[idx][EC_CMDOFFSET]==EC_CMD_LRD) || (context->port->rxbuf[idx][EC_CMDOFFSET]==EC_CMD_LRW))
;;;1812            {
;;;1813               if(first)
;;;1814               {
;;;1815                  memcpy(context->idxstack->data[pos], &(context->port->rxbuf[idx][EC_HEADERSIZE]), context->DCl);
00158e  f04f0b24          MOV      r11,#0x24
001592  e065              B        |L1.5728|
                  |L1.5524|
001594  6aa1              LDR      r1,[r4,#0x28]         ;1806
001596  1cb8              ADDS     r0,r7,#2              ;1806
001598  9a04              LDR      r2,[sp,#0x10]         ;1807
00159a  5c09              LDRB     r1,[r1,r0]            ;1806
00159c  6820              LDR      r0,[r4,#0]            ;1807
00159e  468a              MOV      r10,r1                ;1806
0015a0  f7fffffe          BL       ecx_waitinframe
0015a4  ea5f0900          MOVS     r9,r0                 ;1807
0015a8  d451              BMI      |L1.5710|
0015aa  f24022f7          MOV      r2,#0x2f7             ;1811
0015ae  fb1af602          SMULBB   r6,r10,r2             ;1811
0015b2  211a              MOVS     r1,#0x1a              ;1811
0015b4  6820              LDR      r0,[r4,#0]            ;1811
0015b6  eb010146          ADD      r1,r1,r6,LSL #1       ;1811
0015ba  5c41              LDRB     r1,[r0,r1]            ;1811
0015bc  290a              CMP      r1,#0xa               ;1811
0015be  d004              BEQ      |L1.5578|
0015c0  290c              CMP      r1,#0xc               ;1811
0015c2  d002              BEQ      |L1.5578|
;;;1816                  memcpy(&le_wkc, &(context->port->rxbuf[idx][EC_HEADERSIZE + context->DCl]), EC_WKCSIZE);
;;;1817                  wkc = etohs(le_wkc);
;;;1818                  memcpy(&le_DCtime, &(context->port->rxbuf[idx][context->DCtO]), sizeof(le_DCtime));
;;;1819                  *(context->DCtime) = etohll(le_DCtime);
;;;1820                  first = FALSE;
;;;1821               }
;;;1822               else
;;;1823               {
;;;1824                  /* copy input data back to process data buffer */
;;;1825                  memcpy(context->idxstack->data[pos], &(context->port->rxbuf[idx][EC_HEADERSIZE]), context->idxstack->length[pos]);
;;;1826                  wkc += wkc2;
;;;1827               }
;;;1828            }
;;;1829            else if(context->port->rxbuf[idx][EC_CMDOFFSET]==EC_CMD_LWR)
0015c4  290b              CMP      r1,#0xb
0015c6  d026              BEQ      |L1.5654|
0015c8  e041              B        |L1.5710|
                  |L1.5578|
0015ca  f1b80f00          CMP      r8,#0                 ;1813
0015ce  d012              BEQ      |L1.5622|
0015d0  eb0b0546          ADD      r5,r11,r6,LSL #1      ;1815
0015d4  1941              ADDS     r1,r0,r5              ;1815
0015d6  2014              MOVS     r0,#0x14              ;1815
0015d8  6aa2              LDR      r2,[r4,#0x28]         ;1815
0015da  eb000087          ADD      r0,r0,r7,LSL #2       ;1815
0015de  5810              LDR      r0,[r2,r0]            ;1815
0015e0  8e62              LDRH     r2,[r4,#0x32]         ;1815
0015e2  f7fffffe          BL       __aeabi_memcpy
0015e6  8e61              LDRH     r1,[r4,#0x32]         ;1816
0015e8  6820              LDR      r0,[r4,#0]            ;1816
0015ea  4401              ADD      r1,r1,r0              ;1816
0015ec  4429              ADD      r1,r1,r5              ;1816
0015ee  880d              LDRH     r5,[r1,#0]            ;1816
0015f0  f8ad5000          STRH     r5,[sp,#0]            ;1816
0015f4  e01b              B        |L1.5678|
                  |L1.5622|
0015f6  6aa3              LDR      r3,[r4,#0x28]         ;1825
0015f8  2154              MOVS     r1,#0x54              ;1825
0015fa  eb010147          ADD      r1,r1,r7,LSL #1       ;1825
0015fe  5a5a              LDRH     r2,[r3,r1]            ;1825
001600  eb0b0146          ADD      r1,r11,r6,LSL #1      ;1825
001604  4401              ADD      r1,r1,r0              ;1825
001606  2014              MOVS     r0,#0x14              ;1825
001608  eb000087          ADD      r0,r0,r7,LSL #2       ;1825
00160c  5818              LDR      r0,[r3,r0]            ;1825
00160e  f7fffffe          BL       __aeabi_memcpy
001612  444d              ADD      r5,r5,r9              ;1826
001614  e01b              B        |L1.5710|
                  |L1.5654|
;;;1830            {
;;;1831               if(first)
001616  f1b80f00          CMP      r8,#0
00161a  d016              BEQ      |L1.5706|
;;;1832               {
;;;1833                  memcpy(&le_wkc, &(context->port->rxbuf[idx][EC_HEADERSIZE + context->DCl]), EC_WKCSIZE);
00161c  8e61              LDRH     r1,[r4,#0x32]
00161e  1842              ADDS     r2,r0,r1
001620  eb0b0146          ADD      r1,r11,r6,LSL #1
001624  4411              ADD      r1,r1,r2
001626  8809              LDRH     r1,[r1,#0]
001628  f8ad1000          STRH     r1,[sp,#0]
;;;1834                  /* output WKC counts 2 times when using LRW, emulate the same for LWR */
;;;1835                  wkc = etohs(le_wkc) * 2;
00162c  004d              LSLS     r5,r1,#1
                  |L1.5678|
;;;1836                  memcpy(&le_DCtime, &(context->port->rxbuf[idx][context->DCtO]), sizeof(le_DCtime));
00162e  8e21              LDRH     r1,[r4,#0x30]
;;;1837                  *(context->DCtime) = etohll(le_DCtime);
;;;1838                  first = FALSE;
001630  f04f0800          MOV      r8,#0
001634  4401              ADD      r1,r1,r0              ;1836
001636  2018              MOVS     r0,#0x18              ;1836
001638  eb000046          ADD      r0,r0,r6,LSL #1       ;1836
00163c  4408              ADD      r0,r0,r1              ;1836
00163e  6801              LDR      r1,[r0,#0]            ;1836
001640  6842              LDR      r2,[r0,#4]            ;1836
001642  6b60              LDR      r0,[r4,#0x34]         ;1837
001644  e9c01200          STRD     r1,r2,[r0,#0]         ;1837
001648  e001              B        |L1.5710|
                  |L1.5706|
;;;1839               }
;;;1840               else
;;;1841               {
;;;1842                  /* output WKC counts 2 times when using LRW, emulate the same for LWR */
;;;1843                  wkc += wkc2 * 2;
00164a  eb050549          ADD      r5,r5,r9,LSL #1
                  |L1.5710|
;;;1844               }
;;;1845            }
;;;1846         }
;;;1847         /* release buffer */
;;;1848         ecx_setbufstat(context->port, idx, EC_BUF_EMPTY);
00164e  2200              MOVS     r2,#0
001650  4651              MOV      r1,r10
001652  6820              LDR      r0,[r4,#0]
001654  f7fffffe          BL       ecx_setbufstat
;;;1849         /* get next index */
;;;1850         pos = ecx_pullindex(context);
001658  4620              MOV      r0,r4
00165a  f7fffffe          BL       ecx_pullindex
00165e  4607              MOV      r7,r0
                  |L1.5728|
001660  2f00              CMP      r7,#0                 ;1804
001662  da97              BGE      |L1.5524|
;;;1851      }
;;;1852   
;;;1853      return wkc;
001664  4628              MOV      r0,r5
;;;1854   }
001666  b005              ADD      sp,sp,#0x14
001668  e6b6              B        |L1.5080|
;;;1855   /** Write slave state, if slave = 0 then write to all slaves.
                          ENDP

                  ecx_writestate PROC
;;;1870    */
;;;1871   int ecx_writestate(ecx_contextt *context, uint16 slave)
00166a  b53e              PUSH     {r1-r5,lr}
;;;1872   {
;;;1873      int ret;
;;;1874      uint16 configadr, slstate;
;;;1875   
;;;1876      if (slave == 0)
;;;1877      {
;;;1878         slstate = htoes(context->slavelist[slave].state);
;;;1879         ret = ecx_BWR(context->port, 0, ECT_REG_ALCTL, sizeof(slstate),
00166c  c809              LDM      r0,{r0,r3}
00166e  f2417570          MOV      r5,#0x1770
001672  f44f7290          MOV      r2,#0x120
001676  b199              CBZ      r1,|L1.5792|
;;;1880   	            &slstate, EC_TIMEOUTRET3);
;;;1881      }
;;;1882      else
;;;1883      {
;;;1884         configadr = context->slavelist[slave].configadr;
001678  eb0104c1          ADD      r4,r1,r1,LSL #3
00167c  eb041481          ADD      r4,r4,r1,LSL #6
001680  2104              MOVS     r1,#4
001682  eb010184          ADD      r1,r1,r4,LSL #2
001686  5a59              LDRH     r1,[r3,r1]
;;;1885   
;;;1886         ret = ecx_FPWRw(context->port, configadr, ECT_REG_ALCTL,
001688  9500              STR      r5,[sp,#0]
00168a  f8333024          LDRH     r3,[r3,r4,LSL #2]
00168e  f7fffffe          BL       ecx_FPWRw
                  |L1.5778|
;;;1887   	        htoes(context->slavelist[slave].state), EC_TIMEOUTRET3);
;;;1888      }
;;;1889      return ret;
;;;1890   }
001692  bd3e              POP      {r1-r5,pc}
                  |L1.5780|
                          DCD      socket_mode
                  |L1.5784|
                          DCD      ||area_number.17||
                  |L1.5788|
                          DCD      ||area_number.14||
                  |L1.5792|
0016a0  8819              LDRH     r1,[r3,#0]            ;1878
0016a2  f8ad1008          STRH     r1,[sp,#8]            ;1878
0016a6  a902              ADD      r1,sp,#8              ;1879
0016a8  e9cd1500          STRD     r1,r5,[sp,#0]         ;1879
0016ac  2302              MOVS     r3,#2                 ;1879
0016ae  2100              MOVS     r1,#0                 ;1879
0016b0  f7fffffe          BL       ecx_BWR
0016b4  e7ed              B        |L1.5778|
;;;1891   /** Transmit processdata to slaves.
                          ENDP

                  ec_writestate PROC
;;;1860    */
;;;1861   int ec_writestate(uint16 slave)
0016b6  4601              MOV      r1,r0
;;;1862   {
;;;1863      return ecx_writestate(&ecx_context, slave);
0016b8  48e4              LDR      r0,|L1.6732|
0016ba  e7fe              B        ecx_writestate
;;;1864   }
;;;1865   /** Write slave state, if slave = 0 then write to all slaves.
                          ENDP

                  ecx_send_processdata_group PROC
;;;1902   */
;;;1903   int ecx_send_processdata_group(ecx_contextt *context, uint8 group)
0016bc  e92d4ff0          PUSH     {r4-r11,lr}
;;;1904   {
0016c0  b08d              SUB      sp,sp,#0x34
;;;1905     uint32 LogAdr;
;;;1906      uint16 w1, w2;
;;;1907      int length, sublength;
;;;1908      uint8 idx;
;;;1909      int wkc;
;;;1910      uint8* data;
;;;1911      boolean first=FALSE;
0016c2  2700              MOVS     r7,#0
;;;1912      uint16 currentsegment = 0;
;;;1913   
;;;1914      wkc = 0;
;;;1915      if(context->grouplist[group].hasdc)
0016c4  eb010281          ADD      r2,r1,r1,LSL #2
0016c8  4604              MOV      r4,r0                 ;1904
0016ca  9709              STR      r7,[sp,#0x24]
0016cc  eb021541          ADD      r5,r2,r1,LSL #5
0016d0  6900              LDR      r0,[r0,#0x10]
0016d2  2214              MOVS     r2,#0x14
0016d4  eb0202c5          ADD      r2,r2,r5,LSL #3
0016d8  46b9              MOV      r9,r7                 ;1912
0016da  5c82              LDRB     r2,[r0,r2]
0016dc  b102              CBZ      r2,|L1.5856|
;;;1916      {
;;;1917         first = TRUE;
0016de  2701              MOVS     r7,#1
                  |L1.5856|
;;;1918      }
;;;1919      length = context->grouplist[group].Obytes + context->grouplist[group].Ibytes;
0016e0  2204              MOVS     r2,#4
0016e2  eb0202c5          ADD      r2,r2,r5,LSL #3
0016e6  9208              STR      r2,[sp,#0x20]
0016e8  5886              LDR      r6,[r0,r2]
0016ea  220c              MOVS     r2,#0xc
0016ec  eb0203c5          ADD      r3,r2,r5,LSL #3
;;;1920      LogAdr = context->grouplist[group].logstartaddr;
0016f0  f8508035          LDR      r8,[r0,r5,LSL #3]
0016f4  58c2              LDR      r2,[r0,r3]            ;1919
0016f6  4432              ADD      r2,r2,r6              ;1919
0016f8  ea5f0b02          MOVS     r11,r2                ;1919
;;;1921      if (length)
0016fc  d07e              BEQ      |L1.6140|
;;;1922      {
;;;1923         if(!group)
0016fe  b921              CBNZ     r1,|L1.5898|
;;;1924         {
;;;1925            context->idxstack->pushed = 0;
001700  6aa2              LDR      r2,[r4,#0x28]
001702  2000              MOVS     r0,#0
001704  7010              STRB     r0,[r2,#0]
;;;1926            context->idxstack->pulled = 0;
001706  6aa2              LDR      r2,[r4,#0x28]
001708  7050              STRB     r0,[r2,#1]
                  |L1.5898|
;;;1927         }
;;;1928         wkc = 1;
00170a  2001              MOVS     r0,#1
;;;1929         /* LRW blocked by one or more slaves ? */
;;;1930         if (context->grouplist[group].blockLRW)
00170c  9009              STR      r0,[sp,#0x24]
00170e  221a              MOVS     r2,#0x1a
001710  6920              LDR      r0,[r4,#0x10]
001712  eb0202c5          ADD      r2,r2,r5,LSL #3
001716  eb010c81          ADD      r12,r1,r1,LSL #2      ;1915
00171a  5c86              LDRB     r6,[r0,r2]
00171c  eb0c1141          ADD      r1,r12,r1,LSL #5      ;1915
;;;1931         {
;;;1932            /* if inputs available generate LRD */
;;;1933            if(context->grouplist[group].Ibytes)
;;;1934            {
;;;1935               currentsegment = context->grouplist[group].Isegment;
;;;1936               data = context->grouplist[group].inputs;
;;;1937               length = context->grouplist[group].Ibytes;
;;;1938               LogAdr += context->grouplist[group].Obytes;
;;;1939               /* segment transfer if needed */
;;;1940               do
;;;1941               {
;;;1942                  if(currentsegment == context->grouplist[group].Isegment)
;;;1943                  {
;;;1944                     sublength = context->grouplist[group].IOsegment[currentsegment++] - context->grouplist[group].Ioffset;
;;;1945                  }
;;;1946                  else
;;;1947                  {
;;;1948                     sublength = context->grouplist[group].IOsegment[currentsegment++];
;;;1949                  }
;;;1950                  /* get new index */
;;;1951                  idx = ecx_getindex(context->port);
;;;1952                  w1 = LO_WORD(LogAdr);
;;;1953                  w2 = HI_WORD(LogAdr);
;;;1954                  ecx_setupdatagram(context->port, &(context->port->txbuf[idx]), EC_CMD_LRD, idx, w1, w2, sublength, data);
;;;1955                  if(first)
;;;1956                  {
;;;1957                     context->DCl = sublength;
;;;1958                     /* FPRMW in second datagram */
;;;1959                     context->DCtO = ecx_adddatagram(context->port, &(context->port->txbuf[idx]), EC_CMD_FRMW, idx, FALSE,
001720  f04f0c08          MOV      r12,#8
;;;1960                                              context->slavelist[context->grouplist[group].DCnext].configadr,
;;;1961                                              ECT_REG_DCSYSTIME, sizeof(int64), context->DCtime);
;;;1962                     first = FALSE;
;;;1963                  }
;;;1964                  /* send frame */
;;;1965                  ecx_outframe_red(context->port, idx);
;;;1966                  /* push index and data pointer on stack */
;;;1967                  ecx_pushindex(context, idx, data, sublength);
;;;1968                  length -= sublength;
;;;1969                  LogAdr += sublength;
;;;1970                  data += sublength;
;;;1971               } while (length && (currentsegment < context->grouplist[group].nsegments));
;;;1972            }
;;;1973            /* if outputs available generate LWR */
;;;1974            if(context->grouplist[group].Obytes)
;;;1975            {
;;;1976               data = context->grouplist[group].outputs;
001724  eb0c0cc1          ADD      r12,r12,r1,LSL #3
001728  f8cdc028          STR      r12,[sp,#0x28]        ;1959
00172c  f04f0c16          MOV      r12,#0x16             ;1959
001730  2210              MOVS     r2,#0x10              ;1936
001732  eb0c0cc1          ADD      r12,r12,r1,LSL #3     ;1959
001736  f8cdc01c          STR      r12,[sp,#0x1c]        ;1971
00173a  eb0202c1          ADD      r2,r2,r1,LSL #3       ;1936
00173e  f04f0c1c          MOV      r12,#0x1c             ;1971
001742  eb0c01c1          ADD      r1,r12,r1,LSL #3      ;1971
001746  9106              STR      r1,[sp,#0x18]         ;1930
001748  2e00              CMP      r6,#0                 ;1930
00174a  d07d              BEQ      |L1.6216|
00174c  58c3              LDR      r3,[r0,r3]            ;1933
00174e  2b00              CMP      r3,#0                 ;1933
001750  d07b              BEQ      |L1.6218|
001752  211e              MOVS     r1,#0x1e              ;1935
001754  eb0101c5          ADD      r1,r1,r5,LSL #3       ;1935
001758  910c              STR      r1,[sp,#0x30]         ;1935
00175a  5a46              LDRH     r6,[r0,r1]            ;1935
00175c  9908              LDR      r1,[sp,#0x20]         ;1938
00175e  f850b002          LDR      r11,[r0,r2]           ;1936
001762  469a              MOV      r10,r3                ;1937
001764  5841              LDR      r1,[r0,r1]            ;1938
001766  eb010908          ADD      r9,r1,r8              ;1938
                  |L1.5994|
00176a  6920              LDR      r0,[r4,#0x10]         ;1942
00176c  990c              LDR      r1,[sp,#0x30]         ;1942
00176e  5a41              LDRH     r1,[r0,r1]            ;1942
001770  42b1              CMP      r1,r6                 ;1942
001772  d10b              BNE      |L1.6028|
001774  2128              MOVS     r1,#0x28              ;1944
001776  eb0002c5          ADD      r2,r0,r5,LSL #3       ;1944
00177a  eb010186          ADD      r1,r1,r6,LSL #2       ;1944
00177e  5851              LDR      r1,[r2,r1]            ;1944
001780  2220              MOVS     r2,#0x20              ;1944
001782  eb0202c5          ADD      r2,r2,r5,LSL #3       ;1944
001786  5a80              LDRH     r0,[r0,r2]            ;1944
001788  1a08              SUBS     r0,r1,r0              ;1944
00178a  e005              B        |L1.6040|
                  |L1.6028|
00178c  eb0001c5          ADD      r1,r0,r5,LSL #3       ;1948
001790  2028              MOVS     r0,#0x28              ;1948
001792  eb000086          ADD      r0,r0,r6,LSL #2       ;1948
001796  5808              LDR      r0,[r1,r0]            ;1948
                  |L1.6040|
001798  1c76              ADDS     r6,r6,#1              ;1948
00179a  4680              MOV      r8,r0                 ;1948
00179c  b2b6              UXTH     r6,r6                 ;1948
00179e  6820              LDR      r0,[r4,#0]            ;1951
0017a0  f7fffffe          BL       ecx_getindex
0017a4  b2c1              UXTB     r1,r0                 ;1951
0017a6  9105              STR      r1,[sp,#0x14]         ;1952
0017a8  fa1ff088          UXTH     r0,r8                 ;1954
0017ac  e9cdb003          STRD     r11,r0,[sp,#0xc]      ;1954
0017b0  fa1ff189          UXTH     r1,r9                 ;1952
0017b4  ea4f4219          LSR      r2,r9,#16             ;1953
0017b8  9100              STR      r1,[sp,#0]            ;1954
0017ba  e9cd2001          STRD     r2,r0,[sp,#4]         ;1954
0017be  6820              LDR      r0,[r4,#0]            ;1954
0017c0  9905              LDR      r1,[sp,#0x14]         ;1954
0017c2  f24022f7          MOV      r2,#0x2f7             ;1954
0017c6  fb11f202          SMULBB   r2,r1,r2              ;1954
0017ca  f246516c          MOV      r1,#0x656c            ;1954
0017ce  eb010142          ADD      r1,r1,r2,LSL #1       ;1954
0017d2  910b              STR      r1,[sp,#0x2c]         ;1954
0017d4  4401              ADD      r1,r1,r0              ;1954
0017d6  220a              MOVS     r2,#0xa               ;1954
0017d8  9b05              LDR      r3,[sp,#0x14]         ;1954
0017da  f7fffffe          BL       ecx_setupdatagram
0017de  b317              CBZ      r7,|L1.6182|
0017e0  9804              LDR      r0,[sp,#0x10]         ;1957
0017e2  8660              STRH     r0,[r4,#0x32]         ;1957
0017e4  6927              LDR      r7,[r4,#0x10]         ;1959
0017e6  9807              LDR      r0,[sp,#0x1c]         ;1959
0017e8  2208              MOVS     r2,#8                 ;1959
0017ea  5a38              LDRH     r0,[r7,r0]            ;1959
0017ec  f44f6311          MOV      r3,#0x910             ;1959
0017f0  eb0007c0          ADD      r7,r0,r0,LSL #3       ;1959
0017f4  6b61              LDR      r1,[r4,#0x34]         ;1959
0017f6  eb071780          ADD      r7,r7,r0,LSL #6       ;1959
0017fa  e000              B        |L1.6142|
                  |L1.6140|
0017fc  e0a0              B        |L1.6464|
                  |L1.6142|
0017fe  2004              MOVS     r0,#4                 ;1959
001800  eb000087          ADD      r0,r0,r7,LSL #2       ;1959
001804  6867              LDR      r7,[r4,#4]            ;1959
001806  5a38              LDRH     r0,[r7,r0]            ;1959
001808  e9cd0301          STRD     r0,r3,[sp,#4]         ;1959
00180c  2000              MOVS     r0,#0                 ;1959
00180e  9000              STR      r0,[sp,#0]            ;1959
001810  e9cd2103          STRD     r2,r1,[sp,#0xc]       ;1959
001814  6820              LDR      r0,[r4,#0]            ;1959
001816  990b              LDR      r1,[sp,#0x2c]         ;1959
001818  220e              MOVS     r2,#0xe               ;1959
00181a  4401              ADD      r1,r1,r0              ;1959
00181c  9b05              LDR      r3,[sp,#0x14]         ;1959
00181e  f7fffffe          BL       ecx_adddatagram
001822  8620              STRH     r0,[r4,#0x30]         ;1959
001824  2700              MOVS     r7,#0                 ;1962
                  |L1.6182|
001826  6820              LDR      r0,[r4,#0]            ;1965
001828  9905              LDR      r1,[sp,#0x14]         ;1965
00182a  f7fffffe          BL       ecx_outframe_red
00182e  fa1ff388          UXTH     r3,r8                 ;1967
001832  465a              MOV      r2,r11                ;1967
001834  4620              MOV      r0,r4                 ;1967
001836  9905              LDR      r1,[sp,#0x14]         ;1967
001838  f7fffffe          BL       ecx_pushindex
00183c  ebaa0008          SUB      r0,r10,r8             ;1968
001840  ea5f0a00          MOVS     r10,r0                ;1968
001844  44c1              ADD      r9,r9,r8              ;1969
001846  e001              B        |L1.6220|
                  |L1.6216|
001848  e07b              B        |L1.6466|
                  |L1.6218|
00184a  e006              B        |L1.6234|
                  |L1.6220|
00184c  44c3              ADD      r11,r11,r8            ;1970
00184e  d004              BEQ      |L1.6234|
001850  6921              LDR      r1,[r4,#0x10]         ;1971
001852  9806              LDR      r0,[sp,#0x18]         ;1971
001854  5a08              LDRH     r0,[r1,r0]            ;1971
001856  42b0              CMP      r0,r6                 ;1971
001858  d887              BHI      |L1.5994|
                  |L1.6234|
00185a  6920              LDR      r0,[r4,#0x10]         ;1974
00185c  9908              LDR      r1,[sp,#0x20]         ;1974
00185e  5841              LDR      r1,[r0,r1]            ;1974
001860  2900              CMP      r1,#0                 ;1974
001862  d06d              BEQ      |L1.6464|
001864  9a0a              LDR      r2,[sp,#0x28]
;;;1977               length = context->grouplist[group].Obytes;
;;;1978               LogAdr = context->grouplist[group].logstartaddr;
001866  f850a035          LDR      r10,[r0,r5,LSL #3]
00186a  4688              MOV      r8,r1                 ;1977
00186c  f850b002          LDR      r11,[r0,r2]           ;1976
;;;1979               currentsegment = 0;
001870  f04f0900          MOV      r9,#0
                  |L1.6260|
;;;1980               /* segment transfer if needed */
;;;1981               do
;;;1982               {
;;;1983                  sublength = context->grouplist[group].IOsegment[currentsegment++];
001874  6920              LDR      r0,[r4,#0x10]
001876  2128              MOVS     r1,#0x28
001878  eb0002c5          ADD      r2,r0,r5,LSL #3
00187c  eb010089          ADD      r0,r1,r9,LSL #2
001880  5816              LDR      r6,[r2,r0]
001882  f1090001          ADD      r0,r9,#1
001886  fa1ff980          UXTH     r9,r0
;;;1984                  if((length - sublength) < 0)
00188a  ebb80006          SUBS     r0,r8,r6
00188e  d500              BPL      |L1.6290|
;;;1985                  {
;;;1986                     sublength = length;
001890  4646              MOV      r6,r8
                  |L1.6290|
;;;1987                  }
;;;1988                  /* get new index */
;;;1989                  idx = ecx_getindex(context->port);
001892  6820              LDR      r0,[r4,#0]
001894  f7fffffe          BL       ecx_getindex
001898  b2c1              UXTB     r1,r0
;;;1990                  w1 = LO_WORD(LogAdr);
00189a  9105              STR      r1,[sp,#0x14]
;;;1991                  w2 = HI_WORD(LogAdr);
;;;1992                  ecx_setupdatagram(context->port, &(context->port->txbuf[idx]), EC_CMD_LWR, idx, w1, w2, sublength, data);
00189c  b2b0              UXTH     r0,r6
00189e  e9cdb003          STRD     r11,r0,[sp,#0xc]
0018a2  fa1ff18a          UXTH     r1,r10                ;1990
0018a6  ea4f421a          LSR      r2,r10,#16            ;1991
0018aa  9100              STR      r1,[sp,#0]
0018ac  e9cd2001          STRD     r2,r0,[sp,#4]
0018b0  6820              LDR      r0,[r4,#0]
0018b2  9905              LDR      r1,[sp,#0x14]
0018b4  f24022f7          MOV      r2,#0x2f7
0018b8  fb11f202          SMULBB   r2,r1,r2
0018bc  f246516c          MOV      r1,#0x656c
0018c0  eb010142          ADD      r1,r1,r2,LSL #1
0018c4  9108              STR      r1,[sp,#0x20]
0018c6  4401              ADD      r1,r1,r0
0018c8  220b              MOVS     r2,#0xb
0018ca  9b05              LDR      r3,[sp,#0x14]
0018cc  f7fffffe          BL       ecx_setupdatagram
;;;1993                  if(first)
0018d0  b307              CBZ      r7,|L1.6420|
;;;1994                  {
;;;1995                     context->DCl = sublength;
0018d2  9804              LDR      r0,[sp,#0x10]
0018d4  8660              STRH     r0,[r4,#0x32]
;;;1996                     /* FPRMW in second datagram */
;;;1997                     context->DCtO = ecx_adddatagram(context->port, &(context->port->txbuf[idx]), EC_CMD_FRMW, idx, FALSE,
0018d6  6927              LDR      r7,[r4,#0x10]
0018d8  9807              LDR      r0,[sp,#0x1c]
0018da  f44f6311          MOV      r3,#0x910
0018de  5a38              LDRH     r0,[r7,r0]
0018e0  6b61              LDR      r1,[r4,#0x34]
0018e2  eb0007c0          ADD      r7,r0,r0,LSL #3
0018e6  eb071780          ADD      r7,r7,r0,LSL #6
0018ea  2004              MOVS     r0,#4
0018ec  eb000087          ADD      r0,r0,r7,LSL #2
0018f0  6867              LDR      r7,[r4,#4]
0018f2  2208              MOVS     r2,#8
0018f4  5a38              LDRH     r0,[r7,r0]
0018f6  e9cd0301          STRD     r0,r3,[sp,#4]
0018fa  2000              MOVS     r0,#0
0018fc  9000              STR      r0,[sp,#0]
0018fe  e9cd2103          STRD     r2,r1,[sp,#0xc]
001902  6820              LDR      r0,[r4,#0]
001904  9908              LDR      r1,[sp,#0x20]
001906  220e              MOVS     r2,#0xe
001908  4401              ADD      r1,r1,r0
00190a  9b05              LDR      r3,[sp,#0x14]
00190c  f7fffffe          BL       ecx_adddatagram
001910  8620              STRH     r0,[r4,#0x30]
;;;1998                                              context->slavelist[context->grouplist[group].DCnext].configadr,
;;;1999                                              ECT_REG_DCSYSTIME, sizeof(int64), context->DCtime);
;;;2000                     first = FALSE;
001912  2700              MOVS     r7,#0
                  |L1.6420|
;;;2001                  }
;;;2002                  /* send frame */
;;;2003                  ecx_outframe_red(context->port, idx);
001914  6820              LDR      r0,[r4,#0]
001916  9905              LDR      r1,[sp,#0x14]
001918  f7fffffe          BL       ecx_outframe_red
;;;2004                  /* push index and data pointer on stack */
;;;2005                  ecx_pushindex(context, idx, data, sublength);
00191c  b2b3              UXTH     r3,r6
00191e  465a              MOV      r2,r11
001920  4620              MOV      r0,r4
001922  9905              LDR      r1,[sp,#0x14]
001924  f7fffffe          BL       ecx_pushindex
;;;2006                  length -= sublength;
001928  eba80006          SUB      r0,r8,r6
00192c  ea5f0800          MOVS     r8,r0
;;;2007                  LogAdr += sublength;
001930  44b2              ADD      r10,r10,r6
;;;2008                  data += sublength;
001932  44b3              ADD      r11,r11,r6
;;;2009               } while (length && (currentsegment < context->grouplist[group].nsegments));
001934  d06f              BEQ      |L1.6678|
001936  6921              LDR      r1,[r4,#0x10]
001938  9806              LDR      r0,[sp,#0x18]
00193a  5a09              LDRH     r1,[r1,r0]
00193c  4549              CMP      r1,r9
00193e  d899              BHI      |L1.6260|
                  |L1.6464|
001940  e069              B        |L1.6678|
                  |L1.6466|
;;;2010            }
;;;2011         }
;;;2012         /* LRW can be used */
;;;2013         else
;;;2014         {
;;;2015            if (context->grouplist[group].Obytes)
001942  9908              LDR      r1,[sp,#0x20]
001944  5841              LDR      r1,[r0,r1]
001946  b111              CBZ      r1,|L1.6478|
;;;2016            {
;;;2017               data = context->grouplist[group].outputs;
001948  990a              LDR      r1,[sp,#0x28]
00194a  5840              LDR      r0,[r0,r1]
00194c  e000              B        |L1.6480|
                  |L1.6478|
;;;2018            }
;;;2019            else
;;;2020            {
;;;2021               data = context->grouplist[group].inputs;
00194e  5880              LDR      r0,[r0,r2]
                  |L1.6480|
001950  4682              MOV      r10,r0                ;2017
                  |L1.6482|
;;;2022            }
;;;2023            /* segment transfer if needed */
;;;2024            do
;;;2025            {
;;;2026               sublength = context->grouplist[group].IOsegment[currentsegment++];
001952  6920              LDR      r0,[r4,#0x10]
001954  eb0002c5          ADD      r2,r0,r5,LSL #3
001958  2028              MOVS     r0,#0x28
00195a  eb000089          ADD      r0,r0,r9,LSL #2
00195e  5816              LDR      r6,[r2,r0]
001960  f1090001          ADD      r0,r9,#1
001964  fa1ff980          UXTH     r9,r0
;;;2027               /* get new index */
;;;2028               idx = ecx_getindex(context->port);
001968  6820              LDR      r0,[r4,#0]
00196a  f7fffffe          BL       ecx_getindex
00196e  b2c1              UXTB     r1,r0
;;;2029               w1 = LO_WORD(LogAdr);
;;;2030               w2 = HI_WORD(LogAdr);
001970  9105              STR      r1,[sp,#0x14]
;;;2031               ecx_setupdatagram(context->port, &(context->port->txbuf[idx]), EC_CMD_LRW, idx, w1, w2, sublength, data);
001972  b2b0              UXTH     r0,r6
001974  e9cda003          STRD     r10,r0,[sp,#0xc]
001978  fa1ff288          UXTH     r2,r8                 ;2029
00197c  ea4f4118          LSR      r1,r8,#16             ;2030
001980  9200              STR      r2,[sp,#0]
001982  e9cd1001          STRD     r1,r0,[sp,#4]
001986  6820              LDR      r0,[r4,#0]
001988  9905              LDR      r1,[sp,#0x14]
00198a  f24022f7          MOV      r2,#0x2f7
00198e  fb11f202          SMULBB   r2,r1,r2
001992  f246516c          MOV      r1,#0x656c
001996  eb010142          ADD      r1,r1,r2,LSL #1
00199a  9108              STR      r1,[sp,#0x20]
00199c  4401              ADD      r1,r1,r0
00199e  220c              MOVS     r2,#0xc
0019a0  9b05              LDR      r3,[sp,#0x14]
0019a2  f7fffffe          BL       ecx_setupdatagram
;;;2032               if(first)
0019a6  b307              CBZ      r7,|L1.6634|
;;;2033               {
;;;2034                  context->DCl = sublength;
0019a8  9804              LDR      r0,[sp,#0x10]
0019aa  8660              STRH     r0,[r4,#0x32]
;;;2035                  /* FPRMW in second datagram */
;;;2036                  context->DCtO = ecx_adddatagram(context->port, &(context->port->txbuf[idx]), EC_CMD_FRMW, idx, FALSE,
0019ac  6927              LDR      r7,[r4,#0x10]
0019ae  9807              LDR      r0,[sp,#0x1c]
0019b0  f44f6311          MOV      r3,#0x910
0019b4  5a38              LDRH     r0,[r7,r0]
0019b6  6b61              LDR      r1,[r4,#0x34]
0019b8  eb0007c0          ADD      r7,r0,r0,LSL #3
0019bc  eb071780          ADD      r7,r7,r0,LSL #6
0019c0  2004              MOVS     r0,#4
0019c2  eb000087          ADD      r0,r0,r7,LSL #2
0019c6  6867              LDR      r7,[r4,#4]
0019c8  2208              MOVS     r2,#8
0019ca  5a38              LDRH     r0,[r7,r0]
0019cc  e9cd0301          STRD     r0,r3,[sp,#4]
0019d0  2000              MOVS     r0,#0
0019d2  9000              STR      r0,[sp,#0]
0019d4  e9cd2103          STRD     r2,r1,[sp,#0xc]
0019d8  6820              LDR      r0,[r4,#0]
0019da  9908              LDR      r1,[sp,#0x20]
0019dc  220e              MOVS     r2,#0xe
0019de  4401              ADD      r1,r1,r0
0019e0  9b05              LDR      r3,[sp,#0x14]
0019e2  f7fffffe          BL       ecx_adddatagram
0019e6  8620              STRH     r0,[r4,#0x30]
;;;2037                                           context->slavelist[context->grouplist[group].DCnext].configadr,
;;;2038                                           ECT_REG_DCSYSTIME, sizeof(int64), context->DCtime);
;;;2039                  first = FALSE;
0019e8  2700              MOVS     r7,#0
                  |L1.6634|
;;;2040               }
;;;2041               /* send frame */
;;;2042               ecx_outframe_red(context->port, idx);
0019ea  6820              LDR      r0,[r4,#0]
0019ec  9905              LDR      r1,[sp,#0x14]
0019ee  f7fffffe          BL       ecx_outframe_red
;;;2043               /* push index and data pointer on stack */
;;;2044               ecx_pushindex(context, idx, data, sublength);
0019f2  b2b3              UXTH     r3,r6
0019f4  4652              MOV      r2,r10
0019f6  4620              MOV      r0,r4
0019f8  9905              LDR      r1,[sp,#0x14]
0019fa  f7fffffe          BL       ecx_pushindex
;;;2045               length -= sublength;
0019fe  ebab0006          SUB      r0,r11,r6
001a02  ea5f0b00          MOVS     r11,r0
;;;2046               LogAdr += sublength;
001a06  44b0              ADD      r8,r8,r6
;;;2047               data += sublength;
001a08  44b2              ADD      r10,r10,r6
;;;2048            } while (length && (currentsegment < context->grouplist[group].nsegments));
001a0a  d004              BEQ      |L1.6678|
001a0c  6921              LDR      r1,[r4,#0x10]
001a0e  9806              LDR      r0,[sp,#0x18]
001a10  5a09              LDRH     r1,[r1,r0]
001a12  4549              CMP      r1,r9
001a14  d89d              BHI      |L1.6482|
                  |L1.6678|
;;;2049         }
;;;2050      }
;;;2051   
;;;2052      return wkc;
001a16  9809              LDR      r0,[sp,#0x24]
;;;2053   }
001a18  b00d              ADD      sp,sp,#0x34
001a1a  e4dd              B        |L1.5080|
;;;2054   
                          ENDP

                  ec_send_processdata_group PROC
;;;2067    */
;;;2068   int ec_send_processdata_group(uint8 group)
001a1c  4601              MOV      r1,r0
;;;2069   {
;;;2070      return ecx_send_processdata_group (&ecx_context, group);
001a1e  480b              LDR      r0,|L1.6732|
001a20  e7fe              B        ecx_send_processdata_group
;;;2071   }
;;;2072   /** Receive processdata from slaves.
                          ENDP

                  ec_receive_processdata_group PROC
;;;2080    */
;;;2081   int ec_receive_processdata_group(uint8 group, int timeout)
001a22  460a              MOV      r2,r1
;;;2082   {
;;;2083      return ecx_receive_processdata_group (&ecx_context, group, timeout);
001a24  4601              MOV      r1,r0
001a26  4809              LDR      r0,|L1.6732|
001a28  e7fe              B        ecx_receive_processdata_group
;;;2084   }
;;;2085   
                          ENDP

                  ec_send_processdata PROC
;;;2086   int ec_send_processdata(void)
001a2a  2000              MOVS     r0,#0
;;;2087   {
;;;2088      return ec_send_processdata_group(0);
001a2c  e7fe              B        ec_send_processdata_group
;;;2089   }
;;;2090   
                          ENDP

                  ec_receive_processdata PROC
;;;2091   
;;;2092   int ec_receive_processdata(int timeout)
001a2e  4601              MOV      r1,r0
;;;2093   {
;;;2094      return ec_receive_processdata_group(0, timeout);
001a30  2000              MOVS     r0,#0
001a32  e7fe              B        ec_receive_processdata_group
;;;2095   }
;;;2096   #endif
                          ENDP

                  ecx_pullindex PROC
;;;1289    */
;;;1290   static int ecx_pullindex(ecx_contextt *context)
001a34  4601              MOV      r1,r0
;;;1291   {
;;;1292      int rval = -1;
001a36  f04f30ff          MOV      r0,#0xffffffff
;;;1293      if(context->idxstack->pulled < context->idxstack->pushed)
001a3a  6a8a              LDR      r2,[r1,#0x28]
001a3c  7851              LDRB     r1,[r2,#1]
001a3e  7813              LDRB     r3,[r2,#0]
001a40  4299              CMP      r1,r3
001a42  d202              BCS      |L1.6730|
;;;1294      {
;;;1295         rval = context->idxstack->pulled;
001a44  4608              MOV      r0,r1
001a46  1c49              ADDS     r1,r1,#1
;;;1296         context->idxstack->pulled++;
001a48  7051              STRB     r1,[r2,#1]
                  |L1.6730|
;;;1297      }
;;;1298   
;;;1299      return rval;
;;;1300   }
001a4a  4770              BX       lr
;;;1301   
                          ENDP

                  |L1.6732|
                          DCD      ||area_number.17||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ec_slave
                          %        5840

                          AREA ||area_number.4||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.4||, ||.bss||
                  ec_group
                          %        592

                          AREA ||area_number.5||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.5||, ||.bss||
                  ec_esibuf
                          %        4096

                          AREA ||area_number.6||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.bss||
                  ec_esimap
                          %        512

                          AREA ||area_number.7||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.bss||
                  ec_elist
                          %        1044

                          AREA ||area_number.8||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.bss||
                  ec_idxstack
                          %        116

                          AREA ||area_number.9||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.9||, ||.bss||
                  ec_SMcommtype
                          %        10

                          AREA ||area_number.10||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.10||, ||.bss||
                  ec_PDOassign
                          %        514

                          AREA ||area_number.11||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.bss||
                  ec_PDOdesc
                          %        1028

                          AREA ||area_number.12||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.12||, ||.bss||
                  ec_SM
                          %        12

                          AREA ||area_number.13||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.bss||
                  ecx_port
                          %        51852

                          AREA ||area_number.14||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.bss||
                  ecx_redport
                          %        25960

                          AREA ||.data||, DATA, ALIGN=0

                  EcatError
000000  00                DCB      0x00

                          AREA ||area_number.17||, DATA, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.data||
                  ecx_context
                          DCD      ecx_port
                          DCD      ec_slave
                          DCD      ec_slavecount
                          DCD      0x00000014
                          DCD      ec_group
                          DCD      0x00000002
                          DCD      ec_esibuf
                          DCD      ec_esimap
000020  0000              DCW      0x0000
000022  0000              DCB      0x00,0x00
                          DCD      ec_elist
                          DCD      ec_idxstack
                          DCD      EcatError
000030  00000000          DCW      0x0000,0x0000
                          DCD      ec_DCtime
                          DCD      ec_SMcommtype
                          DCD      ec_PDOassign
                          DCD      ec_PDOdesc
                          DCD      ec_SM
                          DCD      ec_FMMU
                          DCD      0x00000000

                          AREA ||area_number.18||, DATA, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.data||
                  ec_slavecount
                          DCD      0x00000000

                          AREA ||area_number.19||, DATA, ALIGN=1

                          EXPORTAS ||area_number.19||, ||.data||
                  ec_FMMU
                          %        8

                          AREA ||area_number.20||, DATA, ALIGN=3

                          EXPORTAS ||area_number.20||, ||.data||
                  ec_DCtime
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\ETHERCAT\\ethercatmain.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_ethercatmain_c_cb249950____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___14_ethercatmain_c_cb249950____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_ethercatmain_c_cb249950____REVSH|
#line 144
|__asm___14_ethercatmain_c_cb249950____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
