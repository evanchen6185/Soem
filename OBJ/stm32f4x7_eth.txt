; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\stm32f4x7_eth.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f4x7_eth.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\FWLIB\STM32F4xx_StdPeriph_Driver\inc -I..\USER -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\ETHERNET -I..\HARDWARE\TIMER -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\RTC -I..\HARDWARE\ADC -I..\HARDWARE\SRAM -I..\HARDWARE\InterTemperate -I..\FWLIB\STM32F4x7_ETH_Driver\inc -I..\MALLOC -I..\USMART -I..\HARDWARE -I..\ETHERCAT -I.\RTE\_LWIP -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS --omf_browse=..\obj\stm32f4x7_eth.crf ..\FWLIB\STM32F4x7_ETH_Driver\src\stm32f4x7_eth.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ETH_DeInit PROC
;;;149      */
;;;150    void ETH_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;151    {
;;;152      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, ENABLE);
000002  2101              MOVS     r1,#1
000004  064c              LSLS     r4,r1,#25
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_AHB1PeriphResetCmd
;;;153      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_AHB1PeriphResetCmd
;;;154    }
;;;155    
                          ENDP

                  ETH_StructInit PROC
;;;161      */
;;;162    void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
000018  2101              MOVS     r1,#1
;;;163    {
;;;164      /* ETH_InitStruct members default value */
;;;165      /*------------------------   MAC Configuration   ---------------------------*/
;;;166      
;;;167      /* PHY Auto-negotiation enabled */
;;;168      ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable; 			//使能自适应模式       
;;;169      /* MAC watchdog enabled: cuts-off long frame */
;;;170      ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;										 	//使能看门狗
00001a  6001              STR      r1,[r0,#0]
00001c  2100              MOVS     r1,#0
;;;171      /* MAC Jabber enabled in Half-duplex mode */					
;;;172      ETH_InitStruct->ETH_Jabber = ETH_Jabber_Enable;       									//使能Jabber                                                
00001e  6041              STR      r1,[r0,#4]
;;;173      /* Ethernet interframe gap set to 96 bits */
;;;174      ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;  					//设置帧间隔为96bit                                                                                                                          
000020  6081              STR      r1,[r0,#8]
;;;175      /* Carrier Sense Enabled in Half-Duplex mode */ 
;;;176      ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable; 						//半双工模式下使能载波侦听功能                               
;;;177      /* PHY speed configured to 100Mbit/s */
;;;178      ETH_InitStruct->ETH_Speed = ETH_Speed_100M; 														//PHY层速度为100M
000022  f44f4280          MOV      r2,#0x4000
000026  60c1              STR      r1,[r0,#0xc]
000028  e9c01204          STRD     r1,r2,[r0,#0x10]
;;;179      /* Receive own Frames in Half-Duplex mode enabled */
;;;180      ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;                	//半双工模式下允许接收 own frame
;;;181      /* MAC MII loopback disabled */ 
;;;182      ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable; 						//关闭MII接口的反馈功能             
;;;183      /* Full-Duplex mode selected */
;;;184      ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;   											//使用全双工模式                   
00002c  10d2              ASRS     r2,r2,#3
00002e  6181              STR      r1,[r0,#0x18]
000030  e9c01207          STRD     r1,r2,[r0,#0x1c]
;;;185      /* IPv4 and TCP/UDP/ICMP frame Checksum Offload disabled */
;;;186      ETH_InitStruct->ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;   		//关闭ipv4和TCP/UDP/ICMP的帧校验和卸载                                                          
;;;187      /* Retry Transmission enabled for half-duplex mode */ 
;;;188      ETH_InitStruct->ETH_RetryTransmission = ETH_RetryTransmission_Enable;   //开启半双工模式下的重试传输功能                                                                              
000034  6241              STR      r1,[r0,#0x24]
;;;189      /* Automatic PAD/CRC strip disabled*/
;;;190      ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;  //关闭自动去除PDA/CRC功能                                                        
000036  6281              STR      r1,[r0,#0x28]
;;;191      /* half-duplex mode retransmission Backoff time_limit = 10 slot times*/ 
;;;192      ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;     						//设置半双工模式下的最大重传回退事件10 slot times
000038  62c1              STR      r1,[r0,#0x2c]
;;;193      /* half-duplex mode Deferral check disabled */
;;;194      ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;          //关闭半双工模式下的延时检查功能                                                                                                      
00003a  6301              STR      r1,[r0,#0x30]
;;;195      /* Receive all frames disabled */ 
;;;196      ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;								//禁止接收所有帧
00003c  6341              STR      r1,[r0,#0x34]
;;;197      /* Source address filtering (on the optional MAC addresses) disabled */
;;;198      ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;   	//关闭MAC地址的源地址过滤功能
;;;199      /* Do not forward control frames that do not pass the address filtering */
;;;200      ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll; //
00003e  2240              MOVS     r2,#0x40
000040  6381              STR      r1,[r0,#0x38]
000042  e9c0120f          STRD     r1,r2,[r0,#0x3c]
;;;201      /* Disable reception of Broadcast frames */
;;;202      ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;//禁止接收所有的广播帧
000046  2220              MOVS     r2,#0x20
000048  e9c02111          STRD     r2,r1,[r0,#0x44]
;;;203      /* Normal Destination address filtering (not reverse addressing) */
;;;204      ETH_InitStruct->ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal;			//正常的远端地址过滤
;;;205      /* Promiscuous address filtering mode disabled */
;;;206      ETH_InitStruct->ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;			//关闭混合模式的地址过滤                                                            
;;;207      /* Perfect address filtering for multicast addresses */
;;;208      ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;  //对于组播地址使用完美地址过滤   
00004c  64c1              STR      r1,[r0,#0x4c]
;;;209      /* Perfect address filtering for unicast addresses */
;;;210      ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;     	//对单播地址使用完美地址过滤 
00004e  6501              STR      r1,[r0,#0x50]
;;;211      /* Initialize hash table high and low regs */
;;;212      ETH_InitStruct->ETH_HashTableHigh = 0x0;   											//初始化HASH表的高位寄存器             
000050  6541              STR      r1,[r0,#0x54]
;;;213      ETH_InitStruct->ETH_HashTableLow = 0x0;                     		//初始化HASH表的低位位寄存器  
000052  6581              STR      r1,[r0,#0x58]
;;;214      /* Flow control config (flow control disabled)*/
;;;215      ETH_InitStruct->ETH_PauseTime = 0x0;                 					//流控配置 
;;;216      ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
000054  2280              MOVS     r2,#0x80
000056  65c1              STR      r1,[r0,#0x5c]
000058  e9c01218          STRD     r1,r2,[r0,#0x60]
;;;217      ETH_InitStruct->ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4;         
;;;218      ETH_InitStruct->ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;   
00005c  6681              STR      r1,[r0,#0x68]
;;;219      ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
00005e  66c1              STR      r1,[r0,#0x6c]
;;;220      ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;
000060  6701              STR      r1,[r0,#0x70]
;;;221      /* VLANtag config (VLAN field not checked) */
;;;222      ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
000062  6741              STR      r1,[r0,#0x74]
;;;223      ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
;;;224      
;;;225      /*---------------------- DMA Configuration   -------------------------------*/
;;;226    
;;;227      /* Drops frames with with TCP/IP checksum errors */
;;;228      ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; //关闭丢弃TCP/IP错误帧
000064  04d2              LSLS     r2,r2,#19
000066  6781              STR      r1,[r0,#0x78]
000068  e9c0121f          STRD     r1,r2,[r0,#0x7c]
;;;229      /* Store and forward mode enabled for receive */
;;;230      ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       //开启接收数据的存储转发功能
00006c  1052              ASRS     r2,r2,#1
;;;231      /* Flush received frame that created FIFO overflow */
;;;232      ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable; 
;;;233      /* Store and forward mode enabled for transmit */
;;;234      ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;   	//开启发送模式的存储转发功能
00006e  e9c02121          STRD     r2,r1,[r0,#0x84]
000072  1113              ASRS     r3,r2,#4
000074  e9c03123          STRD     r3,r1,[r0,#0x8c]
;;;235      /* Threshold TXFIFO level set to 64 bytes (used when threshold mode is enabled) */
;;;236      ETH_InitStruct->ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;  //设置阈值模式下的发送FIFO的阈值为64字节
;;;237      /* Disable forwarding frames with errors (short frames, CRC,...)*/
;;;238      ETH_InitStruct->ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;   //禁止转发错误帧
;;;239      /* Disable undersized good frames */
;;;240      ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; //不转发过小的好帧
000078  f8c01094          STR      r1,[r0,#0x94]
;;;241      /* Threshold RXFIFO level set to 64 bytes (used when Cut-through mode is enabled) */
;;;242      ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;    //设置直通模式下的发送FIFO阈值为64字节                        
00007c  f8c01098          STR      r1,[r0,#0x98]
000080  f8c0109c          STR      r1,[r0,#0x9c]
000084  e9c01228          STRD     r1,r2,[r0,#0xa0]
;;;243      /* Disable Operate on second frame (transmit a second frame to FIFO without 
;;;244      waiting status of previous frame*/                           
;;;245      ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;							//关闭处理第二帧数据
;;;246      /* DMA works on 32-bit aligned start source and destinations addresses */
;;;247      ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;						//开启DMA传输的地址对齐功能
;;;248      /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
;;;249      ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;    												//开启固定突发功能
000088  1252              ASRS     r2,r2,#9
;;;250      /* DMA transfer max burst length = 32 beats = 32 x 32bits */
;;;251      ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;    //DMA发送的最大突发长度为32
00008a  f8c020a8          STR      r2,[r0,#0xa8]
00008e  0192              LSLS     r2,r2,#6
;;;252      ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;    //DMA接收的最大突发长度为32
000090  f8c020ac          STR      r2,[r0,#0xac]
000094  1252              ASRS     r2,r2,#9
000096  e9c0212c          STRD     r2,r1,[r0,#0xb0]
;;;253      /* DMA Ring mode skip length = 0 */
;;;254      ETH_InitStruct->ETH_DescriptorSkipLength = 0x0; 
;;;255      /* Equal priority (round-robin) between transmit and receive DMA engines */
;;;256      ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
00009a  f8c010b8          STR      r1,[r0,#0xb8]
;;;257    }
00009e  4770              BX       lr
;;;258    
                          ENDP

                  ETH_WritePHYRegister PROC
;;;2226     */
;;;2227   uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
0000a0  b538              PUSH     {r3-r5,lr}
;;;2228   {
;;;2229     uint32_t tmpreg = 0;     
;;;2230     __IO uint32_t timeout = 0;
0000a2  2300              MOVS     r3,#0
;;;2231     /* Check the parameters */
;;;2232     assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
;;;2233     assert_param(IS_ETH_PHY_REG(PHYReg));
;;;2234     
;;;2235     /* Get the ETHERNET MACMIIAR value */
;;;2236     tmpreg = ETH->MACMIIAR;
0000a4  9300              STR      r3,[sp,#0]
0000a6  4bf9              LDR      r3,|L1.1164|
0000a8  691c              LDR      r4,[r3,#0x10]
;;;2237     /* Keep only the CSR Clock Range CR[2:0] bits value */
;;;2238     tmpreg &= ~MACMIIAR_CR_MASK;
;;;2239     /* Prepare the MII register address value */
;;;2240     tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
0000aa  f64f75ff          MOV      r5,#0xffff
0000ae  f004041c          AND      r4,r4,#0x1c           ;2238
0000b2  ea0520c0          AND      r0,r5,r0,LSL #11
0000b6  4320              ORRS     r0,r0,r4
;;;2241     tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
0000b8  f44f64f8          MOV      r4,#0x7c0
0000bc  ea041181          AND      r1,r4,r1,LSL #6
0000c0  4301              ORRS     r1,r1,r0
;;;2242     tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
;;;2243     tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
0000c2  f0410003          ORR      r0,r1,#3
;;;2244     /* Give the value to the MII data register */
;;;2245     ETH->MACMIIDR = PHYValue;
0000c6  615a              STR      r2,[r3,#0x14]
;;;2246     /* Write the result value into the MII Address register */
;;;2247     ETH->MACMIIAR = tmpreg;
0000c8  6118              STR      r0,[r3,#0x10]
;;;2248     /* Check for the Busy flag */
;;;2249     do
;;;2250     {
;;;2251       timeout++;
;;;2252       tmpreg = ETH->MACMIIAR;
;;;2253     } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
0000ca  49f1              LDR      r1,|L1.1168|
                  |L1.204|
0000cc  9800              LDR      r0,[sp,#0]            ;2251
0000ce  1c40              ADDS     r0,r0,#1              ;2251
0000d0  9000              STR      r0,[sp,#0]            ;2252
0000d2  6918              LDR      r0,[r3,#0x10]         ;2252
0000d4  07c0              LSLS     r0,r0,#31
0000d6  d002              BEQ      |L1.222|
0000d8  9800              LDR      r0,[sp,#0]
0000da  4288              CMP      r0,r1
0000dc  d3f6              BCC      |L1.204|
                  |L1.222|
;;;2254     /* Return ERROR in case of timeout */
;;;2255     if(timeout == PHY_WRITE_TO)
0000de  9800              LDR      r0,[sp,#0]
0000e0  4288              CMP      r0,r1
0000e2  d101              BNE      |L1.232|
;;;2256     {
;;;2257       return ETH_ERROR;
0000e4  2000              MOVS     r0,#0
;;;2258     }
;;;2259     
;;;2260     /* Return SUCCESS */
;;;2261     return ETH_SUCCESS;  
;;;2262   }
0000e6  bd38              POP      {r3-r5,pc}
                  |L1.232|
0000e8  2001              MOVS     r0,#1                 ;2261
0000ea  bd38              POP      {r3-r5,pc}
;;;2263   
                          ENDP

                  ETH_ReadPHYRegister PROC
;;;2179     */
;;;2180   uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
0000ec  b518              PUSH     {r3,r4,lr}
;;;2181   {
;;;2182     uint32_t tmpreg = 0;     
;;;2183   __IO uint32_t timeout = 0;
0000ee  2200              MOVS     r2,#0
;;;2184     /* Check the parameters */
;;;2185     assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
;;;2186     assert_param(IS_ETH_PHY_REG(PHYReg));
;;;2187     
;;;2188     /* Get the ETHERNET MACMIIAR value */
;;;2189     tmpreg = ETH->MACMIIAR;
0000f0  9200              STR      r2,[sp,#0]
0000f2  4ae6              LDR      r2,|L1.1164|
0000f4  6913              LDR      r3,[r2,#0x10]
;;;2190     /* Keep only the CSR Clock Range CR[2:0] bits value */
;;;2191     tmpreg &= ~MACMIIAR_CR_MASK;
;;;2192     /* Prepare the MII address register value */
;;;2193     tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
0000f6  f64f74ff          MOV      r4,#0xffff
0000fa  f003031c          AND      r3,r3,#0x1c           ;2191
0000fe  ea0420c0          AND      r0,r4,r0,LSL #11
000102  4318              ORRS     r0,r0,r3
;;;2194     tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
000104  f44f63f8          MOV      r3,#0x7c0
000108  ea031181          AND      r1,r3,r1,LSL #6
00010c  4301              ORRS     r1,r1,r0
;;;2195     tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
00010e  f0210002          BIC      r0,r1,#2
;;;2196     tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
000112  f0400001          ORR      r0,r0,#1
;;;2197     /* Write the result value into the MII Address register */
;;;2198     ETH->MACMIIAR = tmpreg;
000116  6110              STR      r0,[r2,#0x10]
;;;2199     /* Check for the Busy flag */
;;;2200     do
;;;2201     {
;;;2202       timeout++;
;;;2203       tmpreg = ETH->MACMIIAR;
;;;2204     } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
000118  49dd              LDR      r1,|L1.1168|
                  |L1.282|
00011a  9800              LDR      r0,[sp,#0]            ;2202
00011c  1c40              ADDS     r0,r0,#1              ;2202
00011e  9000              STR      r0,[sp,#0]            ;2203
000120  6910              LDR      r0,[r2,#0x10]         ;2203
000122  07c0              LSLS     r0,r0,#31
000124  d002              BEQ      |L1.300|
000126  9800              LDR      r0,[sp,#0]
000128  4288              CMP      r0,r1
00012a  d3f6              BCC      |L1.282|
                  |L1.300|
;;;2205     /* Return ERROR in case of timeout */
;;;2206     if(timeout == PHY_READ_TO)
00012c  9800              LDR      r0,[sp,#0]
00012e  4288              CMP      r0,r1
000130  d101              BNE      |L1.310|
;;;2207     {
;;;2208       return (uint16_t)ETH_ERROR;
000132  2000              MOVS     r0,#0
;;;2209     }
;;;2210     
;;;2211     /* Return data register value */
;;;2212     return (uint16_t)(ETH->MACMIIDR);
;;;2213   }
000134  bd18              POP      {r3,r4,pc}
                  |L1.310|
000136  6950              LDR      r0,[r2,#0x14]         ;2212
000138  b280              UXTH     r0,r0                 ;2212
00013a  bd18              POP      {r3,r4,pc}
;;;2214   
                          ENDP

                  ETH_Init PROC
;;;269    uint32_t sadkasd[10];	
;;;270    uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
00013c  e92d41f0          PUSH     {r4-r8,lr}
;;;271    {
000140  b086              SUB      sp,sp,#0x18
;;;272      uint32_t RegValue = 0, tmpreg = 0;
;;;273      __IO uint32_t i = 0;
000142  2700              MOVS     r7,#0
;;;274      RCC_ClocksTypeDef  rcc_clocks;
;;;275      uint32_t hclk = 60000000;
;;;276      __IO uint32_t timeout = 0;
;;;277      /* Check the parameters */
;;;278      /* MAC --------------------------*/ 
;;;279      assert_param(IS_ETH_AUTONEGOTIATION(ETH_InitStruct->ETH_AutoNegotiation));
;;;280      assert_param(IS_ETH_WATCHDOG(ETH_InitStruct->ETH_Watchdog));
;;;281      assert_param(IS_ETH_JABBER(ETH_InitStruct->ETH_Jabber));
;;;282      assert_param(IS_ETH_INTER_FRAME_GAP(ETH_InitStruct->ETH_InterFrameGap));
;;;283      assert_param(IS_ETH_CARRIER_SENSE(ETH_InitStruct->ETH_CarrierSense));
;;;284      assert_param(IS_ETH_SPEED(ETH_InitStruct->ETH_Speed));
;;;285      assert_param(IS_ETH_RECEIVE_OWN(ETH_InitStruct->ETH_ReceiveOwn));
;;;286      assert_param(IS_ETH_LOOPBACK_MODE(ETH_InitStruct->ETH_LoopbackMode));
;;;287      assert_param(IS_ETH_DUPLEX_MODE(ETH_InitStruct->ETH_Mode));
;;;288      assert_param(IS_ETH_CHECKSUM_OFFLOAD(ETH_InitStruct->ETH_ChecksumOffload));
;;;289      assert_param(IS_ETH_RETRY_TRANSMISSION(ETH_InitStruct->ETH_RetryTransmission));
;;;290      assert_param(IS_ETH_AUTOMATIC_PADCRC_STRIP(ETH_InitStruct->ETH_AutomaticPadCRCStrip));
;;;291      assert_param(IS_ETH_BACKOFF_LIMIT(ETH_InitStruct->ETH_BackOffLimit));
;;;292      assert_param(IS_ETH_DEFERRAL_CHECK(ETH_InitStruct->ETH_DeferralCheck));
;;;293      assert_param(IS_ETH_RECEIVE_ALL(ETH_InitStruct->ETH_ReceiveAll));
;;;294      assert_param(IS_ETH_SOURCE_ADDR_FILTER(ETH_InitStruct->ETH_SourceAddrFilter));
;;;295      assert_param(IS_ETH_CONTROL_FRAMES(ETH_InitStruct->ETH_PassControlFrames));
;;;296      assert_param(IS_ETH_BROADCAST_FRAMES_RECEPTION(ETH_InitStruct->ETH_BroadcastFramesReception));
;;;297      assert_param(IS_ETH_DESTINATION_ADDR_FILTER(ETH_InitStruct->ETH_DestinationAddrFilter));
;;;298      assert_param(IS_ETH_PROMISCUOUS_MODE(ETH_InitStruct->ETH_PromiscuousMode));
;;;299      assert_param(IS_ETH_MULTICAST_FRAMES_FILTER(ETH_InitStruct->ETH_MulticastFramesFilter));  
;;;300      assert_param(IS_ETH_UNICAST_FRAMES_FILTER(ETH_InitStruct->ETH_UnicastFramesFilter));
;;;301      assert_param(IS_ETH_PAUSE_TIME(ETH_InitStruct->ETH_PauseTime));
;;;302      assert_param(IS_ETH_ZEROQUANTA_PAUSE(ETH_InitStruct->ETH_ZeroQuantaPause));
;;;303      assert_param(IS_ETH_PAUSE_LOW_THRESHOLD(ETH_InitStruct->ETH_PauseLowThreshold));
;;;304      assert_param(IS_ETH_UNICAST_PAUSE_FRAME_DETECT(ETH_InitStruct->ETH_UnicastPauseFrameDetect));
;;;305      assert_param(IS_ETH_RECEIVE_FLOWCONTROL(ETH_InitStruct->ETH_ReceiveFlowControl));
;;;306      assert_param(IS_ETH_TRANSMIT_FLOWCONTROL(ETH_InitStruct->ETH_TransmitFlowControl));
;;;307      assert_param(IS_ETH_VLAN_TAG_COMPARISON(ETH_InitStruct->ETH_VLANTagComparison));
;;;308      assert_param(IS_ETH_VLAN_TAG_IDENTIFIER(ETH_InitStruct->ETH_VLANTagIdentifier));
;;;309      /* DMA --------------------------*/
;;;310      assert_param(IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame));
;;;311      assert_param(IS_ETH_RECEIVE_STORE_FORWARD(ETH_InitStruct->ETH_ReceiveStoreForward));
;;;312      assert_param(IS_ETH_FLUSH_RECEIVE_FRAME(ETH_InitStruct->ETH_FlushReceivedFrame));
;;;313      assert_param(IS_ETH_TRANSMIT_STORE_FORWARD(ETH_InitStruct->ETH_TransmitStoreForward));
;;;314      assert_param(IS_ETH_TRANSMIT_THRESHOLD_CONTROL(ETH_InitStruct->ETH_TransmitThresholdControl));
;;;315      assert_param(IS_ETH_FORWARD_ERROR_FRAMES(ETH_InitStruct->ETH_ForwardErrorFrames));
;;;316      assert_param(IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(ETH_InitStruct->ETH_ForwardUndersizedGoodFrames));
;;;317      assert_param(IS_ETH_RECEIVE_THRESHOLD_CONTROL(ETH_InitStruct->ETH_ReceiveThresholdControl));
;;;318      assert_param(IS_ETH_SECOND_FRAME_OPERATE(ETH_InitStruct->ETH_SecondFrameOperate));
;;;319      assert_param(IS_ETH_ADDRESS_ALIGNED_BEATS(ETH_InitStruct->ETH_AddressAlignedBeats));
;;;320      assert_param(IS_ETH_FIXED_BURST(ETH_InitStruct->ETH_FixedBurst));
;;;321      assert_param(IS_ETH_RXDMA_BURST_LENGTH(ETH_InitStruct->ETH_RxDMABurstLength));
;;;322      assert_param(IS_ETH_TXDMA_BURST_LENGTH(ETH_InitStruct->ETH_TxDMABurstLength)); 
;;;323      assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));  
;;;324      assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));       
;;;325      /*-------------------------------- MAC Config ------------------------------*/   
;;;326      /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
;;;327      /* Get the ETHERNET MACMIIAR value */
;;;328      tmpreg = ETH->MACMIIAR;
000144  4ed1              LDR      r6,|L1.1164|
000146  4604              MOV      r4,r0                 ;271
000148  9700              STR      r7,[sp,#0]            ;276
00014a  9701              STR      r7,[sp,#4]
00014c  6930              LDR      r0,[r6,#0x10]
00014e  4688              MOV      r8,r1                 ;271
;;;329      /* Clear CSR Clock Range CR[2:0] bits */
;;;330      tmpreg &= MACMIIAR_CR_MASK;
000150  f020051c          BIC      r5,r0,#0x1c
;;;331      /* Get hclk frequency value */
;;;332      RCC_GetClocksFreq(&rcc_clocks);
000154  a802              ADD      r0,sp,#8
000156  f7fffffe          BL       RCC_GetClocksFreq
;;;333      hclk = rcc_clocks.HCLK_Frequency;
;;;334      
;;;335      /* Set CR bits depending on hclk value */
;;;336      if((hclk >= 20000000)&&(hclk < 35000000))
00015a  49ce              LDR      r1,|L1.1172|
00015c  9803              LDR      r0,[sp,#0xc]
00015e  4ace              LDR      r2,|L1.1176|
000160  4401              ADD      r1,r1,r0
000162  4291              CMP      r1,r2
000164  d202              BCS      |L1.364|
;;;337      {
;;;338        /* CSR Clock Range between 20-35 MHz */
;;;339        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
000166  f0450508          ORR      r5,r5,#8
00016a  e016              B        |L1.410|
                  |L1.364|
;;;340      }
;;;341      else if((hclk >= 35000000)&&(hclk < 60000000))
00016c  49cb              LDR      r1,|L1.1180|
00016e  4acc              LDR      r2,|L1.1184|
000170  4401              ADD      r1,r1,r0
000172  4291              CMP      r1,r2
000174  d202              BCS      |L1.380|
;;;342      {
;;;343        /* CSR Clock Range between 35-60 MHz */ 
;;;344        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;    
000176  f045050c          ORR      r5,r5,#0xc
00017a  e00e              B        |L1.410|
                  |L1.380|
;;;345      }  
;;;346      else if((hclk >= 60000000)&&(hclk < 100000000))
00017c  49c9              LDR      r1,|L1.1188|
00017e  4aca              LDR      r2,|L1.1192|
000180  4401              ADD      r1,r1,r0
000182  4291              CMP      r1,r2
000184  d309              BCC      |L1.410|
;;;347      {
;;;348        /* CSR Clock Range between 60-100 MHz */ 
;;;349        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;    
;;;350      }  
;;;351      else if((hclk >= 100000000)&&(hclk < 150000000))
000186  49c9              LDR      r1,|L1.1196|
000188  4408              ADD      r0,r0,r1
00018a  49c9              LDR      r1,|L1.1200|
00018c  4288              CMP      r0,r1
00018e  d202              BCS      |L1.406|
;;;352      {
;;;353        /* CSR Clock Range between 100-150 MHz */ 
;;;354        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;    
000190  f0450504          ORR      r5,r5,#4
000194  e001              B        |L1.410|
                  |L1.406|
;;;355      }   
;;;356      else /* ((hclk >= 150000000)&&(hclk <= 168000000)) */
;;;357      {
;;;358        /* CSR Clock Range between 150-168 MHz */ 
;;;359        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
000196  f0450510          ORR      r5,r5,#0x10
                  |L1.410|
;;;360      }
;;;361      
;;;362      /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
;;;363      ETH->MACMIIAR = (uint32_t)tmpreg;  
00019a  6135              STR      r5,[r6,#0x10]
;;;364      /*-------------------- PHY initialization and configuration ----------------*/
;;;365      /* Put the PHY in reset mode */
;;;366      if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
00019c  f44f4200          MOV      r2,#0x8000
0001a0  2100              MOVS     r1,#0
0001a2  4640              MOV      r0,r8
0001a4  f7fffffe          BL       ETH_WritePHYRegister
0001a8  2800              CMP      r0,#0
0001aa  d02d              BEQ      |L1.520|
;;;367      {
;;;368        /* Return ERROR in case of write timeout */
;;;369        return ETH_ERROR;
;;;370      }
;;;371      /* Delay to assure PHY reset */
;;;372      _eth_delay_(PHY_RESET_DELAY);
0001ac  48c1              LDR      r0,|L1.1204|
0001ae  f7fffffe          BL       ETH_Delay
;;;373      if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
0001b2  6820              LDR      r0,[r4,#0]
0001b4  b3b8              CBZ      r0,|L1.550|
;;;374      {  
;;;375        /* We wait for linked status... */
;;;376    		
;;;377        do
;;;378        {
;;;379          timeout++;
;;;380        } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
0001b6  4db6              LDR      r5,|L1.1168|
                  |L1.440|
0001b8  9801              LDR      r0,[sp,#4]            ;379
0001ba  2101              MOVS     r1,#1
0001bc  1c40              ADDS     r0,r0,#1              ;379
0001be  9001              STR      r0,[sp,#4]
0001c0  4640              MOV      r0,r8
0001c2  f7fffffe          BL       ETH_ReadPHYRegister
0001c6  0740              LSLS     r0,r0,#29
0001c8  d402              BMI      |L1.464|
0001ca  9801              LDR      r0,[sp,#4]
0001cc  42a8              CMP      r0,r5
0001ce  d3f3              BCC      |L1.440|
                  |L1.464|
;;;381        /* Return ERROR in case of timeout */
;;;382        if(timeout == PHY_READ_TO)
0001d0  9801              LDR      r0,[sp,#4]
0001d2  42a8              CMP      r0,r5
0001d4  d017              BEQ      |L1.518|
;;;383        {
;;;384          return ETH_ERROR;
;;;385        }
;;;386    
;;;387        /* Reset Timeout counter */
;;;388        timeout = 0; 
;;;389        /* Enable Auto-Negotiation */
;;;390        if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
0001d6  f44f5280          MOV      r2,#0x1000
0001da  2100              MOVS     r1,#0
0001dc  4640              MOV      r0,r8
0001de  9701              STR      r7,[sp,#4]
0001e0  f7fffffe          BL       ETH_WritePHYRegister
0001e4  2800              CMP      r0,#0
0001e6  d00f              BEQ      |L1.520|
                  |L1.488|
;;;391        {
;;;392          /* Return ERROR in case of write timeout */
;;;393          return ETH_ERROR;
;;;394        }
;;;395    
;;;396        /* Wait until the auto-negotiation will be completed */
;;;397    		do
;;;398        {
;;;399          timeout++;
0001e8  9801              LDR      r0,[sp,#4]
;;;400        } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
0001ea  2101              MOVS     r1,#1
0001ec  1c40              ADDS     r0,r0,#1              ;399
0001ee  9001              STR      r0,[sp,#4]
0001f0  4640              MOV      r0,r8
0001f2  f7fffffe          BL       ETH_ReadPHYRegister
0001f6  0680              LSLS     r0,r0,#26
0001f8  d402              BMI      |L1.512|
0001fa  9801              LDR      r0,[sp,#4]
0001fc  42a8              CMP      r0,r5
0001fe  d3f3              BCC      |L1.488|
                  |L1.512|
;;;401        /* Return ERROR in case of timeout */
;;;402        if(timeout == PHY_READ_TO)
000200  9801              LDR      r0,[sp,#4]
000202  42a8              CMP      r0,r5
000204  d103              BNE      |L1.526|
                  |L1.518|
;;;403        {
;;;404          return ETH_ERROR;
000206  2000              MOVS     r0,#0
                  |L1.520|
;;;405        }
;;;406    
;;;407        /* Reset Timeout counter */
;;;408        timeout = 0;
;;;409        
;;;410        /* Read the result of the auto-negotiation */
;;;411        RegValue = ETH_ReadPHYRegister(PHYAddress, PHY_SR);
;;;412      
;;;413        /* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
;;;414        if((RegValue & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
;;;415        {
;;;416          /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
;;;417          ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;  
;;;418        }
;;;419        else
;;;420        {
;;;421          /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
;;;422          ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
;;;423        }
;;;424    
;;;425        /* Configure the MAC with the speed fixed by the auto-negotiation process */
;;;426        if(RegValue & PHY_SPEED_STATUS)
;;;427        {  
;;;428          /* Set Ethernet speed to 10M following the auto-negotiation */    
;;;429          ETH_InitStruct->ETH_Speed = ETH_Speed_10M; 
;;;430        }
;;;431        else
;;;432        {   
;;;433          /* Set Ethernet speed to 100M following the auto-negotiation */ 
;;;434          ETH_InitStruct->ETH_Speed = ETH_Speed_100M;      
;;;435        }    
;;;436      }
;;;437      else
;;;438      {
;;;439        if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
;;;440                                                       (uint16_t)(ETH_InitStruct->ETH_Speed >> 1))))
;;;441        {
;;;442          /* Return ERROR in case of write timeout */
;;;443          return ETH_ERROR;
;;;444        }
;;;445        /* Delay to assure PHY configuration */
;;;446        _eth_delay_(PHY_CONFIG_DELAY);
;;;447      }
;;;448      /*------------------------ ETHERNET MACCR Configuration --------------------*/
;;;449      /* Get the ETHERNET MACCR value */  
;;;450      tmpreg = ETH->MACCR;
;;;451      /* Clear WD, PCE, PS, TE and RE bits */
;;;452      tmpreg &= MACCR_CLEAR_MASK;
;;;453      /* Set the WD bit according to ETH_Watchdog value */
;;;454      /* Set the JD: bit according to ETH_Jabber value */
;;;455      /* Set the IFG bit according to ETH_InterFrameGap value */ 
;;;456      /* Set the DCRS bit according to ETH_CarrierSense value */  
;;;457      /* Set the FES bit according to ETH_Speed value */ 
;;;458      /* Set the DO bit according to ETH_ReceiveOwn value */ 
;;;459      /* Set the LM bit according to ETH_LoopbackMode value */ 
;;;460      /* Set the DM bit according to ETH_Mode value */ 
;;;461      /* Set the IPCO bit according to ETH_ChecksumOffload value */                   
;;;462      /* Set the DR bit according to ETH_RetryTransmission value */ 
;;;463      /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
;;;464      /* Set the BL bit according to ETH_BackOffLimit value */ 
;;;465      /* Set the DC bit according to ETH_DeferralCheck value */                          
;;;466      tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
;;;467                      ETH_InitStruct->ETH_Jabber | 
;;;468                      ETH_InitStruct->ETH_InterFrameGap |
;;;469                      ETH_InitStruct->ETH_CarrierSense |
;;;470                      ETH_InitStruct->ETH_Speed | 
;;;471                      ETH_InitStruct->ETH_ReceiveOwn |
;;;472                      ETH_InitStruct->ETH_LoopbackMode |
;;;473                      ETH_InitStruct->ETH_Mode | 
;;;474                      ETH_InitStruct->ETH_ChecksumOffload |    
;;;475                      ETH_InitStruct->ETH_RetryTransmission | 
;;;476                      ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
;;;477                      ETH_InitStruct->ETH_BackOffLimit | 
;;;478                      ETH_InitStruct->ETH_DeferralCheck);
;;;479      /* Write to ETHERNET MACCR */
;;;480      ETH->MACCR = (uint32_t)tmpreg;
;;;481      
;;;482      /*----------------------- ETHERNET MACFFR Configuration --------------------*/ 
;;;483      /* Set the RA bit according to ETH_ReceiveAll value */
;;;484      /* Set the SAF and SAIF bits according to ETH_SourceAddrFilter value */
;;;485      /* Set the PCF bit according to ETH_PassControlFrames value */
;;;486      /* Set the DBF bit according to ETH_BroadcastFramesReception value */
;;;487      /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
;;;488      /* Set the PR bit according to ETH_PromiscuousMode value */
;;;489      /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
;;;490      /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
;;;491      /* Write to ETHERNET MACFFR */  
;;;492      ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
;;;493                              ETH_InitStruct->ETH_SourceAddrFilter |
;;;494                              ETH_InitStruct->ETH_PassControlFrames |
;;;495                              ETH_InitStruct->ETH_BroadcastFramesReception | 
;;;496                              ETH_InitStruct->ETH_DestinationAddrFilter |
;;;497                              ETH_InitStruct->ETH_PromiscuousMode |
;;;498                              ETH_InitStruct->ETH_MulticastFramesFilter |
;;;499                              ETH_InitStruct->ETH_UnicastFramesFilter); 
;;;500      /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
;;;501      /* Write to ETHERNET MACHTHR */
;;;502      ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
;;;503      /* Write to ETHERNET MACHTLR */
;;;504      ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
;;;505      /*----------------------- ETHERNET MACFCR Configuration --------------------*/
;;;506      /* Get the ETHERNET MACFCR value */  
;;;507      tmpreg = ETH->MACFCR;
;;;508      /* Clear xx bits */
;;;509      tmpreg &= MACFCR_CLEAR_MASK;
;;;510      
;;;511      /* Set the PT bit according to ETH_PauseTime value */
;;;512      /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
;;;513      /* Set the PLT bit according to ETH_PauseLowThreshold value */
;;;514      /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
;;;515      /* Set the RFE bit according to ETH_ReceiveFlowControl value */
;;;516      /* Set the TFE bit according to ETH_TransmitFlowControl value */  
;;;517      tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
;;;518                       ETH_InitStruct->ETH_ZeroQuantaPause |
;;;519                       ETH_InitStruct->ETH_PauseLowThreshold |
;;;520                       ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
;;;521                       ETH_InitStruct->ETH_ReceiveFlowControl |
;;;522                       ETH_InitStruct->ETH_TransmitFlowControl); 
;;;523      /* Write to ETHERNET MACFCR */
;;;524      ETH->MACFCR = (uint32_t)tmpreg;
;;;525      /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
;;;526      /* Set the ETV bit according to ETH_VLANTagComparison value */
;;;527      /* Set the VL bit according to ETH_VLANTagIdentifier value */  
;;;528      ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
;;;529                                 ETH_InitStruct->ETH_VLANTagIdentifier); 
;;;530           
;;;531      /*-------------------------------- DMA Config ------------------------------*/
;;;532      /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
;;;533      /* Get the ETHERNET DMAOMR value */  
;;;534      tmpreg = ETH->DMAOMR;
;;;535      /* Clear xx bits */
;;;536      tmpreg &= DMAOMR_CLEAR_MASK;
;;;537      
;;;538      /* Set the DT bit according to ETH_DropTCPIPChecksumErrorFrame value */
;;;539      /* Set the RSF bit according to ETH_ReceiveStoreForward value */
;;;540      /* Set the DFF bit according to ETH_FlushReceivedFrame value */
;;;541      /* Set the TSF bit according to ETH_TransmitStoreForward value */
;;;542      /* Set the TTC bit according to ETH_TransmitThresholdControl value */
;;;543      /* Set the FEF bit according to ETH_ForwardErrorFrames value */
;;;544      /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
;;;545      /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
;;;546      /* Set the OSF bit according to ETH_SecondFrameOperate value */
;;;547      tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
;;;548                      ETH_InitStruct->ETH_ReceiveStoreForward |
;;;549                      ETH_InitStruct->ETH_FlushReceivedFrame |
;;;550                      ETH_InitStruct->ETH_TransmitStoreForward | 
;;;551                      ETH_InitStruct->ETH_TransmitThresholdControl |
;;;552                      ETH_InitStruct->ETH_ForwardErrorFrames |
;;;553                      ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
;;;554                      ETH_InitStruct->ETH_ReceiveThresholdControl |                                   
;;;555                      ETH_InitStruct->ETH_SecondFrameOperate); 
;;;556      /* Write to ETHERNET DMAOMR */
;;;557      ETH->DMAOMR = (uint32_t)tmpreg;
;;;558      
;;;559      /*----------------------- ETHERNET DMABMR Configuration --------------------*/ 
;;;560      /* Set the AAL bit according to ETH_AddressAlignedBeats value */
;;;561      /* Set the FB bit according to ETH_FixedBurst value */
;;;562      /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
;;;563      /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
;;;564      /* Set the DSL bit according to ETH_DesciptorSkipLength value */
;;;565      /* Set the PR and DA bits according to ETH_DMAArbitration value */         
;;;566      ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
;;;567                              ETH_InitStruct->ETH_FixedBurst |
;;;568                              ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
;;;569                              ETH_InitStruct->ETH_TxDMABurstLength | 
;;;570                             (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
;;;571                              ETH_InitStruct->ETH_DMAArbitration |
;;;572                              ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */
;;;573                              
;;;574      #ifdef USE_ENHANCED_DMA_DESCRIPTORS
;;;575        /* Enable the Enhanced DMA descriptors */
;;;576        ETH->DMABMR |= ETH_DMABMR_EDE;
;;;577      #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
;;;578                                  
;;;579      /* Return Ethernet configuration success */
;;;580      return ETH_SUCCESS;
;;;581    }
000208  b006              ADD      sp,sp,#0x18
00020a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.526|
00020e  2111              MOVS     r1,#0x11              ;411
000210  4640              MOV      r0,r8                 ;411
000212  9701              STR      r7,[sp,#4]            ;411
000214  f7fffffe          BL       ETH_ReadPHYRegister
000218  f4104f20          TST      r0,#0xa000            ;414
00021c  d004              BEQ      |L1.552|
00021e  f44f6100          MOV      r1,#0x800             ;417
000222  6221              STR      r1,[r4,#0x20]         ;417
000224  e001              B        |L1.554|
                  |L1.550|
000226  e009              B        |L1.572|
                  |L1.552|
000228  6227              STR      r7,[r4,#0x20]         ;422
                  |L1.554|
00022a  f4105f40          TST      r0,#0x3000            ;426
00022e  d001              BEQ      |L1.564|
000230  6167              STR      r7,[r4,#0x14]         ;429
000232  e013              B        |L1.604|
                  |L1.564|
000234  f44f4080          MOV      r0,#0x4000            ;434
000238  6160              STR      r0,[r4,#0x14]         ;434
00023a  e00f              B        |L1.604|
                  |L1.572|
00023c  6a20              LDR      r0,[r4,#0x20]         ;439
00023e  6961              LDR      r1,[r4,#0x14]         ;439
000240  08c0              LSRS     r0,r0,#3              ;439
000242  ea400051          ORR      r0,r0,r1,LSR #1       ;439
000246  b282              UXTH     r2,r0                 ;439
000248  2100              MOVS     r1,#0                 ;439
00024a  4640              MOV      r0,r8                 ;439
00024c  f7fffffe          BL       ETH_WritePHYRegister
000250  2800              CMP      r0,#0                 ;439
000252  d0d9              BEQ      |L1.520|
000254  f06f407f          MVN      r0,#0xff000000        ;446
000258  f7fffffe          BL       ETH_Delay
                  |L1.604|
00025c  6831              LDR      r1,[r6,#0]            ;450
00025e  4896              LDR      r0,|L1.1208|
000260  4001              ANDS     r1,r1,r0              ;452
000262  e9d40201          LDRD     r0,r2,[r4,#4]         ;452
000266  4310              ORRS     r0,r0,r2              ;466
000268  68e2              LDR      r2,[r4,#0xc]          ;466
00026a  f8543f10          LDR      r3,[r4,#0x10]!        ;466
00026e  431a              ORRS     r2,r2,r3              ;466
000270  4310              ORRS     r0,r0,r2              ;466
000272  6862              LDR      r2,[r4,#4]            ;466
000274  4310              ORRS     r0,r0,r2              ;466
000276  68a2              LDR      r2,[r4,#8]            ;466
000278  4310              ORRS     r0,r0,r2              ;466
00027a  68e2              LDR      r2,[r4,#0xc]          ;466
00027c  4310              ORRS     r0,r0,r2              ;466
00027e  6922              LDR      r2,[r4,#0x10]         ;466
000280  4310              ORRS     r0,r0,r2              ;466
000282  6962              LDR      r2,[r4,#0x14]         ;466
000284  4310              ORRS     r0,r0,r2              ;466
000286  69a2              LDR      r2,[r4,#0x18]         ;466
000288  4310              ORRS     r0,r0,r2              ;466
00028a  69e2              LDR      r2,[r4,#0x1c]         ;466
00028c  4310              ORRS     r0,r0,r2              ;466
00028e  6a22              LDR      r2,[r4,#0x20]         ;466
000290  4310              ORRS     r0,r0,r2              ;466
000292  6a62              LDR      r2,[r4,#0x24]         ;466
000294  4310              ORRS     r0,r0,r2              ;466
000296  4308              ORRS     r0,r0,r1              ;466
000298  6030              STR      r0,[r6,#0]            ;480
00029a  e9f4010a          LDRD     r0,r1,[r4,#0x28]!     ;480
00029e  4308              ORRS     r0,r0,r1              ;492
0002a0  e9d41202          LDRD     r1,r2,[r4,#8]         ;492
0002a4  4311              ORRS     r1,r1,r2              ;492
0002a6  4308              ORRS     r0,r0,r1              ;492
0002a8  6921              LDR      r1,[r4,#0x10]         ;492
0002aa  4308              ORRS     r0,r0,r1              ;492
0002ac  6961              LDR      r1,[r4,#0x14]         ;492
0002ae  4308              ORRS     r0,r0,r1              ;492
0002b0  69a1              LDR      r1,[r4,#0x18]         ;492
0002b2  4308              ORRS     r0,r0,r1              ;492
0002b4  69e1              LDR      r1,[r4,#0x1c]         ;492
0002b6  4308              ORRS     r0,r0,r1              ;492
0002b8  6070              STR      r0,[r6,#4]            ;492
0002ba  6a20              LDR      r0,[r4,#0x20]         ;502
0002bc  60b0              STR      r0,[r6,#8]            ;502
0002be  6a60              LDR      r0,[r4,#0x24]         ;504
0002c0  60f0              STR      r0,[r6,#0xc]          ;504
0002c2  69b1              LDR      r1,[r6,#0x18]         ;507
0002c4  f64f7041          MOV      r0,#0xff41            ;509
0002c8  4001              ANDS     r1,r1,r0              ;509
0002ca  e9d4020b          LDRD     r0,r2,[r4,#0x2c]      ;509
0002ce  4310              ORRS     r0,r0,r2              ;517
0002d0  8d23              LDRH     r3,[r4,#0x28]         ;517
0002d2  6b62              LDR      r2,[r4,#0x34]         ;517
0002d4  ea424203          ORR      r2,r2,r3,LSL #16      ;517
0002d8  4310              ORRS     r0,r0,r2              ;517
0002da  6ba2              LDR      r2,[r4,#0x38]         ;517
0002dc  4310              ORRS     r0,r0,r2              ;517
0002de  6be2              LDR      r2,[r4,#0x3c]         ;517
0002e0  4310              ORRS     r0,r0,r2              ;517
0002e2  4308              ORRS     r0,r0,r1              ;517
0002e4  61b0              STR      r0,[r6,#0x18]         ;524
0002e6  e9d40110          LDRD     r0,r1,[r4,#0x40]      ;524
0002ea  4308              ORRS     r0,r0,r1              ;528
0002ec  61f0              STR      r0,[r6,#0x1c]         ;528
0002ee  4873              LDR      r0,|L1.1212|
0002f0  6982              LDR      r2,[r0,#0x18]         ;534
0002f2  4973              LDR      r1,|L1.1216|
0002f4  400a              ANDS     r2,r2,r1              ;536
0002f6  e9d41312          LDRD     r1,r3,[r4,#0x48]      ;536
0002fa  4319              ORRS     r1,r1,r3              ;547
0002fc  e9d43514          LDRD     r3,r5,[r4,#0x50]      ;547
000300  432b              ORRS     r3,r3,r5              ;547
000302  4319              ORRS     r1,r1,r3              ;547
000304  6da3              LDR      r3,[r4,#0x58]         ;547
000306  4319              ORRS     r1,r1,r3              ;547
000308  6de3              LDR      r3,[r4,#0x5c]         ;547
00030a  4319              ORRS     r1,r1,r3              ;547
00030c  6e23              LDR      r3,[r4,#0x60]         ;547
00030e  4319              ORRS     r1,r1,r3              ;547
000310  6e63              LDR      r3,[r4,#0x64]         ;547
000312  4319              ORRS     r1,r1,r3              ;547
000314  6ea3              LDR      r3,[r4,#0x68]         ;547
000316  4319              ORRS     r1,r1,r3              ;547
000318  4311              ORRS     r1,r1,r2              ;547
00031a  6181              STR      r1,[r0,#0x18]         ;557
00031c  e9d4121b          LDRD     r1,r2,[r4,#0x6c]      ;557
000320  4311              ORRS     r1,r1,r2              ;566
000322  6f62              LDR      r2,[r4,#0x74]         ;566
000324  f8543f78          LDR      r3,[r4,#0x78]!        ;566
000328  431a              ORRS     r2,r2,r3              ;566
00032a  4311              ORRS     r1,r1,r2              ;566
00032c  6862              LDR      r2,[r4,#4]            ;566
00032e  ea410182          ORR      r1,r1,r2,LSL #2       ;566
000332  68a2              LDR      r2,[r4,#8]            ;566
000334  4311              ORRS     r1,r1,r2              ;566
000336  f4410100          ORR      r1,r1,#0x800000       ;566
00033a  6001              STR      r1,[r0,#0]            ;566
00033c  6801              LDR      r1,[r0,#0]            ;576
00033e  f0410180          ORR      r1,r1,#0x80           ;576
000342  6001              STR      r1,[r0,#0]            ;576
000344  2001              MOVS     r0,#1                 ;580
000346  e75f              B        |L1.520|
;;;582    
                          ENDP

                  ETH_DMAReceptionCmd PROC
;;;2027     */
;;;2028   void ETH_DMAReceptionCmd(FunctionalState NewState)
000348  495c              LDR      r1,|L1.1212|
;;;2029   { 
;;;2030     /* Check the parameters */
;;;2031     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2032     
;;;2033     if (NewState != DISABLE)
00034a  2800              CMP      r0,#0
;;;2034     {
;;;2035       /* Enable the DMA reception */
;;;2036       ETH->DMAOMR |= ETH_DMAOMR_SR;  
;;;2037     }
;;;2038     else
;;;2039     {
;;;2040       /* Disable the DMA reception */
;;;2041       ETH->DMAOMR &= ~ETH_DMAOMR_SR;
00034c  6988              LDR      r0,[r1,#0x18]
00034e  d002              BEQ      |L1.854|
000350  f0400002          ORR      r0,r0,#2              ;2036
000354  e001              B        |L1.858|
                  |L1.854|
000356  f0200002          BIC      r0,r0,#2
                  |L1.858|
00035a  6188              STR      r0,[r1,#0x18]         ;2036
;;;2042     }
;;;2043   }
00035c  4770              BX       lr
;;;2044   
                          ENDP

                  ETH_DMATransmissionCmd PROC
;;;2004     */
;;;2005   void ETH_DMATransmissionCmd(FunctionalState NewState)
00035e  4957              LDR      r1,|L1.1212|
;;;2006   { 
;;;2007     /* Check the parameters */
;;;2008     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2009     
;;;2010     if (NewState != DISABLE)
000360  2800              CMP      r0,#0
;;;2011     {
;;;2012       /* Enable the DMA transmission */
;;;2013       ETH->DMAOMR |= ETH_DMAOMR_ST;  
;;;2014     }
;;;2015     else
;;;2016     {
;;;2017       /* Disable the DMA transmission */
;;;2018       ETH->DMAOMR &= ~ETH_DMAOMR_ST;
000362  6988              LDR      r0,[r1,#0x18]
000364  d002              BEQ      |L1.876|
000366  f4405000          ORR      r0,r0,#0x2000         ;2013
00036a  e001              B        |L1.880|
                  |L1.876|
00036c  f4205000          BIC      r0,r0,#0x2000
                  |L1.880|
000370  6188              STR      r0,[r1,#0x18]         ;2013
;;;2019     }
;;;2020   }
000372  4770              BX       lr
;;;2021   
                          ENDP

                  ETH_MACReceptionCmd PROC
;;;633      */
;;;634    void ETH_MACReceptionCmd(FunctionalState NewState)
000374  4945              LDR      r1,|L1.1164|
;;;635    { 
;;;636      /* Check the parameters */
;;;637      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;638      
;;;639      if (NewState != DISABLE)
000376  2800              CMP      r0,#0
;;;640      {
;;;641        /* Enable the MAC reception */
;;;642        ETH->MACCR |= ETH_MACCR_RE;  
;;;643      }
;;;644      else
;;;645      {
;;;646        /* Disable the MAC reception */
;;;647        ETH->MACCR &= ~ETH_MACCR_RE;
000378  6808              LDR      r0,[r1,#0]
00037a  d002              BEQ      |L1.898|
00037c  f0400004          ORR      r0,r0,#4              ;642
000380  e001              B        |L1.902|
                  |L1.898|
000382  f0200004          BIC      r0,r0,#4
                  |L1.902|
000386  6008              STR      r0,[r1,#0]            ;642
;;;648      }
;;;649    }
000388  4770              BX       lr
;;;650    
                          ENDP

                  ETH_FlushTransmitFIFO PROC
;;;1973     */
;;;1974   void ETH_FlushTransmitFIFO(void)
00038a  484c              LDR      r0,|L1.1212|
;;;1975   {
;;;1976     /* Set the Flush Transmit FIFO bit */
;;;1977     ETH->DMAOMR |= ETH_DMAOMR_FTF;  
00038c  6981              LDR      r1,[r0,#0x18]
00038e  f4411180          ORR      r1,r1,#0x100000
000392  6181              STR      r1,[r0,#0x18]
;;;1978   }
000394  4770              BX       lr
;;;1979   
                          ENDP

                  ETH_MACTransmissionCmd PROC
;;;609      */
;;;610    void ETH_MACTransmissionCmd(FunctionalState NewState)
000396  493d              LDR      r1,|L1.1164|
;;;611    { 
;;;612      /* Check the parameters */
;;;613      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;614      
;;;615      if (NewState != DISABLE)
000398  2800              CMP      r0,#0
;;;616      {
;;;617        /* Enable the MAC transmission */
;;;618        ETH->MACCR |= ETH_MACCR_TE;  
;;;619      }
;;;620      else
;;;621      {
;;;622        /* Disable the MAC transmission */
;;;623        ETH->MACCR &= ~ETH_MACCR_TE;
00039a  6808              LDR      r0,[r1,#0]
00039c  d002              BEQ      |L1.932|
00039e  f0400008          ORR      r0,r0,#8              ;618
0003a2  e001              B        |L1.936|
                  |L1.932|
0003a4  f0200008          BIC      r0,r0,#8
                  |L1.936|
0003a8  6008              STR      r0,[r1,#0]            ;618
;;;624      }
;;;625    }
0003aa  4770              BX       lr
;;;626    
                          ENDP

                  ETH_Start PROC
;;;587      */
;;;588    void ETH_Start(void)
0003ac  b500              PUSH     {lr}
;;;589    {
;;;590      /* Enable transmit state machine of the MAC for transmission on the MII */  
;;;591      ETH_MACTransmissionCmd(ENABLE);
0003ae  2001              MOVS     r0,#1
0003b0  f7fffffe          BL       ETH_MACTransmissionCmd
;;;592      /* Flush Transmit FIFO */
;;;593      ETH_FlushTransmitFIFO();
0003b4  f7fffffe          BL       ETH_FlushTransmitFIFO
;;;594      /* Enable receive state machine of the MAC for reception from the MII */  
;;;595      ETH_MACReceptionCmd(ENABLE);
0003b8  2001              MOVS     r0,#1
0003ba  f7fffffe          BL       ETH_MACReceptionCmd
;;;596     
;;;597      /* Start DMA transmission */
;;;598      ETH_DMATransmissionCmd(ENABLE); 
0003be  2001              MOVS     r0,#1
0003c0  f7fffffe          BL       ETH_DMATransmissionCmd
;;;599      /* Start DMA reception */
;;;600      ETH_DMAReceptionCmd(ENABLE);   
0003c4  2001              MOVS     r0,#1
0003c6  f85deb04          POP      {lr}
0003ca  e7fe              B        ETH_DMAReceptionCmd
;;;601    }
;;;602    
                          ENDP

                  ETH_GetFlowControlBusyStatus PROC
;;;656      */
;;;657    FlagStatus ETH_GetFlowControlBusyStatus(void)
0003cc  492f              LDR      r1,|L1.1164|
;;;658    {
;;;659      FlagStatus bitstatus = RESET;
0003ce  2000              MOVS     r0,#0
;;;660      /* The Flow Control register should not be written to until this bit is cleared */
;;;661      if ((ETH->MACFCR & ETH_MACFCR_FCBBPA) != (uint32_t)RESET)
0003d0  6989              LDR      r1,[r1,#0x18]
0003d2  07c9              LSLS     r1,r1,#31
0003d4  d000              BEQ      |L1.984|
;;;662      {
;;;663        bitstatus = SET;
0003d6  2001              MOVS     r0,#1
                  |L1.984|
;;;664      }
;;;665      else
;;;666      {
;;;667        bitstatus = RESET;
;;;668      }
;;;669      return bitstatus;
;;;670    }
0003d8  4770              BX       lr
;;;671    
                          ENDP

                  ETH_InitiatePauseControlFrame PROC
;;;677      */
;;;678    void ETH_InitiatePauseControlFrame(void)  
0003da  482c              LDR      r0,|L1.1164|
;;;679    { 
;;;680      /* When Set In full duplex MAC initiates pause control frame */
;;;681      ETH->MACFCR |= ETH_MACFCR_FCBBPA;  
0003dc  6981              LDR      r1,[r0,#0x18]
0003de  f0410101          ORR      r1,r1,#1
0003e2  6181              STR      r1,[r0,#0x18]
;;;682    }
0003e4  4770              BX       lr
;;;683    
                          ENDP

                  ETH_BackPressureActivationCmd PROC
;;;690      */
;;;691    void ETH_BackPressureActivationCmd(FunctionalState NewState)   
0003e6  4929              LDR      r1,|L1.1164|
;;;692    { 
;;;693      /* Check the parameters */
;;;694      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;695        
;;;696      if (NewState != DISABLE)
0003e8  2800              CMP      r0,#0
;;;697      {
;;;698        /* Activate the MAC BackPressure operation */
;;;699        /* In Half duplex: during backpressure, when the MAC receives a new frame,
;;;700        the transmitter starts sending a JAM pattern resulting in a collision */
;;;701        ETH->MACFCR |= ETH_MACFCR_FCBBPA; 
;;;702      }
;;;703      else
;;;704      {
;;;705        /* Desactivate the MAC BackPressure operation */
;;;706        ETH->MACFCR &= ~ETH_MACFCR_FCBBPA; 
0003ea  6988              LDR      r0,[r1,#0x18]
0003ec  d002              BEQ      |L1.1012|
0003ee  f0400001          ORR      r0,r0,#1              ;701
0003f2  e001              B        |L1.1016|
                  |L1.1012|
0003f4  f0200001          BIC      r0,r0,#1
                  |L1.1016|
0003f8  6188              STR      r0,[r1,#0x18]         ;701
;;;707      } 
;;;708    }
0003fa  4770              BX       lr
;;;709    
                          ENDP

                  ETH_GetMACFlagStatus PROC
;;;721      */
;;;722    FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG)
0003fc  4a23              LDR      r2,|L1.1164|
;;;723    {
0003fe  4601              MOV      r1,r0
;;;724      FlagStatus bitstatus = RESET;
000400  2000              MOVS     r0,#0
;;;725      /* Check the parameters */
;;;726      assert_param(IS_ETH_MAC_GET_FLAG(ETH_MAC_FLAG)); 
;;;727      if ((ETH->MACSR & ETH_MAC_FLAG) != (uint32_t)RESET)
000402  6b92              LDR      r2,[r2,#0x38]
000404  420a              TST      r2,r1
000406  d000              BEQ      |L1.1034|
;;;728      {
;;;729        bitstatus = SET;
000408  2001              MOVS     r0,#1
                  |L1.1034|
;;;730      }
;;;731      else
;;;732      {
;;;733        bitstatus = RESET;
;;;734      }
;;;735      return bitstatus;
;;;736    }
00040a  4770              BX       lr
;;;737    
                          ENDP

                  ETH_GetMACITStatus PROC
;;;749      */
;;;750    ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT)
00040c  4a1f              LDR      r2,|L1.1164|
;;;751    {
00040e  4601              MOV      r1,r0
;;;752      ITStatus bitstatus = RESET;
000410  2000              MOVS     r0,#0
;;;753      /* Check the parameters */
;;;754      assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT)); 
;;;755      if ((ETH->MACSR & ETH_MAC_IT) != (uint32_t)RESET)
000412  6b92              LDR      r2,[r2,#0x38]
000414  420a              TST      r2,r1
000416  d000              BEQ      |L1.1050|
;;;756      {
;;;757        bitstatus = SET;
000418  2001              MOVS     r0,#1
                  |L1.1050|
;;;758      }
;;;759      else
;;;760      {
;;;761        bitstatus = RESET;
;;;762      }
;;;763      return bitstatus;
;;;764    }
00041a  4770              BX       lr
;;;765    
                          ENDP

                  ETH_MACITConfig PROC
;;;777      */
;;;778    void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState)
00041c  4a1b              LDR      r2,|L1.1164|
;;;779    {
;;;780      /* Check the parameters */
;;;781      assert_param(IS_ETH_MAC_IT(ETH_MAC_IT));
;;;782      assert_param(IS_FUNCTIONAL_STATE(NewState));  
;;;783      
;;;784      if (NewState != DISABLE)
00041e  2900              CMP      r1,#0
;;;785      {
;;;786        /* Enable the selected ETHERNET MAC interrupts */
;;;787        ETH->MACIMR &= (~(uint32_t)ETH_MAC_IT);
;;;788      }
;;;789      else
;;;790      {
;;;791        /* Disable the selected ETHERNET MAC interrupts */
;;;792        ETH->MACIMR |= ETH_MAC_IT;
000420  6bd1              LDR      r1,[r2,#0x3c]
000422  d001              BEQ      |L1.1064|
000424  4381              BICS     r1,r1,r0              ;787
000426  e000              B        |L1.1066|
                  |L1.1064|
000428  4301              ORRS     r1,r1,r0
                  |L1.1066|
00042a  63d1              STR      r1,[r2,#0x3c]         ;787
;;;793      }
;;;794    }
00042c  4770              BX       lr
;;;795    
                          ENDP

                  ETH_MACAddressConfig PROC
;;;807      */
;;;808    void ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr)
00042e  4b17              LDR      r3,|L1.1164|
;;;809    {
;;;810      uint32_t tmpreg;
;;;811      /* Check the parameters */
;;;812      assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
;;;813      
;;;814      /* Calculate the selected MAC address high register */
;;;815      tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4]; //计算出所选择的MAC地址的高位寄存器值
000430  888a              LDRH     r2,[r1,#4]
;;;816    																												 //即ETH_MACA0HR的16位值
;;;817      /* Load the selected MAC address high register */
;;;818      (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg; //将计算出的高位值写入ETH_MAC0HR中
000432  4418              ADD      r0,r0,r3
000434  6402              STR      r2,[r0,#0x40]
;;;819      /* Calculate the selected MAC address low register */
;;;820    	//计算出所选择的MAC地址的第位寄存器值,即ETH_MACA0LR的16位值
;;;821      tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
000436  780a              LDRB     r2,[r1,#0]
000438  f8d11001          LDR      r1,[r1,#1]
00043c  ea422101          ORR      r1,r2,r1,LSL #8
;;;822     
;;;823      /* Load the selected MAC address low register */
;;;824      (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;//将计算出的低位值写入ETH_MAC0LR中
000440  6441              STR      r1,[r0,#0x44]
;;;825    }
000442  4770              BX       lr
;;;826    
                          ENDP

                  ETH_GetMACAddress PROC
;;;838      */
;;;839    void ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr)
000444  4a11              LDR      r2,|L1.1164|
;;;840    {
;;;841      uint32_t tmpreg;
;;;842      /* Check the parameters */
;;;843      assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
;;;844      
;;;845      /* Get the selected MAC address high register */
;;;846      tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
000446  4402              ADD      r2,r2,r0
000448  6c10              LDR      r0,[r2,#0x40]
;;;847     
;;;848      /* Calculate the selected MAC address buffer */
;;;849      Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
00044a  0a03              LSRS     r3,r0,#8
00044c  714b              STRB     r3,[r1,#5]
;;;850      Addr[4] = (tmpreg & (uint8_t)0xFF);
00044e  7108              STRB     r0,[r1,#4]
;;;851      /* Load the selected MAC address low register */
;;;852      tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
000450  6c50              LDR      r0,[r2,#0x44]
;;;853      /* Calculate the selected MAC address buffer */
;;;854      Addr[3] = ((tmpreg >> 24) & (uint8_t)0xFF);
000452  0e02              LSRS     r2,r0,#24
000454  70ca              STRB     r2,[r1,#3]
;;;855      Addr[2] = ((tmpreg >> 16) & (uint8_t)0xFF);
000456  0c02              LSRS     r2,r0,#16
000458  708a              STRB     r2,[r1,#2]
;;;856      Addr[1] = ((tmpreg >> 8 ) & (uint8_t)0xFF);
00045a  0a02              LSRS     r2,r0,#8
00045c  704a              STRB     r2,[r1,#1]
;;;857      Addr[0] = (tmpreg & (uint8_t)0xFF);
00045e  7008              STRB     r0,[r1,#0]
;;;858    }
000460  4770              BX       lr
;;;859    
                          ENDP

                  ETH_MACAddressPerfectFilterCmd PROC
;;;872      */
;;;873    void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState)
000462  4a0a              LDR      r2,|L1.1164|
;;;874    {
;;;875      /* Check the parameters */
;;;876      assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
;;;877      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;878        
;;;879      if (NewState != DISABLE)
000464  2900              CMP      r1,#0
;;;880      {
;;;881        /* Enable the selected ETHERNET MAC address for perfect filtering */
;;;882        (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE;
000466  4410              ADD      r0,r0,r2
;;;883      }
;;;884      else
;;;885      {
;;;886        /* Disable the selected ETHERNET MAC address for perfect filtering */
;;;887        (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_AE);
000468  6c01              LDR      r1,[r0,#0x40]
00046a  d002              BEQ      |L1.1138|
00046c  f0414100          ORR      r1,r1,#0x80000000     ;882
000470  e001              B        |L1.1142|
                  |L1.1138|
000472  f0214100          BIC      r1,r1,#0x80000000
                  |L1.1142|
000476  6401              STR      r1,[r0,#0x40]         ;882
;;;888      }
;;;889    }
000478  4770              BX       lr
;;;890    
                          ENDP

                  ETH_MACAddressFilterConfig PROC
;;;906      */
;;;907    void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter)
00047a  4a04              LDR      r2,|L1.1164|
;;;908    {
;;;909      /* Check the parameters */
;;;910      assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
;;;911      assert_param(IS_ETH_MAC_ADDRESS_FILTER(Filter));
;;;912      
;;;913      if (Filter != ETH_MAC_AddressFilter_DA)
00047c  2908              CMP      r1,#8
;;;914      {
;;;915        /* The selected ETHERNET MAC address is used to compare with the SA fields of the
;;;916           received frame. */
;;;917        (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA;
00047e  4410              ADD      r0,r0,r2
;;;918      }
;;;919      else
;;;920      {
;;;921        /* The selected ETHERNET MAC address is used to compare with the DA fields of the
;;;922           received frame. */
;;;923        (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_SA);
000480  6c01              LDR      r1,[r0,#0x40]
000482  d01f              BEQ      |L1.1220|
000484  f0414180          ORR      r1,r1,#0x40000000     ;917
000488  e01e              B        |L1.1224|
00048a  0000              DCW      0x0000
                  |L1.1164|
                          DCD      0x40028000
                  |L1.1168|
                          DCD      0x00013fff
                  |L1.1172|
                          DCD      0xfeced300
                  |L1.1176|
                          DCD      0x00e4e1c0
                  |L1.1180|
                          DCD      0xfde9f140
                  |L1.1184|
                          DCD      0x017d7840
                  |L1.1188|
                          DCD      0xfc6c7900
                  |L1.1192|
                          DCD      0x02625a00
                  |L1.1196|
                          DCD      0xfa0a1f00
                  |L1.1200|
                          DCD      0x02faf080
                  |L1.1204|
                          DCD      0x000fffff
                  |L1.1208|
                          DCD      0xff20810f
                  |L1.1212|
                          DCD      0x40029000
                  |L1.1216|
                          DCD      0xf8de3f23
                  |L1.1220|
0004c4  f0214180          BIC      r1,r1,#0x40000000
                  |L1.1224|
0004c8  6401              STR      r1,[r0,#0x40]         ;917
;;;924      }
;;;925    }
0004ca  4770              BX       lr
;;;926    
                          ENDP

                  ETH_MACAddressMaskBytesFilterConfig PROC
;;;944      */
;;;945    void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte)
0004cc  4af8              LDR      r2,|L1.2224|
;;;946    {
;;;947      /* Check the parameters */
;;;948      assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
;;;949      assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte));
;;;950      
;;;951      /* Clear MBC bits in the selected MAC address  high register */
;;;952      (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_MBC);
0004ce  4410              ADD      r0,r0,r2
0004d0  6c02              LDR      r2,[r0,#0x40]
0004d2  f022527c          BIC      r2,r2,#0x3f000000
0004d6  6402              STR      r2,[r0,#0x40]
;;;953      /* Set the selected Filter mask bytes */
;;;954      (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte;
0004d8  6c02              LDR      r2,[r0,#0x40]
0004da  430a              ORRS     r2,r2,r1
0004dc  6402              STR      r2,[r0,#0x40]
;;;955    }
0004de  4770              BX       lr
;;;956    
                          ENDP

                  ETH_Get_Received_Frame PROC
;;;969    uint32_t  dkf_addr;
;;;970    FrameTypeDef ETH_Get_Received_Frame(void)
0004e0  b570              PUSH     {r4-r6,lr}
;;;971    { 
;;;972      uint32_t framelength = 0;
;;;973      FrameTypeDef frame = {0,0,0}; 
;;;974      
;;;975      /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
;;;976      framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
0004e2  4bf4              LDR      r3,|L1.2228|
0004e4  6859              LDR      r1,[r3,#4]  ; DMARxDescToGet
0004e6  680a              LDR      r2,[r1,#0]
0004e8  f3c2440d          UBFX     r4,r2,#16,#14
;;;977      frame.length = framelength;
;;;978      
;;;979      /* Get the address of the buffer start address */ 
;;;980      /* Check if more than one segment in the frame */
;;;981      if (DMA_RX_FRAME_infos->Seg_Count >1)
0004ec  689a              LDR      r2,[r3,#8]  ; DMA_RX_FRAME_infos
0004ee  6896              LDR      r6,[r2,#8]
;;;982      {
;;;983        frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
;;;984    		 sdfdfsf[0]++;
0004f0  1f24              SUBS     r4,r4,#4
0004f2  f103050c          ADD      r5,r3,#0xc
0004f6  2e01              CMP      r6,#1                 ;981
0004f8  d905              BLS      |L1.1286|
0004fa  6812              LDR      r2,[r2,#0]            ;983
0004fc  6892              LDR      r2,[r2,#8]            ;983
0004fe  882e              LDRH     r6,[r5,#0]  ; sdfdfsf
000500  1c76              ADDS     r6,r6,#1
000502  802e              STRH     r6,[r5,#0]
000504  e005              B        |L1.1298|
                  |L1.1286|
;;;985      }
;;;986      else 
;;;987      {
;;;988        frame.buffer = DMARxDescToGet->Buffer1Addr;
000506  688a              LDR      r2,[r1,#8]
;;;989    		dkf_addr=DMARxDescToGet->Buffer1Addr;
000508  688e              LDR      r6,[r1,#8]
;;;990    		sdfdfsf[1]++;
00050a  611e              STR      r6,[r3,#0x10]  ; dkf_addr
00050c  886e              LDRH     r6,[r5,#2]  ; sdfdfsf
00050e  1c76              ADDS     r6,r6,#1
000510  806e              STRH     r6,[r5,#2]
                  |L1.1298|
;;;991      }
;;;992    
;;;993      frame.descriptor = DMARxDescToGet;
;;;994    	
;;;995      /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
;;;996      /* Chained Mode */    
;;;997      /* Selects the next DMA Rx descriptor list for next buffer to read */ 
;;;998      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
000512  68cd              LDR      r5,[r1,#0xc]
;;;999      
;;;1000     /* Return Frame */
;;;1001     return (frame);  
000514  605d              STR      r5,[r3,#4]  ; DMARxDescToGet
000516  6004              STR      r4,[r0,#0]
000518  e9c02101          STRD     r2,r1,[r0,#4]
;;;1002   }
00051c  bd70              POP      {r4-r6,pc}
;;;1003   
                          ENDP

                  ETH_Get_Received_Frame_interrupt PROC
;;;1011     */
;;;1012   FrameTypeDef ETH_Get_Received_Frame_interrupt(void)
00051e  b538              PUSH     {r3-r5,lr}
;;;1013   { 
;;;1014     FrameTypeDef frame={0,0,0};
;;;1015     __IO uint32_t descriptor_scan_counter = 0; 
;;;1016     
;;;1017     /* scan descriptors owned by CPU */
;;;1018     while (((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET)&&
;;;1019           (descriptor_scan_counter<ETH_RXBUFNB))
;;;1020     {
;;;1021       
;;;1022       /* Just by security */
;;;1023       descriptor_scan_counter++;
;;;1024       
;;;1025       /* check if first segment in frame */
;;;1026       if(((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
000520  4ce4              LDR      r4,|L1.2228|
000522  2300              MOVS     r3,#0                 ;1014
;;;1027         ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
;;;1028       {
;;;1029         DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
000524  9300              STR      r3,[sp,#0]
000526  e9d42101          LDRD     r2,r1,[r4,#4]         ;1013
00052a  e017              B        |L1.1372|
                  |L1.1324|
00052c  1c6d              ADDS     r5,r5,#1              ;1013
00052e  9500              STR      r5,[sp,#0]            ;1026
000530  6815              LDR      r5,[r2,#0]            ;1026
000532  05ad              LSLS     r5,r5,#22             ;1026
000534  d507              BPL      |L1.1350|
000536  6815              LDR      r5,[r2,#0]            ;1027
000538  05ed              LSLS     r5,r5,#23             ;1027
00053a  d404              BMI      |L1.1350|
00053c  600a              STR      r2,[r1,#0]
;;;1030         DMA_RX_FRAME_infos->Seg_Count = 1;   
00053e  2201              MOVS     r2,#1
000540  608a              STR      r2,[r1,#8]
;;;1031         DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
000542  6862              LDR      r2,[r4,#4]  ; DMARxDescToGet
000544  e008              B        |L1.1368|
                  |L1.1350|
;;;1032       }
;;;1033       
;;;1034       /* check if intermediate segment */
;;;1035       else if (((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET)&&
000546  6815              LDR      r5,[r2,#0]
000548  05ed              LSLS     r5,r5,#23
00054a  d411              BMI      |L1.1392|
;;;1036               ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET))
00054c  6815              LDR      r5,[r2,#0]
00054e  05ad              LSLS     r5,r5,#22
000550  d40e              BMI      |L1.1392|
;;;1037       {
;;;1038         (DMA_RX_FRAME_infos->Seg_Count) ++;
000552  688d              LDR      r5,[r1,#8]
000554  1c6d              ADDS     r5,r5,#1
000556  608d              STR      r5,[r1,#8]
                  |L1.1368|
;;;1039         DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
000558  68d2              LDR      r2,[r2,#0xc]
00055a  6062              STR      r2,[r4,#4]  ; DMARxDescToGet
                  |L1.1372|
00055c  6815              LDR      r5,[r2,#0]            ;1018
00055e  2d00              CMP      r5,#0                 ;1018
000560  db02              BLT      |L1.1384|
000562  9d00              LDR      r5,[sp,#0]            ;1019
000564  2d05              CMP      r5,#5                 ;1019
000566  d3e1              BCC      |L1.1324|
                  |L1.1384|
;;;1040       }
;;;1041   
;;;1042       /* should be last segment */
;;;1043       else
;;;1044       { 
;;;1045         /* last segment */
;;;1046         DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
;;;1047         
;;;1048         (DMA_RX_FRAME_infos->Seg_Count)++;
;;;1049           
;;;1050         /* first segment is last segment */
;;;1051         if ((DMA_RX_FRAME_infos->Seg_Count)==1)
;;;1052           DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
;;;1053         
;;;1054         /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
;;;1055         frame.length = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
;;;1056   
;;;1057     
;;;1058         /* Get the address of the buffer start address */ 
;;;1059         /* Check if more than one segment in the frame */
;;;1060         if (DMA_RX_FRAME_infos->Seg_Count >1)
;;;1061         {
;;;1062           frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
;;;1063         }
;;;1064         else 
;;;1065         {
;;;1066           frame.buffer = DMARxDescToGet->Buffer1Addr;
;;;1067         }
;;;1068         
;;;1069         frame.descriptor = DMARxDescToGet;
;;;1070     
;;;1071         /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
;;;1072         DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
;;;1073        
;;;1074         /* Return Frame */
;;;1075         return (frame);  
;;;1076       }
;;;1077     }
;;;1078     return (frame); 
000568  6003              STR      r3,[r0,#0]
00056a  6043              STR      r3,[r0,#4]
00056c  6083              STR      r3,[r0,#8]
;;;1079   }
00056e  bd38              POP      {r3-r5,pc}
                  |L1.1392|
000570  604a              STR      r2,[r1,#4]            ;1046
000572  688b              LDR      r3,[r1,#8]            ;1048
000574  1c5b              ADDS     r3,r3,#1              ;1048
000576  608b              STR      r3,[r1,#8]            ;1048
000578  688b              LDR      r3,[r1,#8]            ;1051
00057a  2b01              CMP      r3,#1                 ;1051
00057c  d100              BNE      |L1.1408|
00057e  600a              STR      r2,[r1,#0]            ;1052
                  |L1.1408|
000580  6862              LDR      r2,[r4,#4]            ;1055  ; DMARxDescToGet
000582  6813              LDR      r3,[r2,#0]            ;1055
000584  688d              LDR      r5,[r1,#8]            ;1060
000586  f3c3430d          UBFX     r3,r3,#16,#14         ;1055
00058a  1f1b              SUBS     r3,r3,#4              ;1060
00058c  2d01              CMP      r5,#1                 ;1060
00058e  d902              BLS      |L1.1430|
000590  6809              LDR      r1,[r1,#0]            ;1062
000592  6889              LDR      r1,[r1,#8]            ;1062
000594  e000              B        |L1.1432|
                  |L1.1430|
000596  6891              LDR      r1,[r2,#8]            ;1066
                  |L1.1432|
000598  68d5              LDR      r5,[r2,#0xc]          ;1072
00059a  6065              STR      r5,[r4,#4]            ;1075  ; DMARxDescToGet
00059c  6003              STR      r3,[r0,#0]            ;1075
00059e  e9c01201          STRD     r1,r2,[r0,#4]         ;1075
0005a2  bd38              POP      {r3-r5,pc}
;;;1080         
                          ENDP

                  ETH_Prepare_Transmit_Descriptors PROC
;;;1086     */
;;;1087   uint32_t ETH_Prepare_Transmit_Descriptors(u16 FrameLength)
0005a4  b5f0              PUSH     {r4-r7,lr}
;;;1088   {   
;;;1089     uint32_t buf_count =0, size=0,i=0;
;;;1090     __IO ETH_DMADESCTypeDef *DMATxNextDesc;
;;;1091     
;;;1092     /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
;;;1093     if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
0005a6  4cc3              LDR      r4,|L1.2228|
0005a8  2200              MOVS     r2,#0                 ;1089
0005aa  6821              LDR      r1,[r4,#0]  ; DMATxDescToSet
0005ac  680b              LDR      r3,[r1,#0]
0005ae  2b00              CMP      r3,#0
0005b0  da01              BGE      |L1.1462|
;;;1094     {  
;;;1095       /* Return ERROR: OWN bit set */
;;;1096       return ETH_ERROR;
0005b2  2000              MOVS     r0,#0
;;;1097     }
;;;1098     
;;;1099     DMATxNextDesc = DMATxDescToSet;
;;;1100     
;;;1101     if (FrameLength > ETH_TX_BUF_SIZE)
;;;1102     {
;;;1103       buf_count = FrameLength/ETH_TX_BUF_SIZE;
;;;1104       if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
;;;1105     }
;;;1106     else buf_count =1;
;;;1107     
;;;1108     if (buf_count ==1)
;;;1109     {
;;;1110       /*set LAST and FIRST segment */
;;;1111       DMATxDescToSet->Status |=ETH_DMATxDesc_FS|ETH_DMATxDesc_LS;
;;;1112       /* Set frame size */
;;;1113       DMATxDescToSet->ControlBufferSize = (FrameLength& ETH_DMATxDesc_TBS1);
;;;1114       /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
;;;1115       DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
;;;1116       DMATxDescToSet= (ETH_DMADESCTypeDef *)(DMATxDescToSet->Buffer2NextDescAddr);
;;;1117     }
;;;1118     else
;;;1119     {
;;;1120       for (i=0; i< buf_count; i++)
;;;1121       {
;;;1122         if (i==0) 
;;;1123         {
;;;1124           /* Setting the first segment bit */
;;;1125           DMATxDescToSet->Status |= ETH_DMATxDesc_FS;  
;;;1126         }
;;;1127         
;;;1128         /* Program size */
;;;1129         DMATxNextDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
;;;1130          
;;;1131         if (i== (buf_count-1))
;;;1132         {
;;;1133           /* Setting the last segment bit */
;;;1134           DMATxNextDesc->Status |= ETH_DMATxDesc_LS;
;;;1135           size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
;;;1136           DMATxNextDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
;;;1137         }
;;;1138           
;;;1139         /*give back descriptor to DMA */
;;;1140         DMATxNextDesc->Status |= ETH_DMATxDesc_OWN;
;;;1141         
;;;1142         DMATxNextDesc = (ETH_DMADESCTypeDef *)(DMATxNextDesc->Buffer2NextDescAddr);
;;;1143         /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
;;;1144        }
;;;1145       DMATxDescToSet = DMATxNextDesc ;
;;;1146     }
;;;1147       
;;;1148     /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
;;;1149     if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
;;;1150     {
;;;1151       /* Clear TBUS ETHERNET DMA flag */
;;;1152       ETH->DMASR = ETH_DMASR_TBUS;
;;;1153       /* Resume DMA transmission*/
;;;1154       ETH->DMATPDR = 0;
;;;1155     }
;;;1156     
;;;1157     /* Return SUCCESS */
;;;1158     return ETH_SUCCESS;   
;;;1159   }
0005b4  bdf0              POP      {r4-r7,pc}
                  |L1.1462|
0005b6  f24055f4          MOV      r5,#0x5f4             ;1101
0005ba  42a8              CMP      r0,r5                 ;1101
0005bc  d915              BLS      |L1.1514|
0005be  fbb0f6f5          UDIV     r6,r0,r5              ;1104
0005c2  fbb0f3f5          UDIV     r3,r0,r5              ;1103
0005c6  fb050616          MLS      r6,r5,r6,r0           ;1104
0005ca  b106              CBZ      r6,|L1.1486|
0005cc  1c5b              ADDS     r3,r3,#1              ;1104
                  |L1.1486|
0005ce  2b01              CMP      r3,#1                 ;1108
0005d0  d00b              BEQ      |L1.1514|
0005d2  f1c30701          RSB      r7,r3,#1              ;1135
0005d6  ebc717c7          RSB      r7,r7,r7,LSL #7       ;1135
0005da  eb070747          ADD      r7,r7,r7,LSL #1       ;1135
0005de  eb000087          ADD      r0,r0,r7,LSL #2       ;1135
0005e2  1e5e              SUBS     r6,r3,#1              ;1131
0005e4  f3c0070c          UBFX     r7,r0,#0,#13          ;1136
0005e8  e023              B        |L1.1586|
                  |L1.1514|
0005ea  680a              LDR      r2,[r1,#0]            ;1111
0005ec  f0425240          ORR      r2,r2,#0x30000000     ;1111
0005f0  600a              STR      r2,[r1,#0]            ;1111
0005f2  f3c0000c          UBFX     r0,r0,#0,#13          ;1113
0005f6  6048              STR      r0,[r1,#4]            ;1113
0005f8  6808              LDR      r0,[r1,#0]            ;1115
0005fa  f0404000          ORR      r0,r0,#0x80000000     ;1115
0005fe  6008              STR      r0,[r1,#0]            ;1115
000600  68c8              LDR      r0,[r1,#0xc]          ;1116
000602  6020              STR      r0,[r4,#0]            ;1116  ; DMATxDescToSet
000604  e018              B        |L1.1592|
                  |L1.1542|
000606  b932              CBNZ     r2,|L1.1558|
000608  6820              LDR      r0,[r4,#0]            ;1125  ; DMATxDescToSet
00060a  f8d0c000          LDR      r12,[r0,#0]           ;1125
00060e  f04c5c80          ORR      r12,r12,#0x10000000   ;1125
000612  f8c0c000          STR      r12,[r0,#0]           ;1125
                  |L1.1558|
000616  604d              STR      r5,[r1,#4]            ;1129
000618  42b2              CMP      r2,r6                 ;1131
00061a  d104              BNE      |L1.1574|
00061c  6808              LDR      r0,[r1,#0]            ;1134
00061e  f0405000          ORR      r0,r0,#0x20000000     ;1134
000622  6008              STR      r0,[r1,#0]            ;1134
000624  604f              STR      r7,[r1,#4]            ;1136
                  |L1.1574|
000626  6808              LDR      r0,[r1,#0]            ;1140
000628  f0404000          ORR      r0,r0,#0x80000000     ;1140
00062c  6008              STR      r0,[r1,#0]            ;1140
00062e  68c9              LDR      r1,[r1,#0xc]          ;1142
000630  1c52              ADDS     r2,r2,#1              ;1142
                  |L1.1586|
000632  429a              CMP      r2,r3                 ;1120
000634  d3e7              BCC      |L1.1542|
000636  6021              STR      r1,[r4,#0]            ;1145  ; DMATxDescToSet
                  |L1.1592|
000638  489f              LDR      r0,|L1.2232|
00063a  6941              LDR      r1,[r0,#0x14]         ;1149
00063c  0749              LSLS     r1,r1,#29             ;1149
00063e  d503              BPL      |L1.1608|
000640  2104              MOVS     r1,#4                 ;1152
000642  6141              STR      r1,[r0,#0x14]         ;1152
000644  2100              MOVS     r1,#0                 ;1154
000646  6041              STR      r1,[r0,#4]            ;1154
                  |L1.1608|
000648  2001              MOVS     r0,#1                 ;1158
00064a  bdf0              POP      {r4-r7,pc}
;;;1160   
                          ENDP

                  ETH_DMARxDescChainInit PROC
;;;1168     */
;;;1169   void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
00064c  b5f0              PUSH     {r4-r7,lr}
;;;1170   {
;;;1171     uint32_t i = 0;
;;;1172     ETH_DMADESCTypeDef *DMARxDesc;
;;;1173     
;;;1174     /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
;;;1175     DMARxDescToGet = DMARxDescTab; 
00064e  4f99              LDR      r7,|L1.2228|
000650  2300              MOVS     r3,#0                 ;1171
;;;1176     /* Fill each DMARxDesc descriptor with the right values */
;;;1177     for(i=0; i < RxBuffCount; i++)
;;;1178     {
;;;1179       /* Get the pointer on the ith member of the Rx Desc list */
;;;1180       DMARxDesc = DMARxDescTab+i;
;;;1181       /* Set Own bit of the Rx descriptor Status */
;;;1182       DMARxDesc->Status = ETH_DMARxDesc_OWN;
000652  f04f4c00          MOV      r12,#0x80000000
;;;1183   
;;;1184       /* Set Buffer1 size and Second Address Chained bit */
;;;1185       DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
000656  f2445ef4          MOV      lr,#0x45f4
;;;1186       /* Set Buffer1 address pointer */
;;;1187       DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
;;;1188       
;;;1189       /* Initialize the next descriptor with the Next Descriptor Polling Enable */
;;;1190       if(i < (RxBuffCount-1))
00065a  1e56              SUBS     r6,r2,#1
00065c  6078              STR      r0,[r7,#4]            ;1170  ; DMARxDescToGet
00065e  e013              B        |L1.1672|
                  |L1.1632|
000660  eb001443          ADD      r4,r0,r3,LSL #5       ;1180
000664  f8c4c000          STR      r12,[r4,#0]           ;1182
000668  ebc315c3          RSB      r5,r3,r3,LSL #7       ;1187
00066c  eb050545          ADD      r5,r5,r5,LSL #1       ;1187
000670  eb010585          ADD      r5,r1,r5,LSL #2       ;1187
000674  e9c4e501          STRD     lr,r5,[r4,#4]
000678  42b3              CMP      r3,r6
00067a  d203              BCS      |L1.1668|
;;;1191       {
;;;1192         /* Set next descriptor address register with next descriptor base address */
;;;1193         DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
00067c  f1040520          ADD      r5,r4,#0x20
000680  60e5              STR      r5,[r4,#0xc]
000682  e000              B        |L1.1670|
                  |L1.1668|
;;;1194       }
;;;1195       else
;;;1196       {
;;;1197         /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
;;;1198         DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
000684  60e0              STR      r0,[r4,#0xc]
                  |L1.1670|
000686  1c5b              ADDS     r3,r3,#1
                  |L1.1672|
000688  4293              CMP      r3,r2                 ;1177
00068a  d3e9              BCC      |L1.1632|
;;;1199       }
;;;1200     }
;;;1201      
;;;1202     /* Set Receive Descriptor List Address Register */
;;;1203     ETH->DMARDLAR = (uint32_t) DMARxDescTab; 
00068c  498a              LDR      r1,|L1.2232|
00068e  60c8              STR      r0,[r1,#0xc]
;;;1204     
;;;1205   
;;;1206     DMA_RX_FRAME_infos = &RX_Frame_Descriptor;
000690  488a              LDR      r0,|L1.2236|
000692  60b8              STR      r0,[r7,#8]  ; DMA_RX_FRAME_infos
;;;1207   
;;;1208   }
000694  bdf0              POP      {r4-r7,pc}
;;;1209   
                          ENDP

                  ETH_CheckFrameReceived PROC
;;;1214     */
;;;1215   uint32_t ETH_CheckFrameReceived(void)
000696  4a87              LDR      r2,|L1.2228|
;;;1216   { 
;;;1217     /* check if last segment */
;;;1218     if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
000698  6850              LDR      r0,[r2,#4]  ; DMARxDescToGet
00069a  6803              LDR      r3,[r0,#0]
00069c  4611              MOV      r1,r2
00069e  2b00              CMP      r3,#0
;;;1219        ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
;;;1220       {   
;;;1221         DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
0006a0  6889              LDR      r1,[r1,#8]
0006a2  db08              BLT      |L1.1718|
0006a4  6803              LDR      r3,[r0,#0]            ;1219
0006a6  05db              LSLS     r3,r3,#23             ;1219
0006a8  d505              BPL      |L1.1718|
0006aa  6048              STR      r0,[r1,#4]
;;;1222         DMA_RX_FRAME_infos->Seg_Count++;
0006ac  6888              LDR      r0,[r1,#8]
0006ae  1c40              ADDS     r0,r0,#1
0006b0  6088              STR      r0,[r1,#8]
;;;1223         return 1;
0006b2  2001              MOVS     r0,#1
;;;1224       }
;;;1225     
;;;1226       /* check if first segment */
;;;1227       else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
;;;1228        ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
;;;1229        ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))      
;;;1230       {
;;;1231         DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
;;;1232         DMA_RX_FRAME_infos->LS_Rx_Desc = NULL;
;;;1233         DMA_RX_FRAME_infos->Seg_Count = 1;   
;;;1234         DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
;;;1235       }
;;;1236       
;;;1237       /* check if intermediate segment */ 
;;;1238       else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
;;;1239        ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
;;;1240        ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
;;;1241       {
;;;1242         (DMA_RX_FRAME_infos->Seg_Count) ++;
;;;1243         DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
;;;1244       } 
;;;1245       return 0;
;;;1246   }
0006b4  4770              BX       lr
                  |L1.1718|
0006b6  6803              LDR      r3,[r0,#0]            ;1227
0006b8  2b00              CMP      r3,#0                 ;1227
0006ba  db0c              BLT      |L1.1750|
0006bc  6803              LDR      r3,[r0,#0]            ;1228
0006be  059b              LSLS     r3,r3,#22             ;1228
0006c0  d509              BPL      |L1.1750|
0006c2  6803              LDR      r3,[r0,#0]            ;1229
0006c4  05db              LSLS     r3,r3,#23             ;1229
0006c6  d406              BMI      |L1.1750|
0006c8  6008              STR      r0,[r1,#0]            ;1231
0006ca  2000              MOVS     r0,#0                 ;1232
0006cc  6048              STR      r0,[r1,#4]            ;1232
0006ce  2001              MOVS     r0,#1                 ;1233
0006d0  6088              STR      r0,[r1,#8]            ;1233
0006d2  6850              LDR      r0,[r2,#4]            ;1234  ; DMARxDescToGet
0006d4  e00b              B        |L1.1774|
                  |L1.1750|
0006d6  6803              LDR      r3,[r0,#0]            ;1238
0006d8  2b00              CMP      r3,#0                 ;1238
0006da  db0a              BLT      |L1.1778|
0006dc  6803              LDR      r3,[r0,#0]            ;1239
0006de  059b              LSLS     r3,r3,#22             ;1239
0006e0  d407              BMI      |L1.1778|
0006e2  6803              LDR      r3,[r0,#0]            ;1240
0006e4  05db              LSLS     r3,r3,#23             ;1240
0006e6  d404              BMI      |L1.1778|
0006e8  688b              LDR      r3,[r1,#8]            ;1242
0006ea  1c5b              ADDS     r3,r3,#1              ;1242
0006ec  608b              STR      r3,[r1,#8]            ;1242
                  |L1.1774|
0006ee  68c0              LDR      r0,[r0,#0xc]          ;1243
0006f0  6050              STR      r0,[r2,#4]            ;1243  ; DMARxDescToGet
                  |L1.1778|
0006f2  2000              MOVS     r0,#0                 ;1245
0006f4  4770              BX       lr
;;;1247   
                          ENDP

                  ETH_DMATxDescChainInit PROC
;;;1256     */
;;;1257   void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
0006f6  b5f0              PUSH     {r4-r7,lr}
;;;1258   {
;;;1259     uint32_t i = 0;
;;;1260     ETH_DMADESCTypeDef *DMATxDesc;
;;;1261     
;;;1262     /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
;;;1263     DMATxDescToSet = DMATxDescTab;
0006f8  4c6e              LDR      r4,|L1.2228|
0006fa  2300              MOVS     r3,#0                 ;1259
;;;1264     /* Fill each DMATxDesc descriptor with the right values */   
;;;1265     for(i=0; i < TxBuffCount; i++)
;;;1266     {
;;;1267       /* Get the pointer on the ith member of the Tx Desc list */
;;;1268       DMATxDesc = DMATxDescTab + i;
;;;1269       /* Set Second Address Chained bit */
;;;1270       DMATxDesc->Status = ETH_DMATxDesc_TCH;  
0006fc  f44f1780          MOV      r7,#0x100000
;;;1271          
;;;1272       /* Set Buffer1 address pointer */
;;;1273       DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
;;;1274       
;;;1275       /* Initialize the next descriptor with the Next Descriptor Polling Enable */
;;;1276       if(i < (TxBuffCount-1))
000700  1e56              SUBS     r6,r2,#1
000702  6020              STR      r0,[r4,#0]            ;1258  ; DMATxDescToSet
000704  e011              B        |L1.1834|
                  |L1.1798|
000706  eb001443          ADD      r4,r0,r3,LSL #5       ;1268
00070a  6027              STR      r7,[r4,#0]            ;1270
00070c  ebc315c3          RSB      r5,r3,r3,LSL #7       ;1273
000710  eb050545          ADD      r5,r5,r5,LSL #1       ;1273
000714  eb010585          ADD      r5,r1,r5,LSL #2       ;1273
000718  60a5              STR      r5,[r4,#8]
00071a  42b3              CMP      r3,r6
00071c  d203              BCS      |L1.1830|
;;;1277       {
;;;1278         /* Set next descriptor address register with next descriptor base address */
;;;1279         DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
00071e  f1040520          ADD      r5,r4,#0x20
000722  60e5              STR      r5,[r4,#0xc]
000724  e000              B        |L1.1832|
                  |L1.1830|
;;;1280       }
;;;1281       else
;;;1282       {
;;;1283         /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
;;;1284         DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
000726  60e0              STR      r0,[r4,#0xc]
                  |L1.1832|
000728  1c5b              ADDS     r3,r3,#1
                  |L1.1834|
00072a  4293              CMP      r3,r2                 ;1265
00072c  d3eb              BCC      |L1.1798|
;;;1285       }
;;;1286     }
;;;1287      
;;;1288     /* Set Transmit Desciptor List Address Register */
;;;1289     ETH->DMATDLAR = (uint32_t) DMATxDescTab;
00072e  4962              LDR      r1,|L1.2232|
000730  6108              STR      r0,[r1,#0x10]
;;;1290   }
000732  bdf0              POP      {r4-r7,pc}
;;;1291   
                          ENDP

                  ETH_GetDMATxDescFlagStatus PROC
;;;1326     */
;;;1327   FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag)
000734  4602              MOV      r2,r0
;;;1328   {
;;;1329     FlagStatus bitstatus = RESET;
000736  2000              MOVS     r0,#0
;;;1330     /* Check the parameters */
;;;1331     assert_param(IS_ETH_DMATxDESC_GET_FLAG(ETH_DMATxDescFlag));
;;;1332     
;;;1333     if ((DMATxDesc->Status & ETH_DMATxDescFlag) != (uint32_t)RESET)
000738  6812              LDR      r2,[r2,#0]
00073a  420a              TST      r2,r1
00073c  d000              BEQ      |L1.1856|
;;;1334     {
;;;1335       bitstatus = SET;
00073e  2001              MOVS     r0,#1
                  |L1.1856|
;;;1336     }
;;;1337     else
;;;1338     {
;;;1339       bitstatus = RESET;
;;;1340     }
;;;1341     return bitstatus;
;;;1342   }
000740  4770              BX       lr
;;;1343   
                          ENDP

                  ETH_GetDMATxDescCollisionCount PROC
;;;1348     */
;;;1349   uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc)
000742  6800              LDR      r0,[r0,#0]
;;;1350   {
;;;1351     /* Return the Receive descriptor frame length */
;;;1352     return ((DMATxDesc->Status & ETH_DMATxDesc_CC) >> ETH_DMATXDESC_COLLISION_COUNTSHIFT);
000744  f3c000c3          UBFX     r0,r0,#3,#4
;;;1353   }
000748  4770              BX       lr
;;;1354   
                          ENDP

                  ETH_SetDMATxDescOwnBit PROC
;;;1359     */
;;;1360   void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc)
00074a  6801              LDR      r1,[r0,#0]
;;;1361   {
;;;1362     /* Set the DMA Tx Desc Own bit */
;;;1363     DMATxDesc->Status |= ETH_DMATxDesc_OWN;
00074c  f0414100          ORR      r1,r1,#0x80000000
000750  6001              STR      r1,[r0,#0]
;;;1364   }
000752  4770              BX       lr
;;;1365   
                          ENDP

                  ETH_DMATxDescTransmitITConfig PROC
;;;1372     */
;;;1373   void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
000754  2900              CMP      r1,#0
;;;1374   {
;;;1375     /* Check the parameters */
;;;1376     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1377     
;;;1378     if (NewState != DISABLE)
;;;1379     {
;;;1380       /* Enable the DMA Tx Desc Transmit interrupt */
;;;1381       DMATxDesc->Status |= ETH_DMATxDesc_IC;
;;;1382     }
;;;1383     else
;;;1384     {
;;;1385       /* Disable the DMA Tx Desc Transmit interrupt */
;;;1386       DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_IC);
000756  6801              LDR      r1,[r0,#0]
000758  d002              BEQ      |L1.1888|
00075a  f0414180          ORR      r1,r1,#0x40000000     ;1381
00075e  e001              B        |L1.1892|
                  |L1.1888|
000760  f0214180          BIC      r1,r1,#0x40000000
                  |L1.1892|
000764  6001              STR      r1,[r0,#0]            ;1381
;;;1387     }
;;;1388   }
000766  4770              BX       lr
;;;1389   
                          ENDP

                  ETH_DMATxDescFrameSegmentConfig PROC
;;;1398     */
;;;1399   void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment)
000768  6802              LDR      r2,[r0,#0]
;;;1400   {
;;;1401     /* Check the parameters */
;;;1402     assert_param(IS_ETH_DMA_TXDESC_SEGMENT(DMATxDesc_FrameSegment));
;;;1403     
;;;1404     /* Selects the DMA Tx Desc Frame segment */
;;;1405     DMATxDesc->Status |= DMATxDesc_FrameSegment;
00076a  430a              ORRS     r2,r2,r1
00076c  6002              STR      r2,[r0,#0]
;;;1406   }
00076e  4770              BX       lr
;;;1407   
                          ENDP

                  ETH_DMATxDescChecksumInsertionConfig PROC
;;;1418     */
;;;1419   void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum)
000770  6802              LDR      r2,[r0,#0]
;;;1420   {
;;;1421     /* Check the parameters */
;;;1422     assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum));
;;;1423     
;;;1424     /* Set the selected DMA Tx desc checksum insertion control */
;;;1425     DMATxDesc->Status |= DMATxDesc_Checksum;
000772  430a              ORRS     r2,r2,r1
000774  6002              STR      r2,[r0,#0]
;;;1426   }
000776  4770              BX       lr
;;;1427   
                          ENDP

                  ETH_DMATxDescCRCCmd PROC
;;;1434     */
;;;1435   void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
000778  2900              CMP      r1,#0
;;;1436   {
;;;1437     /* Check the parameters */
;;;1438     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1439     
;;;1440     if (NewState != DISABLE)
;;;1441     {
;;;1442       /* Enable the selected DMA Tx Desc CRC */
;;;1443       DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DC);
;;;1444     }
;;;1445     else
;;;1446     {
;;;1447       /* Disable the selected DMA Tx Desc CRC */
;;;1448       DMATxDesc->Status |= ETH_DMATxDesc_DC; 
00077a  6801              LDR      r1,[r0,#0]
00077c  d002              BEQ      |L1.1924|
00077e  f0216100          BIC      r1,r1,#0x8000000      ;1443
000782  e001              B        |L1.1928|
                  |L1.1924|
000784  f0416100          ORR      r1,r1,#0x8000000
                  |L1.1928|
000788  6001              STR      r1,[r0,#0]            ;1443
;;;1449     }
;;;1450   }
00078a  4770              BX       lr
;;;1451   
                          ENDP

                  ETH_DMATxDescSecondAddressChainedCmd PROC
;;;1459     */
;;;1460   void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
00078c  2900              CMP      r1,#0
;;;1461   {
;;;1462     /* Check the parameters */
;;;1463     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1464     
;;;1465     if (NewState != DISABLE)
;;;1466     {
;;;1467       /* Enable the selected DMA Tx Desc second address chained */
;;;1468       DMATxDesc->Status |= ETH_DMATxDesc_TCH;  
;;;1469     }
;;;1470     else
;;;1471     {
;;;1472       /* Disable the selected DMA Tx Desc second address chained */
;;;1473       DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_TCH); 
00078e  6801              LDR      r1,[r0,#0]
000790  d002              BEQ      |L1.1944|
000792  f4411180          ORR      r1,r1,#0x100000       ;1468
000796  e001              B        |L1.1948|
                  |L1.1944|
000798  f4211180          BIC      r1,r1,#0x100000
                  |L1.1948|
00079c  6001              STR      r1,[r0,#0]            ;1468
;;;1474     }
;;;1475   }
00079e  4770              BX       lr
;;;1476   
                          ENDP

                  ETH_DMATxDescShortFramePaddingCmd PROC
;;;1483     */
;;;1484   void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
0007a0  2900              CMP      r1,#0
;;;1485   {
;;;1486     /* Check the parameters */
;;;1487     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1488     
;;;1489     if (NewState != DISABLE)
;;;1490     {
;;;1491       /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */
;;;1492       DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DP);
;;;1493     }
;;;1494     else
;;;1495     {
;;;1496       /* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/
;;;1497       DMATxDesc->Status |= ETH_DMATxDesc_DP; 
0007a2  6801              LDR      r1,[r0,#0]
0007a4  d002              BEQ      |L1.1964|
0007a6  f0216180          BIC      r1,r1,#0x4000000      ;1492
0007aa  e001              B        |L1.1968|
                  |L1.1964|
0007ac  f0416180          ORR      r1,r1,#0x4000000
                  |L1.1968|
0007b0  6001              STR      r1,[r0,#0]            ;1492
;;;1498     }
;;;1499   }
0007b2  4770              BX       lr
;;;1500   
                          ENDP

                  ETH_DMATxDescBufferSizeConfig PROC
;;;1508     */
;;;1509   void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2)
0007b4  6843              LDR      r3,[r0,#4]
;;;1510   {
;;;1511     /* Check the parameters */
;;;1512     assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1));
;;;1513     assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2));
;;;1514     
;;;1515     /* Set the DMA Tx Desc buffer1 and buffer2 sizes values */
;;;1516     DMATxDesc->ControlBufferSize |= (BufferSize1 | (BufferSize2 << ETH_DMATXDESC_BUFFER2_SIZESHIFT));
0007b6  ea414102          ORR      r1,r1,r2,LSL #16
0007ba  430b              ORRS     r3,r3,r1
0007bc  6043              STR      r3,[r0,#4]
;;;1517   }
0007be  4770              BX       lr
;;;1518   
                          ENDP

                  ETH_GetDMARxDescFlagStatus PROC
;;;1544     */
;;;1545   FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag)
0007c0  4602              MOV      r2,r0
;;;1546   {
;;;1547     FlagStatus bitstatus = RESET;
0007c2  2000              MOVS     r0,#0
;;;1548     /* Check the parameters */
;;;1549     assert_param(IS_ETH_DMARxDESC_GET_FLAG(ETH_DMARxDescFlag));
;;;1550     if ((DMARxDesc->Status & ETH_DMARxDescFlag) != (uint32_t)RESET)
0007c4  6812              LDR      r2,[r2,#0]
0007c6  420a              TST      r2,r1
0007c8  d000              BEQ      |L1.1996|
;;;1551     {
;;;1552       bitstatus = SET;
0007ca  2001              MOVS     r0,#1
                  |L1.1996|
;;;1553     }
;;;1554     else
;;;1555     {
;;;1556       bitstatus = RESET;
;;;1557     }
;;;1558     return bitstatus;
;;;1559   }
0007cc  4770              BX       lr
;;;1560   
                          ENDP

                  ETH_GetDMAPTPRxDescExtendedFlagStatus PROC
;;;1577     */
;;;1578   FlagStatus ETH_GetDMAPTPRxDescExtendedFlagStatus(ETH_DMADESCTypeDef *DMAPTPRxDesc, uint32_t ETH_DMAPTPRxDescExtendedFlag)
0007ce  4602              MOV      r2,r0
;;;1579   {
;;;1580     FlagStatus bitstatus = RESET;
0007d0  2000              MOVS     r0,#0
;;;1581   
;;;1582     /* Check the parameters */
;;;1583     assert_param(IS_ETH_DMAPTPRxDESC_GET_EXTENDED_FLAG(ETH_DMAPTPRxDescExtendedFlag));
;;;1584   
;;;1585     if ((DMAPTPRxDesc->ExtendedStatus & ETH_DMAPTPRxDescExtendedFlag) != (uint32_t)RESET)
0007d2  6912              LDR      r2,[r2,#0x10]
0007d4  420a              TST      r2,r1
0007d6  d000              BEQ      |L1.2010|
;;;1586     {
;;;1587       bitstatus = SET;
0007d8  2001              MOVS     r0,#1
                  |L1.2010|
;;;1588     }
;;;1589     else
;;;1590     {
;;;1591       bitstatus = RESET;
;;;1592     }
;;;1593     return bitstatus;
;;;1594   }
0007da  4770              BX       lr
;;;1595   #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
                          ENDP

                  ETH_SetDMARxDescOwnBit PROC
;;;1601     */
;;;1602   void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc)
0007dc  6801              LDR      r1,[r0,#0]
;;;1603   {
;;;1604     /* Set the DMA Rx Desc Own bit */
;;;1605     DMARxDesc->Status |= ETH_DMARxDesc_OWN;
0007de  f0414100          ORR      r1,r1,#0x80000000
0007e2  6001              STR      r1,[r0,#0]
;;;1606   }
0007e4  4770              BX       lr
;;;1607   
                          ENDP

                  ETH_GetDMARxDescFrameLength PROC
;;;1612     */
;;;1613   uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc)
0007e6  6800              LDR      r0,[r0,#0]
;;;1614   {
;;;1615     /* Return the Receive descriptor frame length */
;;;1616     return ((DMARxDesc->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT);
0007e8  f3c0400d          UBFX     r0,r0,#16,#14
;;;1617   }
0007ec  4770              BX       lr
;;;1618   
                          ENDP

                  ETH_DMARxDescReceiveITConfig PROC
;;;1625     */
;;;1626   void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
0007ee  6842              LDR      r2,[r0,#4]
;;;1627   {
0007f0  b111              CBZ      r1,|L1.2040|
;;;1628     /* Check the parameters */
;;;1629     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1630     
;;;1631     if (NewState != DISABLE)
;;;1632     {
;;;1633       /* Enable the DMA Rx Desc receive interrupt */
;;;1634       DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_DIC);
0007f2  f0224100          BIC      r1,r2,#0x80000000
0007f6  e001              B        |L1.2044|
                  |L1.2040|
;;;1635     }
;;;1636     else
;;;1637     {
;;;1638       /* Disable the DMA Rx Desc receive interrupt */
;;;1639       DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_DIC;
0007f8  f0424100          ORR      r1,r2,#0x80000000
                  |L1.2044|
0007fc  6041              STR      r1,[r0,#4]            ;1634
;;;1640     }
;;;1641   }
0007fe  4770              BX       lr
;;;1642   
                          ENDP

                  ETH_GetDMARxDescBufferSize PROC
;;;1652     */
;;;1653   uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer)
000800  6840              LDR      r0,[r0,#4]
;;;1654   {
000802  b111              CBZ      r1,|L1.2058|
;;;1655     /* Check the parameters */
;;;1656     assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer));
;;;1657     
;;;1658     if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1)
;;;1659     {
;;;1660       /* Return the DMA Rx Desc buffer2 size */
;;;1661       return ((DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS2) >> ETH_DMARXDESC_BUFFER2_SIZESHIFT); 
000804  f3c0400c          UBFX     r0,r0,#16,#13
;;;1662     }
;;;1663     else
;;;1664     {
;;;1665       /* Return the DMA Rx Desc buffer1 size */
;;;1666       return (DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS1); 
;;;1667     }
;;;1668   }
000808  4770              BX       lr
                  |L1.2058|
00080a  f3c0000c          UBFX     r0,r0,#0,#13          ;1666
00080e  4770              BX       lr
;;;1669   
                          ENDP

                  ETH_GetRxPktSize PROC
;;;1675     */
;;;1676   uint32_t ETH_GetRxPktSize(ETH_DMADESCTypeDef *DMARxDesc)
000810  6802              LDR      r2,[r0,#0]
;;;1677   {
;;;1678     uint32_t frameLength = 0;
000812  2100              MOVS     r1,#0
;;;1679     if(((DMARxDesc->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
000814  2a00              CMP      r2,#0
000816  db08              BLT      |L1.2090|
;;;1680        ((DMARxDesc->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
000818  6802              LDR      r2,[r0,#0]
00081a  0412              LSLS     r2,r2,#16
00081c  d405              BMI      |L1.2090|
;;;1681        ((DMARxDesc->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
00081e  6802              LDR      r2,[r0,#0]
000820  05d2              LSLS     r2,r2,#23
000822  d502              BPL      |L1.2090|
000824  6800              LDR      r0,[r0,#0]
000826  f3c0410d          UBFX     r1,r0,#16,#14
                  |L1.2090|
;;;1682     {
;;;1683       /* Get the size of the packet: including 4 bytes of the CRC */
;;;1684       frameLength =  ETH_GetDMARxDescFrameLength(DMARxDesc);
;;;1685     }
;;;1686     
;;;1687     /* Return Frame Length */ 
;;;1688     return frameLength;
00082a  4608              MOV      r0,r1
;;;1689   }
00082c  4770              BX       lr
;;;1690   
                          ENDP

                  ETH_EnhancedDescriptorCmd PROC
;;;1697     */
;;;1698   void ETH_EnhancedDescriptorCmd(FunctionalState NewState)
00082e  4922              LDR      r1,|L1.2232|
;;;1699   { 
;;;1700     /* Check the parameters */
;;;1701     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1702     
;;;1703     if (NewState != DISABLE)
000830  2800              CMP      r0,#0
;;;1704     {
;;;1705       /* Enable enhanced descriptor structure */
;;;1706       ETH->DMABMR |= ETH_DMABMR_EDE;  
;;;1707     }
;;;1708     else
;;;1709     {
;;;1710       /* Disable enhanced descriptor structure */
;;;1711       ETH->DMABMR &= ~ETH_DMABMR_EDE;
000832  6808              LDR      r0,[r1,#0]
000834  d002              BEQ      |L1.2108|
000836  f0400080          ORR      r0,r0,#0x80           ;1706
00083a  e001              B        |L1.2112|
                  |L1.2108|
00083c  f0200080          BIC      r0,r0,#0x80
                  |L1.2112|
000840  6008              STR      r0,[r1,#0]            ;1706
;;;1712     }
;;;1713   }
000842  4770              BX       lr
;;;1714   #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
                          ENDP

                  ETH_SoftwareReset PROC
;;;1723     */
;;;1724   void ETH_SoftwareReset(void)
000844  481c              LDR      r0,|L1.2232|
;;;1725   {
;;;1726     /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
;;;1727     /* After reset all the registers holds their respective reset values */
;;;1728     ETH->DMABMR |= ETH_DMABMR_SR;
000846  6801              LDR      r1,[r0,#0]
000848  f0410101          ORR      r1,r1,#1
00084c  6001              STR      r1,[r0,#0]
;;;1729   }
00084e  4770              BX       lr
;;;1730   
                          ENDP

                  ETH_GetSoftwareResetStatus PROC
;;;1735     */
;;;1736   FlagStatus ETH_GetSoftwareResetStatus(void)
000850  4919              LDR      r1,|L1.2232|
;;;1737   {
;;;1738     FlagStatus bitstatus = RESET;
000852  2000              MOVS     r0,#0
;;;1739     if((ETH->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
000854  6809              LDR      r1,[r1,#0]
000856  07c9              LSLS     r1,r1,#31
000858  d000              BEQ      |L1.2140|
;;;1740     {
;;;1741       bitstatus = SET;
00085a  2001              MOVS     r0,#1
                  |L1.2140|
;;;1742     }
;;;1743     else
;;;1744     {
;;;1745       bitstatus = RESET;
;;;1746     }
;;;1747     return bitstatus;
;;;1748   }
00085c  4770              BX       lr
;;;1749   
                          ENDP

                  ETH_GetDMAFlagStatus PROC
;;;1776     */
;;;1777   FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG)
00085e  4a16              LDR      r2,|L1.2232|
;;;1778   {  
000860  4601              MOV      r1,r0
;;;1779     FlagStatus bitstatus = RESET;
000862  2000              MOVS     r0,#0
;;;1780     /* Check the parameters */
;;;1781     assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_FLAG));
;;;1782     if ((ETH->DMASR & ETH_DMA_FLAG) != (uint32_t)RESET)
000864  6952              LDR      r2,[r2,#0x14]
000866  420a              TST      r2,r1
000868  d000              BEQ      |L1.2156|
;;;1783     {
;;;1784       bitstatus = SET;
00086a  2001              MOVS     r0,#1
                  |L1.2156|
;;;1785     }
;;;1786     else
;;;1787     {
;;;1788       bitstatus = RESET;
;;;1789     }
;;;1790     return bitstatus;
;;;1791   }
00086c  4770              BX       lr
;;;1792   
                          ENDP

                  ETH_DMAClearFlag PROC
;;;1813     */
;;;1814   void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG)
00086e  4912              LDR      r1,|L1.2232|
;;;1815   {
;;;1816     /* Check the parameters */
;;;1817     assert_param(IS_ETH_DMA_FLAG(ETH_DMA_FLAG));
;;;1818     
;;;1819     /* Clear the selected ETHERNET DMA FLAG */
;;;1820     ETH->DMASR = (uint32_t) ETH_DMA_FLAG;
000870  6148              STR      r0,[r1,#0x14]
;;;1821   }
000872  4770              BX       lr
;;;1822   
                          ENDP

                  ETH_DMAITConfig PROC
;;;1846     */
;;;1847   void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState)
000874  4a10              LDR      r2,|L1.2232|
;;;1848   {
;;;1849     /* Check the parameters */
;;;1850     assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
;;;1851     assert_param(IS_FUNCTIONAL_STATE(NewState));  
;;;1852     
;;;1853     if (NewState != DISABLE)
000876  2900              CMP      r1,#0
;;;1854     {
;;;1855       /* Enable the selected ETHERNET DMA interrupts */
;;;1856       ETH->DMAIER |= ETH_DMA_IT;
;;;1857     }
;;;1858     else
;;;1859     {
;;;1860       /* Disable the selected ETHERNET DMA interrupts */
;;;1861       ETH->DMAIER &=(~(uint32_t)ETH_DMA_IT);
000878  69d1              LDR      r1,[r2,#0x1c]
00087a  d001              BEQ      |L1.2176|
00087c  4301              ORRS     r1,r1,r0              ;1856
00087e  e000              B        |L1.2178|
                  |L1.2176|
000880  4381              BICS     r1,r1,r0
                  |L1.2178|
000882  61d1              STR      r1,[r2,#0x1c]         ;1856
;;;1862     }
;;;1863   }
000884  4770              BX       lr
;;;1864   
                          ENDP

                  ETH_GetDMAITStatus PROC
;;;1888     */
;;;1889   ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT)
000886  4a0c              LDR      r2,|L1.2232|
;;;1890   {  
000888  4601              MOV      r1,r0
;;;1891     ITStatus bitstatus = RESET;
00088a  2000              MOVS     r0,#0
;;;1892     /* Check the parameters */
;;;1893     assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_IT));
;;;1894     if ((ETH->DMASR & ETH_DMA_IT) != (uint32_t)RESET)
00088c  6952              LDR      r2,[r2,#0x14]
00088e  420a              TST      r2,r1
000890  d000              BEQ      |L1.2196|
;;;1895     {
;;;1896       bitstatus = SET;
000892  2001              MOVS     r0,#1
                  |L1.2196|
;;;1897     }
;;;1898     else
;;;1899     {
;;;1900       bitstatus = RESET;
;;;1901     }
;;;1902     return bitstatus;
;;;1903   }
000894  4770              BX       lr
;;;1904   
                          ENDP

                  ETH_DMAClearITPendingBit PROC
;;;1925     */
;;;1926   void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT)
000896  4908              LDR      r1,|L1.2232|
;;;1927   {
;;;1928     /* Check the parameters */
;;;1929     assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
;;;1930     
;;;1931     /* Clear the selected ETHERNET DMA IT */
;;;1932     ETH->DMASR = (uint32_t) ETH_DMA_IT;
000898  6148              STR      r0,[r1,#0x14]
;;;1933   }
00089a  4770              BX       lr
;;;1934   
                          ENDP

                  ETH_GetTransmitProcessState PROC
;;;1946     */
;;;1947   uint32_t ETH_GetTransmitProcessState(void)
00089c  4806              LDR      r0,|L1.2232|
;;;1948   {
;;;1949     return ((uint32_t)(ETH->DMASR & ETH_DMASR_TS)); 
00089e  6940              LDR      r0,[r0,#0x14]
0008a0  f0000001          AND      r0,r0,#1
;;;1950   }
0008a4  4770              BX       lr
;;;1951   
                          ENDP

                  ETH_GetReceiveProcessState PROC
;;;1963     */
;;;1964   uint32_t ETH_GetReceiveProcessState(void)
0008a6  4804              LDR      r0,|L1.2232|
;;;1965   {
;;;1966     return ((uint32_t)(ETH->DMASR & ETH_DMASR_RS)); 
0008a8  6940              LDR      r0,[r0,#0x14]
0008aa  f0000040          AND      r0,r0,#0x40
                  |L1.2222|
;;;1967   }
0008ae  4770              BX       lr
                  |L1.2224|
                          DCD      0x40028000
                  |L1.2228|
                          DCD      ||.data||
                  |L1.2232|
                          DCD      0x40029000
                  |L1.2236|
                          DCD      ||area_number.7||
                          ENDP

                  ETH_GetFlushTransmitFIFOStatus PROC
;;;1984     */
;;;1985   FlagStatus ETH_GetFlushTransmitFIFOStatus(void)
0008c0  4980              LDR      r1,|L1.2756|
;;;1986   {   
;;;1987     FlagStatus bitstatus = RESET;
0008c2  2000              MOVS     r0,#0
;;;1988     if ((ETH->DMAOMR & ETH_DMAOMR_FTF) != (uint32_t)RESET)
0008c4  6989              LDR      r1,[r1,#0x18]
0008c6  02c9              LSLS     r1,r1,#11
0008c8  d5f1              BPL      |L1.2222|
;;;1989     {
;;;1990       bitstatus = SET;
0008ca  2001              MOVS     r0,#1
;;;1991     }
;;;1992     else
;;;1993     {
;;;1994       bitstatus = RESET;
;;;1995     }
;;;1996     return bitstatus; 
;;;1997   }
0008cc  e7ef              B        |L1.2222|
;;;1998   
                          ENDP

                  ETH_GetDMAOverflowStatus PROC
;;;2052     */
;;;2053   FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow)
0008ce  4a7d              LDR      r2,|L1.2756|
;;;2054   {
0008d0  4601              MOV      r1,r0
;;;2055     FlagStatus bitstatus = RESET;
0008d2  2000              MOVS     r0,#0
;;;2056     /* Check the parameters */
;;;2057     assert_param(IS_ETH_DMA_GET_OVERFLOW(ETH_DMA_Overflow));
;;;2058     
;;;2059     if ((ETH->DMAMFBOCR & ETH_DMA_Overflow) != (uint32_t)RESET)
0008d4  6a12              LDR      r2,[r2,#0x20]
0008d6  420a              TST      r2,r1
0008d8  d0e9              BEQ      |L1.2222|
;;;2060     {
;;;2061       bitstatus = SET;
0008da  2001              MOVS     r0,#1
;;;2062     }
;;;2063     else
;;;2064     {
;;;2065       bitstatus = RESET;
;;;2066     }
;;;2067     return bitstatus;
;;;2068   }
0008dc  e7e7              B        |L1.2222|
;;;2069   
                          ENDP

                  ETH_GetRxOverflowMissedFrameCounter PROC
;;;2074     */
;;;2075   uint32_t ETH_GetRxOverflowMissedFrameCounter(void)
0008de  4879              LDR      r0,|L1.2756|
;;;2076   {
;;;2077     return ((uint32_t)((ETH->DMAMFBOCR & ETH_DMAMFBOCR_MFA)>>ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT));
0008e0  6a00              LDR      r0,[r0,#0x20]
0008e2  f3c0404a          UBFX     r0,r0,#17,#11
;;;2078   }
0008e6  e7e2              B        |L1.2222|
;;;2079   
                          ENDP

                  ETH_GetBufferUnavailableMissedFrameCounter PROC
;;;2084     */
;;;2085   uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void)
0008e8  4876              LDR      r0,|L1.2756|
;;;2086   {
;;;2087     return ((uint32_t)(ETH->DMAMFBOCR) & ETH_DMAMFBOCR_MFC);
0008ea  6a00              LDR      r0,[r0,#0x20]
0008ec  b280              UXTH     r0,r0
;;;2088   }
0008ee  e7de              B        |L1.2222|
;;;2089   
                          ENDP

                  ETH_GetCurrentTxDescStartAddress PROC
;;;2094     */
;;;2095   uint32_t ETH_GetCurrentTxDescStartAddress(void)
0008f0  4874              LDR      r0,|L1.2756|
;;;2096   {
;;;2097     return ((uint32_t)(ETH->DMACHTDR));
0008f2  6c80              LDR      r0,[r0,#0x48]
;;;2098   }
0008f4  e7db              B        |L1.2222|
;;;2099   
                          ENDP

                  ETH_GetCurrentRxDescStartAddress PROC
;;;2104     */
;;;2105   uint32_t ETH_GetCurrentRxDescStartAddress(void)
0008f6  4873              LDR      r0,|L1.2756|
;;;2106   {
;;;2107     return ((uint32_t)(ETH->DMACHRDR));
0008f8  6cc0              LDR      r0,[r0,#0x4c]
;;;2108   }
0008fa  e7d8              B        |L1.2222|
;;;2109   
                          ENDP

                  ETH_GetCurrentTxBufferAddress PROC
;;;2114     */
;;;2115   uint32_t ETH_GetCurrentTxBufferAddress(void)
0008fc  4871              LDR      r0,|L1.2756|
;;;2116   {
;;;2117     return ((uint32_t)(ETH->DMACHTBAR));
0008fe  6d00              LDR      r0,[r0,#0x50]
;;;2118   }
000900  e7d5              B        |L1.2222|
;;;2119   
                          ENDP

                  ETH_GetCurrentRxBufferAddress PROC
;;;2124     */
;;;2125   uint32_t ETH_GetCurrentRxBufferAddress(void)
000902  4870              LDR      r0,|L1.2756|
;;;2126   {
;;;2127     return ((uint32_t)(ETH->DMACHRBAR));
000904  6d40              LDR      r0,[r0,#0x54]
;;;2128   }
000906  e7d2              B        |L1.2222|
;;;2129   
                          ENDP

                  ETH_ResumeDMATransmission PROC
;;;2135     */
;;;2136   void ETH_ResumeDMATransmission(void)
000908  496e              LDR      r1,|L1.2756|
;;;2137   {
;;;2138     ETH->DMATPDR = 0;
00090a  2000              MOVS     r0,#0
00090c  6048              STR      r0,[r1,#4]
;;;2139   }
00090e  e7ce              B        |L1.2222|
;;;2140   
                          ENDP

                  ETH_ResumeDMAReception PROC
;;;2146     */
;;;2147   void ETH_ResumeDMAReception(void)
000910  496c              LDR      r1,|L1.2756|
;;;2148   {
;;;2149     ETH->DMARPDR = 0;
000912  2000              MOVS     r0,#0
000914  6088              STR      r0,[r1,#8]
;;;2150   }
000916  e7ca              B        |L1.2222|
;;;2151   
                          ENDP

                  ETH_SetReceiveWatchdogTimer PROC
;;;2156     */
;;;2157   void ETH_SetReceiveWatchdogTimer(uint8_t Value)
000918  496a              LDR      r1,|L1.2756|
;;;2158   {
;;;2159     /* Set the DMA Receive status watchdog timer register */
;;;2160     ETH->DMARSWTR = Value;
00091a  6248              STR      r0,[r1,#0x24]
;;;2161   }
00091c  e7c7              B        |L1.2222|
;;;2162   
                          ENDP

                  ETH_PHYLoopBackCmd PROC
;;;2273     */
;;;2274   uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
00091e  b530              PUSH     {r4,r5,lr}
;;;2275   {
000920  460c              MOV      r4,r1
000922  4605              MOV      r5,r0
;;;2276     uint16_t tmpreg = 0;
;;;2277     /* Check the parameters */
;;;2278     assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
;;;2279     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2280       
;;;2281     /* Get the PHY configuration to update it */
;;;2282     tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); 
000924  2100              MOVS     r1,#0
000926  f7fffffe          BL       ETH_ReadPHYRegister
;;;2283     
;;;2284     if (NewState != DISABLE)
00092a  b114              CBZ      r4,|L1.2354|
;;;2285     {
;;;2286       /* Enable the PHY loopback mode */
;;;2287       tmpreg |= PHY_Loopback;  
00092c  f4404280          ORR      r2,r0,#0x4000
000930  e001              B        |L1.2358|
                  |L1.2354|
;;;2288     }
;;;2289     else
;;;2290     {
;;;2291       /* Disable the PHY loopback mode: normal mode */
;;;2292       tmpreg &= (uint16_t)(~(uint16_t)PHY_Loopback);
000932  f4204280          BIC      r2,r0,#0x4000
                  |L1.2358|
;;;2293     }
;;;2294     /* Update the PHY control register with the new configuration */
;;;2295     if(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET)
000936  2100              MOVS     r1,#0
000938  4628              MOV      r0,r5
00093a  f7fffffe          BL       ETH_WritePHYRegister
00093e  2800              CMP      r0,#0
000940  d000              BEQ      |L1.2372|
;;;2296     {
;;;2297       return ETH_SUCCESS;
000942  2001              MOVS     r0,#1
                  |L1.2372|
;;;2298     }
;;;2299     else
;;;2300     {
;;;2301       /* Return SUCCESS */
;;;2302       return ETH_ERROR; 
;;;2303     }   
;;;2304   } 
000944  bd30              POP      {r4,r5,pc}
;;;2305   
                          ENDP

                  ETH_ResetWakeUpFrameFilterRegisterPointer PROC
;;;2313     */
;;;2314   void ETH_ResetWakeUpFrameFilterRegisterPointer(void)
000946  4860              LDR      r0,|L1.2760|
;;;2315   {  
;;;2316     /* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */
;;;2317     ETH->MACPMTCSR |= ETH_MACPMTCSR_WFFRPR;  
000948  6ac1              LDR      r1,[r0,#0x2c]
00094a  f0414100          ORR      r1,r1,#0x80000000
00094e  62c1              STR      r1,[r0,#0x2c]
;;;2318   }
000950  e7ad              B        |L1.2222|
;;;2319   
                          ENDP

                  ETH_SetWakeUpFrameFilterRegister PROC
;;;2324     */
;;;2325   void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
000952  4a5d              LDR      r2,|L1.2760|
;;;2326   {
;;;2327     uint32_t i = 0;
000954  2100              MOVS     r1,#0
                  |L1.2390|
;;;2328     
;;;2329     /* Fill Remote Wake-up Frame Filter register with Buffer data */
;;;2330     for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
;;;2331     {
;;;2332       /* Write each time to the same register */ 
;;;2333       ETH->MACRWUFFR = Buffer[i];
000956  f8503021          LDR      r3,[r0,r1,LSL #2]
00095a  6293              STR      r3,[r2,#0x28]
00095c  1c49              ADDS     r1,r1,#1
00095e  2908              CMP      r1,#8                 ;2330
000960  d3f9              BCC      |L1.2390|
;;;2334     }
;;;2335   }
000962  e7a4              B        |L1.2222|
;;;2336   
                          ENDP

                  ETH_GlobalUnicastWakeUpCmd PROC
;;;2343     */
;;;2344   void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState)
000964  4958              LDR      r1,|L1.2760|
;;;2345   { 
;;;2346     /* Check the parameters */
;;;2347     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2348     
;;;2349     if (NewState != DISABLE)
000966  2800              CMP      r0,#0
;;;2350     {
;;;2351       /* Enable the MAC Global Unicast Wake-Up */
;;;2352       ETH->MACPMTCSR |= ETH_MACPMTCSR_GU;  
;;;2353     }
;;;2354     else
;;;2355     {
;;;2356       /* Disable the MAC Global Unicast Wake-Up */ 
;;;2357       ETH->MACPMTCSR &= ~ETH_MACPMTCSR_GU;
000968  6ac8              LDR      r0,[r1,#0x2c]
00096a  d002              BEQ      |L1.2418|
00096c  f4407000          ORR      r0,r0,#0x200          ;2352
000970  e001              B        |L1.2422|
                  |L1.2418|
000972  f4207000          BIC      r0,r0,#0x200
                  |L1.2422|
000976  62c8              STR      r0,[r1,#0x2c]         ;2352
;;;2358     }
;;;2359   }
000978  e799              B        |L1.2222|
;;;2360   
                          ENDP

                  ETH_GetPMTFlagStatus PROC
;;;2369     */
;;;2370   FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG)
00097a  4a53              LDR      r2,|L1.2760|
;;;2371   {
00097c  4601              MOV      r1,r0
;;;2372     FlagStatus bitstatus = RESET;
00097e  2000              MOVS     r0,#0
;;;2373     /* Check the parameters */
;;;2374     assert_param(IS_ETH_PMT_GET_FLAG(ETH_PMT_FLAG));
;;;2375     
;;;2376     if ((ETH->MACPMTCSR & ETH_PMT_FLAG) != (uint32_t)RESET)
000980  6ad2              LDR      r2,[r2,#0x2c]
000982  420a              TST      r2,r1
000984  d093              BEQ      |L1.2222|
;;;2377     {
;;;2378       bitstatus = SET;
000986  2001              MOVS     r0,#1
;;;2379     }
;;;2380     else
;;;2381     {
;;;2382       bitstatus = RESET;
;;;2383     }
;;;2384     return bitstatus;
;;;2385   }
000988  e791              B        |L1.2222|
;;;2386   
                          ENDP

                  ETH_WakeUpFrameDetectionCmd PROC
;;;2392     */
;;;2393   void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState)
00098a  494f              LDR      r1,|L1.2760|
;;;2394   { 
;;;2395     /* Check the parameters */
;;;2396     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2397     
;;;2398     if (NewState != DISABLE)
00098c  2800              CMP      r0,#0
;;;2399     {
;;;2400       /* Enable the MAC Wake-Up Frame Detection */
;;;2401       ETH->MACPMTCSR |= ETH_MACPMTCSR_WFE;  
;;;2402     }
;;;2403     else
;;;2404     {
;;;2405       /* Disable the MAC Wake-Up Frame Detection */ 
;;;2406       ETH->MACPMTCSR &= ~ETH_MACPMTCSR_WFE;
00098e  6ac8              LDR      r0,[r1,#0x2c]
000990  d002              BEQ      |L1.2456|
000992  f0400004          ORR      r0,r0,#4              ;2401
000996  e001              B        |L1.2460|
                  |L1.2456|
000998  f0200004          BIC      r0,r0,#4
                  |L1.2460|
00099c  62c8              STR      r0,[r1,#0x2c]         ;2401
;;;2407     }
;;;2408   }
00099e  e786              B        |L1.2222|
;;;2409   
                          ENDP

                  ETH_MagicPacketDetectionCmd PROC
;;;2415     */
;;;2416   void ETH_MagicPacketDetectionCmd(FunctionalState NewState)
0009a0  4949              LDR      r1,|L1.2760|
;;;2417   { 
;;;2418     /* Check the parameters */
;;;2419     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2420     
;;;2421     if (NewState != DISABLE)
0009a2  2800              CMP      r0,#0
;;;2422     {
;;;2423       /* Enable the MAC Magic Packet Detection */
;;;2424       ETH->MACPMTCSR |= ETH_MACPMTCSR_MPE;  
;;;2425     }
;;;2426     else
;;;2427     {
;;;2428       /* Disable the MAC Magic Packet Detection */ 
;;;2429       ETH->MACPMTCSR &= ~ETH_MACPMTCSR_MPE;
0009a4  6ac8              LDR      r0,[r1,#0x2c]
0009a6  d002              BEQ      |L1.2478|
0009a8  f0400002          ORR      r0,r0,#2              ;2424
0009ac  e001              B        |L1.2482|
                  |L1.2478|
0009ae  f0200002          BIC      r0,r0,#2
                  |L1.2482|
0009b2  62c8              STR      r0,[r1,#0x2c]         ;2424
;;;2430     }
;;;2431   }
0009b4  e77b              B        |L1.2222|
;;;2432   
                          ENDP

                  ETH_PowerDownCmd PROC
;;;2438     */
;;;2439   void ETH_PowerDownCmd(FunctionalState NewState)
0009b6  4944              LDR      r1,|L1.2760|
;;;2440   { 
;;;2441     /* Check the parameters */
;;;2442     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2443     
;;;2444     if (NewState != DISABLE)
0009b8  2800              CMP      r0,#0
;;;2445     {
;;;2446       /* Enable the MAC Power Down */
;;;2447       /* This puts the MAC in power down mode */
;;;2448       ETH->MACPMTCSR |= ETH_MACPMTCSR_PD;  
;;;2449     }
;;;2450     else
;;;2451     {
;;;2452       /* Disable the MAC Power Down */ 
;;;2453       ETH->MACPMTCSR &= ~ETH_MACPMTCSR_PD;
0009ba  6ac8              LDR      r0,[r1,#0x2c]
0009bc  d002              BEQ      |L1.2500|
0009be  f0400001          ORR      r0,r0,#1              ;2448
0009c2  e001              B        |L1.2504|
                  |L1.2500|
0009c4  f0200001          BIC      r0,r0,#1
                  |L1.2504|
0009c8  62c8              STR      r0,[r1,#0x2c]         ;2448
;;;2454     }
;;;2455   } 
0009ca  e770              B        |L1.2222|
;;;2456   
                          ENDP

                  ETH_MMCCounterFullPreset PROC
;;;2464     */
;;;2465   void ETH_MMCCounterFullPreset(void)
0009cc  483e              LDR      r0,|L1.2760|
;;;2466   {
;;;2467     /* Preset and Initialize the MMC counters to almost-full value */
;;;2468     ETH->MMCCR |= ETH_MMCCR_MCFHP | ETH_MMCCR_MCP;
0009ce  f8d01100          LDR      r1,[r0,#0x100]
0009d2  f0410130          ORR      r1,r1,#0x30
0009d6  f8c01100          STR      r1,[r0,#0x100]
;;;2469   }
0009da  e768              B        |L1.2222|
;;;2470   
                          ENDP

                  ETH_MMCCounterHalfPreset PROC
;;;2475     */
;;;2476   void ETH_MMCCounterHalfPreset(void)
0009dc  483a              LDR      r0,|L1.2760|
;;;2477   {
;;;2478     /* Preset the MMC counters to almost-full value */
;;;2479     ETH->MMCCR &= ~ETH_MMCCR_MCFHP;
0009de  f8d01100          LDR      r1,[r0,#0x100]
0009e2  f0210120          BIC      r1,r1,#0x20
0009e6  f8c01100          STR      r1,[r0,#0x100]
;;;2480     /* Initialize the MMC counters to almost-half value */
;;;2481     ETH->MMCCR |= ETH_MMCCR_MCP;
0009ea  f8d01100          LDR      r1,[r0,#0x100]
0009ee  f0410110          ORR      r1,r1,#0x10
0009f2  f8c01100          STR      r1,[r0,#0x100]
;;;2482   }
0009f6  e75a              B        |L1.2222|
;;;2483   
                          ENDP

                  ETH_MMCCounterFreezeCmd PROC
;;;2489     */
;;;2490   void ETH_MMCCounterFreezeCmd(FunctionalState NewState)
0009f8  4933              LDR      r1,|L1.2760|
;;;2491   {
;;;2492     /* Check the parameters */
;;;2493     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2494     
;;;2495     if (NewState != DISABLE)
0009fa  2800              CMP      r0,#0
;;;2496     {
;;;2497       /* Enable the MMC Counter Freeze */
;;;2498       ETH->MMCCR |= ETH_MMCCR_MCF;
;;;2499     }
;;;2500     else
;;;2501     {
;;;2502       /* Disable the MMC Counter Freeze */
;;;2503       ETH->MMCCR &= ~ETH_MMCCR_MCF;
0009fc  f8d10100          LDR      r0,[r1,#0x100]
000a00  d002              BEQ      |L1.2568|
000a02  f0400008          ORR      r0,r0,#8              ;2498
000a06  e001              B        |L1.2572|
                  |L1.2568|
000a08  f0200008          BIC      r0,r0,#8
                  |L1.2572|
000a0c  f8c10100          STR      r0,[r1,#0x100]        ;2498
;;;2504     }
;;;2505   }
000a10  e74d              B        |L1.2222|
;;;2506   
                          ENDP

                  ETH_MMCResetOnReadCmd PROC
;;;2512     */
;;;2513   void ETH_MMCResetOnReadCmd(FunctionalState NewState)
000a12  492d              LDR      r1,|L1.2760|
;;;2514   {
;;;2515     /* Check the parameters */
;;;2516     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2517     
;;;2518     if (NewState != DISABLE)
000a14  2800              CMP      r0,#0
;;;2519     {
;;;2520       /* Enable the MMC Counter reset on read */
;;;2521       ETH->MMCCR |= ETH_MMCCR_ROR; 
;;;2522     }
;;;2523     else
;;;2524     {
;;;2525       /* Disable the MMC Counter reset on read */
;;;2526       ETH->MMCCR &= ~ETH_MMCCR_ROR;
000a16  f8d10100          LDR      r0,[r1,#0x100]
000a1a  d002              BEQ      |L1.2594|
000a1c  f0400004          ORR      r0,r0,#4              ;2521
000a20  e001              B        |L1.2598|
                  |L1.2594|
000a22  f0200004          BIC      r0,r0,#4
                  |L1.2598|
000a26  f8c10100          STR      r0,[r1,#0x100]        ;2521
;;;2527     }
;;;2528   }
000a2a  e740              B        |L1.2222|
;;;2529   
                          ENDP

                  ETH_MMCCounterRolloverCmd PROC
;;;2535     */
;;;2536   void ETH_MMCCounterRolloverCmd(FunctionalState NewState)
000a2c  4926              LDR      r1,|L1.2760|
;;;2537   {
;;;2538     /* Check the parameters */
;;;2539     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2540     
;;;2541     if (NewState != DISABLE)
000a2e  2800              CMP      r0,#0
;;;2542     {
;;;2543       /* Disable the MMC Counter Stop Rollover  */
;;;2544       ETH->MMCCR &= ~ETH_MMCCR_CSR;
;;;2545     }
;;;2546     else
;;;2547     {
;;;2548       /* Enable the MMC Counter Stop Rollover */
;;;2549       ETH->MMCCR |= ETH_MMCCR_CSR; 
000a30  f8d10100          LDR      r0,[r1,#0x100]
000a34  d002              BEQ      |L1.2620|
000a36  f0200002          BIC      r0,r0,#2              ;2544
000a3a  e001              B        |L1.2624|
                  |L1.2620|
000a3c  f0400002          ORR      r0,r0,#2
                  |L1.2624|
000a40  f8c10100          STR      r0,[r1,#0x100]        ;2544
;;;2550     }
;;;2551   }
000a44  e733              B        |L1.2222|
;;;2552   
                          ENDP

                  ETH_MMCCountersReset PROC
;;;2557     */
;;;2558   void ETH_MMCCountersReset(void)
000a46  4820              LDR      r0,|L1.2760|
;;;2559   {
;;;2560     /* Resets the MMC Counters */
;;;2561     ETH->MMCCR |= ETH_MMCCR_CR; 
000a48  f8d01100          LDR      r1,[r0,#0x100]
000a4c  f0410101          ORR      r1,r1,#1
000a50  f8c01100          STR      r1,[r0,#0x100]
;;;2562   }
000a54  e72b              B        |L1.2222|
;;;2563   
                          ENDP

                  ETH_MMCITConfig PROC
;;;2578     */
;;;2579   void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState)
000a56  4a1c              LDR      r2,|L1.2760|
;;;2580   { 
;;;2581     /* Check the parameters */
;;;2582     assert_param(IS_ETH_MMC_IT(ETH_MMC_IT));  
;;;2583     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2584      
;;;2585     if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
000a58  00c3              LSLS     r3,r0,#3
000a5a  d50b              BPL      |L1.2676|
;;;2586     {
;;;2587       /* Remove Register mak from IT */
;;;2588       ETH_MMC_IT &= 0xEFFFFFFF;
;;;2589     
;;;2590       /* ETHERNET MMC Rx interrupts selected */
;;;2591       if (NewState != DISABLE)
000a5c  2900              CMP      r1,#0
;;;2592       {
;;;2593         /* Enable the selected ETHERNET MMC interrupts */
;;;2594         ETH->MMCRIMR &=(~(uint32_t)ETH_MMC_IT);
;;;2595       }
;;;2596       else
;;;2597       {
;;;2598         /* Disable the selected ETHERNET MMC interrupts */
;;;2599         ETH->MMCRIMR |= ETH_MMC_IT;    
000a5e  f8d2110c          LDR      r1,[r2,#0x10c]
000a62  f0205080          BIC      r0,r0,#0x10000000     ;2588
000a66  d001              BEQ      |L1.2668|
000a68  4381              BICS     r1,r1,r0              ;2594
000a6a  e000              B        |L1.2670|
                  |L1.2668|
000a6c  4301              ORRS     r1,r1,r0
                  |L1.2670|
000a6e  f8c2110c          STR      r1,[r2,#0x10c]
;;;2600       }
;;;2601     }
;;;2602     else
;;;2603     {
;;;2604       /* ETHERNET MMC Tx interrupts selected */
;;;2605       if (NewState != DISABLE)
;;;2606       {
;;;2607         /* Enable the selected ETHERNET MMC interrupts */
;;;2608         ETH->MMCTIMR &=(~(uint32_t)ETH_MMC_IT);
;;;2609       }
;;;2610       else
;;;2611       {
;;;2612         /* Disable the selected ETHERNET MMC interrupts */
;;;2613         ETH->MMCTIMR |= ETH_MMC_IT;    
;;;2614       }  
;;;2615     }
;;;2616   }
000a72  e71c              B        |L1.2222|
                  |L1.2676|
000a74  2900              CMP      r1,#0                 ;2605
000a76  f8d21110          LDR      r1,[r2,#0x110]        ;2613
000a7a  d001              BEQ      |L1.2688|
000a7c  4381              BICS     r1,r1,r0              ;2608
000a7e  e000              B        |L1.2690|
                  |L1.2688|
000a80  4301              ORRS     r1,r1,r0              ;2613
                  |L1.2690|
000a82  f8c21110          STR      r1,[r2,#0x110]        ;2613
000a86  e712              B        |L1.2222|
;;;2617   
                          ENDP

                  ETH_GetMMCITStatus PROC
;;;2629     */
;;;2630   ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT)
000a88  2100              MOVS     r1,#0
;;;2631   {
;;;2632     ITStatus bitstatus = RESET;
;;;2633     /* Check the parameters */
;;;2634     assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT)); 
;;;2635     
;;;2636     if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
;;;2637     {
;;;2638       /* ETHERNET MMC Rx interrupts selected */
;;;2639       /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occurred */ 
;;;2640       if ((((ETH->MMCRIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
000a8a  4a0f              LDR      r2,|L1.2760|
000a8c  00c3              LSLS     r3,r0,#3              ;2636
000a8e  d502              BPL      |L1.2710|
000a90  f8d23104          LDR      r3,[r2,#0x104]
000a94  e001              B        |L1.2714|
                  |L1.2710|
;;;2641       {
;;;2642         bitstatus = SET;
;;;2643       }
;;;2644       else
;;;2645       {
;;;2646         bitstatus = RESET;
;;;2647       }
;;;2648     }
;;;2649     else
;;;2650     {
;;;2651       /* ETHERNET MMC Tx interrupts selected */
;;;2652       /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occurred */  
;;;2653       if ((((ETH->MMCTIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
000a96  f8d23108          LDR      r3,[r2,#0x108]
                  |L1.2714|
000a9a  4203              TST      r3,r0
000a9c  d004              BEQ      |L1.2728|
000a9e  f8d2210c          LDR      r2,[r2,#0x10c]
000aa2  4202              TST      r2,r0
000aa4  d100              BNE      |L1.2728|
;;;2654       {
;;;2655         bitstatus = SET;
000aa6  2101              MOVS     r1,#1
                  |L1.2728|
;;;2656       }
;;;2657       else
;;;2658       {
;;;2659         bitstatus = RESET;
;;;2660       }  
;;;2661     }    
;;;2662       
;;;2663     return bitstatus;
000aa8  4608              MOV      r0,r1
;;;2664   }
000aaa  e700              B        |L1.2222|
;;;2665   
                          ENDP

                  ETH_GetMMCRegister PROC
;;;2682     */
;;;2683   uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg)
000aac  4906              LDR      r1,|L1.2760|
;;;2684   {
;;;2685     /* Check the parameters */
;;;2686     assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg));
;;;2687     
;;;2688     /* Return the selected register value */
;;;2689     return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg));
000aae  5840              LDR      r0,[r0,r1]
;;;2690   }
000ab0  e6fd              B        |L1.2222|
;;;2691   
                          ENDP

                  ETH_Delay PROC
;;;128      */
;;;129    static void ETH_Delay(__IO uint32_t nCount)
000ab2  b501              PUSH     {r0,lr}
;;;130    {
000ab4  b081              SUB      sp,sp,#4
;;;131      __IO uint32_t index = 0; 
;;;132      for(index = nCount; index != 0; index--)
000ab6  9801              LDR      r0,[sp,#4]
                  |L1.2744|
000ab8  9000              STR      r0,[sp,#0]
000aba  2800              CMP      r0,#0
000abc  d001              BEQ      |L1.2754|
000abe  1e40              SUBS     r0,r0,#1
000ac0  e7fa              B        |L1.2744|
                  |L1.2754|
;;;133      {
;;;134       ;
;;;135      }
;;;136    }
000ac2  bd0c              POP      {r2,r3,pc}
;;;137    #endif /* USE_Delay*/
                          ENDP

                  |L1.2756|
                          DCD      0x40029000
                  |L1.2760|
                          DCD      0x40028000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  DMARxDscrTab
                          %        160

                          AREA ||area_number.4||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.4||, ||.bss||
                  DMATxDscrTab
                          %        160

                          AREA ||area_number.5||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.5||, ||.bss||
                  Rx_Buff
                          %        7620

                          AREA ||area_number.6||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.bss||
                  Tx_Buff
                          %        7620

                          AREA ||area_number.7||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.bss||
                  RX_Frame_Descriptor
                          %        12

                          AREA ||area_number.8||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.bss||
                  sadkasd
                          %        40

                          AREA ||.data||, DATA, ALIGN=2

                  DMATxDescToSet
                          DCD      0x00000000
                  DMARxDescToGet
                          DCD      0x00000000
                  DMA_RX_FRAME_infos
                          DCD      0x00000000
                  sdfdfsf
                          DCD      0x00000000
                  dkf_addr
                          DCD      0x00000000

                          AREA ||area_number.11||, DATA, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.data||
                  Frame_Rx_index
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FWLIB\\STM32F4x7_ETH_Driver\\src\\stm32f4x7_eth.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4x7_eth_c_195bd0ff____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___15_stm32f4x7_eth_c_195bd0ff____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4x7_eth_c_195bd0ff____REVSH|
#line 144
|__asm___15_stm32f4x7_eth_c_195bd0ff____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
