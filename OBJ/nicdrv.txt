; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\nicdrv.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\nicdrv.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\FWLIB\STM32F4xx_StdPeriph_Driver\inc -I..\USER -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\ETHERNET -I..\HARDWARE\TIMER -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\RTC -I..\HARDWARE\ADC -I..\HARDWARE\SRAM -I..\HARDWARE\InterTemperate -I..\FWLIB\STM32F4x7_ETH_Driver\inc -I..\MALLOC -I..\USMART -I..\HARDWARE -I..\ETHERCAT -I.\RTE\_LWIP -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS --omf_browse=..\obj\nicdrv.crf ..\ETHERCAT\nicdrv.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  MAC_Send PROC
;;;108    
;;;109    uint8_t MAC_Send(uint8_t *data, int length)
000000  b510              PUSH     {r4,lr}
;;;110    {
000002  460c              MOV      r4,r1
000004  4601              MOV      r1,r0
;;;111    	uint8_t i;
;;;112     		memcpy((u8*)(DMATxDescToSet->Buffer1Addr), (u8*)data, length);
000006  48fb              LDR      r0,|L1.1012|
000008  4622              MOV      r2,r4
00000a  6800              LDR      r0,[r0,#0]  ; DMATxDescToSet
00000c  6880              LDR      r0,[r0,#8]
00000e  f7fffffe          BL       __aeabi_memcpy
;;;113    		/* Prepare transmit descriptors to give to DMA*/
;;;114    	  i=ETH_Prepare_Transmit_Descriptors(length);
000012  b2a0              UXTH     r0,r4
000014  f7fffffe          BL       ETH_Prepare_Transmit_Descriptors
000018  b2c0              UXTB     r0,r0
;;;115    	  return i;
;;;116    }
00001a  bd10              POP      {r4,pc}
;;;117    
                          ENDP

                  ec_setupheader PROC
;;;193     */
;;;194    void ec_setupheader(void *p)
00001c  f64f71ff          MOV      r1,#0xffff
;;;195    {
;;;196       ec_etherheadert *bp;
;;;197       bp = (ec_etherheadert *)p;
;;;198       bp->da0 = htons(0xffff);
000020  8001              STRH     r1,[r0,#0]
;;;199       bp->da1 = htons(0xffff);
000022  8041              STRH     r1,[r0,#2]
;;;200       bp->da2 = htons(0xffff);
000024  8081              STRH     r1,[r0,#4]
;;;201       bp->sa0 = htons(priMAC[0]);
000026  f2401101          MOV      r1,#0x101
00002a  80c1              STRH     r1,[r0,#6]
;;;202       bp->sa1 = htons(priMAC[1]);
00002c  8101              STRH     r1,[r0,#8]
;;;203       bp->sa2 = htons(priMAC[2]);
00002e  8141              STRH     r1,[r0,#0xa]
;;;204       bp->etype = htons(ETH_P_ECAT);
000030  f24a4188          MOV      r1,#0xa488
000034  8181              STRH     r1,[r0,#0xc]
;;;205    }
000036  4770              BX       lr
;;;206    /** Get new frame identifier index and allocate corresponding rx buffer.
                          ENDP

                  ecx_setupnic PROC
;;;135     */
;;;136    int ecx_setupnic(ecx_portt *port,int secondary) 
000038  e92d47f0          PUSH     {r4-r10,lr}
;;;137    {	 
;;;138    	 int i;   
;;;139    		
;;;140    	
;;;141    	 if (secondary)
;;;142       {
;;;143          /* secondary port stuct available? */
;;;144          if (port->redport)
;;;145          {
;;;146             /* when using secondary socket it is automatically a redundant setup */
;;;147      
;;;148             port->redstate                   = ECT_RED_DOUBLE;
;;;149             port->redport->stack.txbuf       = &(port->txbuf);
00003c  f246596c          MOV      r9,#0x656c
000040  4604              MOV      r4,r0                 ;137
000042  eb000309          ADD      r3,r0,r9
;;;150             port->redport->stack.txbuflength = &(port->txbuflength);
000046  f24c404c          MOV      r0,#0xc44c
00004a  1822              ADDS     r2,r4,r0
;;;151             port->redport->stack.tempbuf     = &(port->redport->tempinbuf);
00004c  f6457c78          MOV      r12,#0x5f78
;;;152             port->redport->stack.rxbuf       = &(port->redport->rxbuf);
;;;153             port->redport->stack.rxbufstat   = &(port->redport->rxbufstat);
000050  f64567f8          MOV      r7,#0x5ef8
;;;154             port->redport->stack.rxsa        = &(port->redport->rxsa);
000054  f6457638          MOV      r6,#0x5f38
000058  2500              MOVS     r5,#0
00005a  f5044040          ADD      r0,r4,#0xc000         ;144
00005e  b3e1              CBZ      r1,|L1.218|
000060  f8d01a88          LDR      r1,[r0,#0xa88]        ;144
000064  b3d1              CBZ      r1,|L1.220|
000066  f04f0801          MOV      r8,#1                 ;148
00006a  f8c08a84          STR      r8,[r0,#0xa84]        ;149
00006e  600b              STR      r3,[r1,#0]            ;150
000070  f8d01a88          LDR      r1,[r0,#0xa88]        ;150
000074  604a              STR      r2,[r1,#4]            ;151
000076  f8d01a88          LDR      r1,[r0,#0xa88]        ;151
00007a  eb01020c          ADD      r2,r1,r12             ;151
00007e  608a              STR      r2,[r1,#8]            ;152
000080  f8d01a88          LDR      r1,[r0,#0xa88]        ;152
000084  f1010218          ADD      r2,r1,#0x18           ;152
000088  60ca              STR      r2,[r1,#0xc]          ;153
00008a  f8d01a88          LDR      r1,[r0,#0xa88]        ;153
00008e  19ca              ADDS     r2,r1,r7              ;153
000090  610a              STR      r2,[r1,#0x10]
000092  f8d01a88          LDR      r1,[r0,#0xa88]
000096  198a              ADDS     r2,r1,r6
;;;155             ecx_clear_rxbufstat(&(port->redport->rxbufstat[0]));
000098  614a              STR      r2,[r1,#0x14]
00009a  f8d00a88          LDR      r0,[r0,#0xa88]
00009e  4438              ADD      r0,r0,r7
                  |L1.160|
0000a0  f7fffffe          BL       ecx_clear_rxbufstat
;;;156          }
;;;157          else
;;;158          {
;;;159             /* fail */
;;;160             return 0;
;;;161          }
;;;162       }
;;;163       else
;;;164       {
;;;165          port->lastidx           = 0;
;;;166          port->redstate          = ECT_RED_NONE;
;;;167          port->stack.txbuf       = &(port->txbuf);
;;;168          port->stack.txbuflength = &(port->txbuflength);
;;;169          port->stack.tempbuf     = &(port->tempinbuf);
;;;170          port->stack.rxbuf       = &(port->rxbuf);
;;;171          port->stack.rxbufstat   = &(port->rxbufstat);
;;;172          port->stack.rxsa        = &(port->rxsa);
;;;173          ecx_clear_rxbufstat(&(port->rxbufstat[0]));
;;;174       }  
;;;175    
;;;176       /* setup ethernet headers in tx buffers so we don't have to repeat it */
;;;177    
;;;178    	 for (i = 0; i < EC_MAXBUF; i++)
0000a4  2200              MOVS     r2,#0
0000a6  464b              MOV      r3,r9                 ;149
                  |L1.168|
;;;179       {
;;;180          ec_setupheader(&(port->txbuf[i]));
0000a8  f24020f7          MOV      r0,#0x2f7
0000ac  4350              MULS     r0,r2,r0
0000ae  eb040040          ADD      r0,r4,r0,LSL #1
0000b2  4418              ADD      r0,r0,r3
0000b4  f7fffffe          BL       ec_setupheader
;;;181          port->rxbufstat[i] = EC_BUF_EMPTY;
0000b8  eb040082          ADD      r0,r4,r2,LSL #2
0000bc  f50040a0          ADD      r0,r0,#0x5000
0000c0  1c52              ADDS     r2,r2,#1
0000c2  f8c05ef8          STR      r5,[r0,#0xef8]        ;178
0000c6  2a10              CMP      r2,#0x10              ;178
0000c8  dbee              BLT      |L1.168|
;;;182       }
;;;183       ec_setupheader(&(port->txbuf2));
0000ca  f24c408c          MOV      r0,#0xc48c
0000ce  4420              ADD      r0,r0,r4
0000d0  f7fffffe          BL       ec_setupheader
;;;184    
;;;185       return 1;
0000d4  2001              MOVS     r0,#1
                  |L1.214|
;;;186    }
0000d6  e8bd87f0          POP      {r4-r10,pc}
                  |L1.218|
0000da  e002              B        |L1.226|
                  |L1.220|
0000dc  e7ff              B        |L1.222|
                  |L1.222|
0000de  2000              MOVS     r0,#0                 ;160
0000e0  e7f9              B        |L1.214|
                  |L1.226|
0000e2  f8c05a80          STR      r5,[r0,#0xa80]        ;166
0000e6  f8c05a84          STR      r5,[r0,#0xa84]        ;167
0000ea  eb04000c          ADD      r0,r4,r12             ;169
0000ee  6023              STR      r3,[r4,#0]            ;169
0000f0  e9c42001          STRD     r2,r0,[r4,#4]         ;169
0000f4  f1040018          ADD      r0,r4,#0x18           ;170
0000f8  60e0              STR      r0,[r4,#0xc]          ;171
0000fa  19e0              ADDS     r0,r4,r7              ;171
0000fc  19a1              ADDS     r1,r4,r6              ;172
0000fe  e9c40104          STRD     r0,r1,[r4,#0x10]      ;172
000102  e7cd              B        |L1.160|
;;;187    
                          ENDP

                  ecx_getindex PROC
;;;209     */
;;;210    int ecx_getindex(ecx_portt *port)
000104  b510              PUSH     {r4,lr}
;;;211    {
;;;212       int idx;
;;;213       int cnt;
;;;214    
;;;215       idx = port->lastidx + 1;
000106  f5004240          ADD      r2,r0,#0xc000
00010a  4603              MOV      r3,r0                 ;211
00010c  f8d20a80          LDR      r0,[r2,#0xa80]
000110  1c40              ADDS     r0,r0,#1
;;;216       /* index can't be larger than buffer array */
;;;217       if (idx >= EC_MAXBUF)
000112  2810              CMP      r0,#0x10
000114  db00              BLT      |L1.280|
;;;218       {
;;;219          idx = 0;
000116  2000              MOVS     r0,#0
                  |L1.280|
;;;220       }
;;;221       cnt = 0;
000118  2100              MOVS     r1,#0
;;;222       /* try to find unused index */
;;;223       while ((port->rxbufstat[idx] != EC_BUF_EMPTY) && (cnt < EC_MAXBUF))
00011a  e004              B        |L1.294|
                  |L1.284|
00011c  1c40              ADDS     r0,r0,#1
00011e  1c49              ADDS     r1,r1,#1
;;;224       {
;;;225          idx++;
;;;226          cnt++;
;;;227          if (idx >= EC_MAXBUF)
000120  2810              CMP      r0,#0x10
000122  db00              BLT      |L1.294|
;;;228          {
;;;229             idx = 0;
000124  2000              MOVS     r0,#0
                  |L1.294|
000126  eb030480          ADD      r4,r3,r0,LSL #2       ;223
00012a  f50444a0          ADD      r4,r4,#0x5000         ;223
00012e  f8d44ef8          LDR      r4,[r4,#0xef8]        ;223
000132  b10c              CBZ      r4,|L1.312|
000134  2910              CMP      r1,#0x10              ;223
000136  dbf1              BLT      |L1.284|
                  |L1.312|
;;;230          }
;;;231       }
;;;232       port->rxbufstat[idx] = EC_BUF_ALLOC;
000138  eb030380          ADD      r3,r3,r0,LSL #2
00013c  f50343a0          ADD      r3,r3,#0x5000
000140  2101              MOVS     r1,#1
;;;233    	 if (port->redstate != ECT_RED_NONE)
000142  f8c31ef8          STR      r1,[r3,#0xef8]
000146  f8d23a84          LDR      r3,[r2,#0xa84]
00014a  b133              CBZ      r3,|L1.346|
;;;234       {
;;;235          port->redport->rxbufstat[idx] = EC_BUF_ALLOC;
00014c  f64564f8          MOV      r4,#0x5ef8
000150  f8d23a88          LDR      r3,[r2,#0xa88]
000154  eb040480          ADD      r4,r4,r0,LSL #2
000158  5119              STR      r1,[r3,r4]
                  |L1.346|
;;;236       }
;;;237       port->lastidx = idx;
00015a  f8c20a80          STR      r0,[r2,#0xa80]
;;;238       return idx;
;;;239    }
00015e  bd10              POP      {r4,pc}
;;;240    
                          ENDP

                  ecx_setbufstat PROC
;;;245     */
;;;246    void ecx_setbufstat(ecx_portt *port, int idx, int bufstat)
000160  eb000381          ADD      r3,r0,r1,LSL #2
;;;247    {
;;;248        port->rxbufstat[idx] = bufstat;
000164  f50343a0          ADD      r3,r3,#0x5000
000168  f5004040          ADD      r0,r0,#0xc000
;;;249       if (port->redstate != ECT_RED_NONE)
00016c  f8c32ef8          STR      r2,[r3,#0xef8]
000170  f8d03a84          LDR      r3,[r0,#0xa84]        ;247
000174  2b00              CMP      r3,#0                 ;247
000176  d006              BEQ      |L1.390|
;;;250       {
;;;251          port->redport->rxbufstat[idx] = bufstat;
000178  f8d00a88          LDR      r0,[r0,#0xa88]
00017c  f64563f8          MOV      r3,#0x5ef8
000180  eb030181          ADD      r1,r3,r1,LSL #2
000184  5042              STR      r2,[r0,r1]
                  |L1.390|
;;;252       }
;;;253    }
000186  4770              BX       lr
;;;254    
                          ENDP

                  ecx_outframe PROC
;;;260     */
;;;261    int ecx_outframe(ecx_portt *port, int idx, int stacknumber)
000188  b570              PUSH     {r4-r6,lr}
;;;262    {
00018a  460d              MOV      r5,r1
;;;263    	 int lp, rval;
;;;264       ec_stackT *stack;
;;;265    
;;;266       if (stacknumber==0)
;;;267       {
;;;268          stack = &(port->stack);
;;;269    		  lp = (*stack->txbuflength)[idx];
;;;270    		  MAC_Send((*stack->txbuf)[idx], lp);
00018c  f24023f7          MOV      r3,#0x2f7
000190  4359              MULS     r1,r3,r1
000192  b192              CBZ      r2,|L1.442|
000194  f5004040          ADD      r0,r0,#0xc000         ;262
;;;271       }
;;;272       else
;;;273       {
;;;274          stack = &(port->redport->stack);
;;;275    		  lp = (*stack->txbuflength)[idx];
000198  f8d04a88          LDR      r4,[r0,#0xa88]
00019c  6860              LDR      r0,[r4,#4]
00019e  f8302025          LDRH     r2,[r0,r5,LSL #2]
;;;276    		  dm9k_send_packet((*stack->txbuf)[idx], lp);
0001a2  6820              LDR      r0,[r4,#0]
0001a4  eb000041          ADD      r0,r0,r1,LSL #1
0001a8  b291              UXTH     r1,r2
0001aa  f7fffffe          BL       dm9k_send_packet
                  |L1.430|
;;;277       }
;;;278       rval =1;
;;;279       (*stack->rxbufstat)[idx] = EC_BUF_TX;
0001ae  6922              LDR      r2,[r4,#0x10]
0001b0  2001              MOVS     r0,#1                 ;278
0001b2  2102              MOVS     r1,#2
0001b4  f8421025          STR      r1,[r2,r5,LSL #2]
;;;280       return rval;
;;;281    }
0001b8  bd70              POP      {r4-r6,pc}
                  |L1.442|
0001ba  4604              MOV      r4,r0                 ;268
0001bc  6840              LDR      r0,[r0,#4]            ;269
0001be  f8502025          LDR      r2,[r0,r5,LSL #2]     ;269
0001c2  6820              LDR      r0,[r4,#0]            ;270
0001c4  eb000041          ADD      r0,r0,r1,LSL #1       ;270
0001c8  4611              MOV      r1,r2                 ;270
0001ca  f7fffffe          BL       MAC_Send
0001ce  e7ee              B        |L1.430|
;;;282    
                          ENDP

                  ecx_outframe_red PROC
;;;287     */
;;;288    int ecx_outframe_red(ecx_portt *port, int idx)
0001d0  e92d41f0          PUSH     {r4-r8,lr}
;;;289    {
0001d4  4605              MOV      r5,r0
;;;290       ec_comt *datagramP;
;;;291       ec_etherheadert *ehp;
;;;292       int rval;
;;;293    	
;;;294    	  ehp = (ec_etherheadert *)&(port->txbuf[idx]);
0001d6  f24020f7          MOV      r0,#0x2f7
0001da  460c              MOV      r4,r1                 ;289
0001dc  4348              MULS     r0,r1,r0
0001de  eb050140          ADD      r1,r5,r0,LSL #1
0001e2  f246506c          MOV      r0,#0x656c
0001e6  180e              ADDS     r6,r1,r0
;;;295       /* rewrite MAC source address 1 to primary */
;;;296        ehp->sa1 = htons(priMAC[1]);
;;;297       /* transmit over primary socket*/
;;;298    	 if(DM9161_LINK_OK==1)
0001e8  4f83              LDR      r7,|L1.1016|
0001ea  f2401001          MOV      r0,#0x101             ;296
0001ee  8130              STRH     r0,[r6,#8]            ;296
0001f0  7878              LDRB     r0,[r7,#1]  ; DM9161_LINK_OK
0001f2  2801              CMP      r0,#1
0001f4  d105              BNE      |L1.514|
;;;299       rval = ecx_outframe(port, idx, 0);
0001f6  2200              MOVS     r2,#0
0001f8  4621              MOV      r1,r4
0001fa  4628              MOV      r0,r5
0001fc  f7fffffe          BL       ecx_outframe
000200  4680              MOV      r8,r0
                  |L1.514|
;;;300    	 if(DM9000_LINK_OK==0)
000202  7838              LDRB     r0,[r7,#0]  ; DM9000_LINK_OK
000204  b1c0              CBZ      r0,|L1.568|
;;;301    		  return rval;
;;;302       if (port->redstate != ECT_RED_NONE)
000206  f5054740          ADD      r7,r5,#0xc000
00020a  f8d70a84          LDR      r0,[r7,#0xa84]
00020e  b198              CBZ      r0,|L1.568|
;;;303       {   
;;;304          ehp = (ec_etherheadert *)&(port->txbuf2);
;;;305          /* use dummy frame for secondary socket transmit (BRD) */
;;;306          datagramP = (ec_comt*)&(port->txbuf2[ETH_HEADERSIZE]);
000210  f24c409a          MOV      r0,#0xc49a
000214  4428              ADD      r0,r0,r5
;;;307          /* write index to frame */
;;;308          datagramP->index = idx;
;;;309    		  ehp = (ec_etherheadert *)&(port->txbuf[idx]);
;;;310          /* rewrite MAC source address 1 to secondary */
;;;311          ehp->sa1 = htons(secMAC[1]);
;;;312          /* transmit over secondary socket */
;;;313          //send(sockhandle2, &ec_txbuf2, ec_txbuflength2 , 0);
;;;314          // OBS! redundant not ACTIVE for BFIN, just added to compile
;;;315    //      bfin_EMAC_send(&(port->txbuf2), port->txbuflength2);
;;;316          ecx_outframe(port, idx, 1);
000216  2201              MOVS     r2,#1
000218  70c4              STRB     r4,[r0,#3]            ;308
00021a  f2404004          MOV      r0,#0x404             ;311
00021e  8130              STRH     r0,[r6,#8]            ;311
000220  4621              MOV      r1,r4
000222  4628              MOV      r0,r5
000224  f7fffffe          BL       ecx_outframe
;;;317          port->redport->rxbufstat[idx] = EC_BUF_TX;
000228  f64562f8          MOV      r2,#0x5ef8
00022c  f8d71a88          LDR      r1,[r7,#0xa88]
000230  eb020284          ADD      r2,r2,r4,LSL #2
000234  2002              MOVS     r0,#2
000236  5088              STR      r0,[r1,r2]
                  |L1.568|
;;;318       }   
;;;319       
;;;320       return rval;
000238  4640              MOV      r0,r8
;;;321    }
00023a  e8bd81f0          POP      {r4-r8,pc}
;;;322    
                          ENDP

                  ecx_inframe PROC
;;;368     */
;;;369    int ecx_inframe(ecx_portt *port, int idx, int stacknumber)
00023e  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;370    {
000242  460d              MOV      r5,r1
000244  4607              MOV      r7,r0
;;;371    	 uint16  l;
;;;372    	 uint16 temp;
;;;373       int     rval;
;;;374       int     idxf;
;;;375       ec_etherheadert *ehp;
;;;376       ec_comt *ecp;
;;;377       ec_stackT *stack;
;;;378       ec_bufT *rxbuf;
;;;379    //   stack = &(port->stack);
;;;380    
;;;381    		if (stacknumber==0)
;;;382          {
;;;383    					stack = &(port->stack);
;;;384    					if(ETH_CheckFrameReceived()) 	//检测是否收到数据包
;;;385    					{ 
;;;386    							receiveLen=0;
;;;387    							memset(receiveBuffer, 0, sizeof(receiveBuffer));
;;;388    							lwip_pkt_handle();
;;;389    							memcpy((uint8*)(*stack->rxbuf)[idx], (uint8*)receiveBuffer, receiveLen);
;;;390    					} 
;;;391          }
;;;392         else
;;;393          { 
;;;394            stack = &(port->redport->stack);
000246  f5004a40          ADD      r10,r0,#0xc000
00024a  9902              LDR      r1,[sp,#8]            ;381
00024c  f24020f7          MOV      r0,#0x2f7             ;389
000250  f04f0b00          MOV      r11,#0                ;381
000254  fb05f600          MUL      r6,r5,r0              ;389
000258  2900              CMP      r1,#0                 ;381
00025a  d05b              BEQ      |L1.788|
;;;395    				receiveLen_DM9000 = 0;								/* Çå³ý½ÓÊÕµÄ³¤¶È */
00025c  f8df819c          LDR      r8,|L1.1020|
000260  f8da4a88          LDR      r4,[r10,#0xa88]
;;;396    		    memset(receiveBuffer_DM9000, 0, sizeof(receiveBuffer_DM9000));
000264  21c8              MOVS     r1,#0xc8
000266  f8a8b000          STRH     r11,[r8,#0]           ;395
00026a  4865              LDR      r0,|L1.1024|
00026c  f7fffffe          BL       __aeabi_memclr
;;;397    				if(dm9k_receive_packet())
000270  f7fffffe          BL       dm9k_receive_packet
000274  b138              CBZ      r0,|L1.646|
;;;398    				 {
;;;399    					memcpy((uint8*)(*stack->rxbuf)[idx], (uint8*)receiveBuffer_DM9000, receiveLen_DM9000);
000276  68e0              LDR      r0,[r4,#0xc]
000278  f8b82000          LDRH     r2,[r8,#0]  ; receiveLen_DM9000
00027c  eb000046          ADD      r0,r0,r6,LSL #1
000280  495f              LDR      r1,|L1.1024|
                  |L1.642|
000282  f7fffffe          BL       __aeabi_memcpy
                  |L1.646|
;;;400             }
;;;401          }	 				 
;;;402    		 rval = EC_NOFRAME;		 
;;;403    		 rxbuf = &(*stack->rxbuf)[idx];
000286  68e0              LDR      r0,[r4,#0xc]
000288  f04f38ff          MOV      r8,#0xffffffff        ;402
00028c  eb000646          ADD      r6,r0,r6,LSL #1
;;;404    		 /* check if requested index is already in buffer ? */
;;;405    		 if ((idx < EC_MAXBUF) && ((*stack->rxbufstat)[idx] == EC_BUF_RCVD)) 
000290  2d10              CMP      r5,#0x10
000292  da04              BGE      |L1.670|
000294  6921              LDR      r1,[r4,#0x10]
000296  f8510025          LDR      r0,[r1,r5,LSL #2]
00029a  2803              CMP      r0,#3
00029c  d050              BEQ      |L1.832|
                  |L1.670|
00029e  9802              LDR      r0,[sp,#8]
;;;406    		 {
;;;407    				l = (*rxbuf)[0] + ((uint16)((*rxbuf)[1] & 0x0f) << 8);
;;;408    				/* return WKC */
;;;409    				rval = ((*rxbuf)[l] + ((uint16)(*rxbuf)[l + 1] << 8));
;;;410    				/* mark as completed */
;;;411    				(*stack->rxbufstat)[idx] = EC_BUF_COMPLETE;
;;;412    		 }
;;;413    		 else 
;;;414    		 {
;;;415    				/* non blocking call to retrieve frame from socket */
;;;416    				if (ecx_recvpkt(port, stacknumber)) 
0002a0  46b9              MOV      r9,r7
0002a2  b3b0              CBZ      r0,|L1.786|
0002a4  4955              LDR      r1,|L1.1020|
0002a6  f8da0a88          LDR      r0,[r10,#0xa88]
0002aa  880f              LDRH     r7,[r1,#0]  ; receiveLen_DM9000
0002ac  6880              LDR      r0,[r0,#8]
0002ae  463a              MOV      r2,r7
0002b0  4953              LDR      r1,|L1.1024|
                  |L1.690|
0002b2  f7fffffe          BL       __aeabi_memcpy
0002b6  f2465068          MOV      r0,#0x6568
0002ba  2f00              CMP      r7,#0
0002bc  f8407009          STR      r7,[r0,r9]
0002c0  dd57              BLE      |L1.882|
;;;417    				{
;;;418    					 rval = EC_OTHERFRAME;
;;;419    					 ehp =(ec_etherheadert*)(stack->tempbuf);
;;;420    					 /* check if it is an EtherCAT frame */
;;;421    					 if (ehp->etype == htons(ETH_P_ECAT)) 
0002c2  68a7              LDR      r7,[r4,#8]
0002c4  f06f0801          MVN      r8,#1                 ;418
0002c8  89b8              LDRH     r0,[r7,#0xc]
0002ca  f5a04124          SUB      r1,r0,#0xa400
0002ce  3988              SUBS     r1,r1,#0x88
0002d0  d14f              BNE      |L1.882|
;;;422    					 {
;;;423    							ecp =(ec_comt*)(&(*stack->tempbuf)[ETH_HEADERSIZE]); 
;;;424    							l = etohs(ecp->elength) & 0x0fff;						
;;;425    							idxf = ecp->index;
0002d2  7c78              LDRB     r0,[r7,#0x11]
0002d4  f107010e          ADD      r1,r7,#0xe
;;;426    							/* found index equals reqested index ? */
;;;427    							if (idxf == idx) 
0002d8  42a8              CMP      r0,r5
0002da  d145              BNE      |L1.872|
;;;428    							{
;;;429    								 /* yes, put it in the buffer array (strip ethernet header) */
;;;430    								 memcpy(rxbuf, &(*stack->tempbuf)[ETH_HEADERSIZE], (*stack->txbuflength)[idx] - ETH_HEADERSIZE);
0002dc  6860              LDR      r0,[r4,#4]
0002de  f8502025          LDR      r2,[r0,r5,LSL #2]
0002e2  4630              MOV      r0,r6
0002e4  3a0e              SUBS     r2,r2,#0xe
0002e6  f7fffffe          BL       __aeabi_memcpy
;;;431    								/* return WKC */
;;;432    								 l=(*stack->txbuflength)[idx] - ETH_HEADERSIZE;
0002ea  6860              LDR      r0,[r4,#4]
0002ec  f8300025          LDRH     r0,[r0,r5,LSL #2]
0002f0  380e              SUBS     r0,r0,#0xe
0002f2  b280              UXTH     r0,r0
;;;433    								 rval = ((*rxbuf)[l-2] + ((uint16)((*rxbuf)[l-1]) << 8));
0002f4  4430              ADD      r0,r0,r6
0002f6  f8101d02          LDRB     r1,[r0,#-2]!
0002fa  7840              LDRB     r0,[r0,#1]
0002fc  eb012800          ADD      r8,r1,r0,LSL #8
;;;434    								 /* mark as completed */
;;;435    								 (*stack->rxbufstat)[idx] = EC_BUF_COMPLETE;
000300  6921              LDR      r1,[r4,#0x10]
000302  2004              MOVS     r0,#4
000304  f8410025          STR      r0,[r1,r5,LSL #2]
;;;436    								 /* store MAC source word 1 for redundant routing info */
;;;437    								 (*stack->rxsa)[idx] = etohs(ehp->sa1);
000308  8938              LDRH     r0,[r7,#8]
00030a  6961              LDR      r1,[r4,#0x14]
                  |L1.780|
00030c  f8410025          STR      r0,[r1,r5,LSL #2]
000310  e02f              B        |L1.882|
                  |L1.786|
000312  e022              B        |L1.858|
                  |L1.788|
000314  463c              MOV      r4,r7                 ;383
000316  f7fffffe          BL       ETH_CheckFrameReceived
00031a  2800              CMP      r0,#0                 ;384
00031c  d0b3              BEQ      |L1.646|
00031e  f8df80e4          LDR      r8,|L1.1028|
000322  21c8              MOVS     r1,#0xc8              ;387
000324  4838              LDR      r0,|L1.1032|
000326  f8a8b000          STRH     r11,[r8,#0]           ;386
00032a  f7fffffe          BL       __aeabi_memclr
00032e  f7fffffe          BL       lwip_pkt_handle
000332  68e0              LDR      r0,[r4,#0xc]          ;389
000334  f8b82000          LDRH     r2,[r8,#0]            ;389  ; receiveLen
000338  eb000046          ADD      r0,r0,r6,LSL #1       ;389
00033c  4932              LDR      r1,|L1.1032|
00033e  e7a0              B        |L1.642|
                  |L1.832|
000340  7872              LDRB     r2,[r6,#1]            ;407
000342  7830              LDRB     r0,[r6,#0]            ;407
000344  f002020f          AND      r2,r2,#0xf            ;407
000348  eb002002          ADD      r0,r0,r2,LSL #8       ;407
00034c  5c32              LDRB     r2,[r6,r0]            ;409
00034e  4430              ADD      r0,r0,r6              ;409
000350  7840              LDRB     r0,[r0,#1]            ;409
000352  eb022800          ADD      r8,r2,r0,LSL #8       ;409
000356  2004              MOVS     r0,#4                 ;411
000358  e7d8              B        |L1.780|
                  |L1.858|
00035a  492a              LDR      r1,|L1.1028|
00035c  f8d90008          LDR      r0,[r9,#8]            ;411
000360  880f              LDRH     r7,[r1,#0]            ;411  ; receiveLen
000362  4929              LDR      r1,|L1.1032|
000364  463a              MOV      r2,r7                 ;411
000366  e7a4              B        |L1.690|
                  |L1.872|
;;;438    							}
;;;439    							else 
;;;440    							{
;;;441    								 /* check if index exist? */
;;;442    								 if (idxf < EC_MAXBUF) 
000368  2810              CMP      r0,#0x10
00036a  da02              BGE      |L1.882|
;;;443    								 {
;;;444    //										rxbuf = &(*stack->rxbuf)[idxf];
;;;445    //										/* put it in the buffer array (strip ethernet header) */
;;;446    //										memcpy(rxbuf, &(*stack->tempbuf)[ETH_HEADERSIZE], (*stack->txbuflength)[idxf] - ETH_HEADERSIZE);
;;;447    //										/* mark as received */
;;;448    //										(*stack->rxbufstat)[idxf] = EC_BUF_RCVD;
;;;449    //										(*stack->rxsa)[idxf] = etohs(ehp->sa1);
;;;450    									  (*stack->rxbufstat)[idxf] = EC_BUF_EMPTY;
00036c  6922              LDR      r2,[r4,#0x10]
00036e  f842b020          STR      r11,[r2,r0,LSL #2]
                  |L1.882|
;;;451    								 }
;;;452    								 else 
;;;453    								 {
;;;454    										/* strange things happend */
;;;455    								 }
;;;456    							}
;;;457    					 }
;;;458    				}    
;;;459    		 }
;;;460       return rval;
000372  4640              MOV      r0,r8
;;;461    }
000374  e8bd8ffe          POP      {r1-r11,pc}
;;;462    /** Blocking receive frame function. Calls ec_waitinframe_red().
                          ENDP

                  ecx_waitinframe_red PROC
;;;495     */
;;;496    int ecx_waitinframe_red(ecx_portt *port, int idx, int timeout)
000378  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;497    {
00037c  b082              SUB      sp,sp,#8
;;;498    	 int wkc  = EC_NOFRAME;
00037e  f04f34ff          MOV      r4,#0xffffffff
;;;499       int wkc2 = EC_NOFRAME;
;;;500       int primrx, secrx;
;;;501       uint32_t timer2;
;;;502    	
;;;503       /* if not in redundant mode then always assume secondary is OK */
;;;504       if (port->redstate == ECT_RED_NONE)
000382  9e02              LDR      r6,[sp,#8]
000384  4625              MOV      r5,r4                 ;499
000386  f5064640          ADD      r6,r6,#0xc000
00038a  f8d60a84          LDR      r0,[r6,#0xa84]        ;497
00038e  b900              CBNZ     r0,|L1.914|
;;;505       {
;;;506          wkc2 = 0;
000390  2500              MOVS     r5,#0
                  |L1.914|
;;;507       }
;;;508    	 timer2=bsp_GetTickCount();
000392  f7fffffe          BL       bsp_GetTickCount
;;;509       do 
;;;510       {
;;;511          /* only read frame if not already in */
;;;512    		if(DM9161_LINK_OK==1)
000396  4f18              LDR      r7,|L1.1016|
000398  4680              MOV      r8,r0                 ;508
                  |L1.922|
00039a  7878              LDRB     r0,[r7,#1]  ; DM9161_LINK_OK
00039c  2801              CMP      r0,#1
00039e  d013              BEQ      |L1.968|
;;;513    		{
;;;514          if (wkc <= EC_NOFRAME)
;;;515          {
;;;516             wkc  = ecx_inframe(port, idx, 0);
;;;517          }
;;;518    		}
;;;519    		else
;;;520    		{
;;;521    		  wkc=0;
0003a0  2400              MOVS     r4,#0
                  |L1.930|
;;;522    		}
;;;523          /* only try secondary if in redundant mode */
;;;524    		if(DM9000_LINK_OK==1)
0003a2  7838              LDRB     r0,[r7,#0]  ; DM9000_LINK_OK
0003a4  2801              CMP      r0,#1
0003a6  d018              BEQ      |L1.986|
;;;525    		{
;;;526          if (port->redstate != ECT_RED_NONE)
;;;527          {   
;;;528             /* only read frame if not already in */
;;;529             if (wkc2 <= EC_NOFRAME)
;;;530                wkc2 = ecx_inframe(port, idx, 1);
;;;531          } 
;;;532    		}	
;;;533        else	
;;;534        {
;;;535    		   wkc2=0;
0003a8  2500              MOVS     r5,#0
                  |L1.938|
;;;536    		}			
;;;537       /* wait for both frames to arrive or timeout */   
;;;538       }while (((wkc <= EC_NOFRAME) || (wkc2 <= EC_NOFRAME)) && ((bsp_GetTickCount()-timer2)<timeout));
0003aa  2c00              CMP      r4,#0
0003ac  db01              BLT      |L1.946|
0003ae  2d00              CMP      r5,#0
0003b0  da06              BGE      |L1.960|
                  |L1.946|
0003b2  f7fffffe          BL       bsp_GetTickCount
0003b6  eba00108          SUB      r1,r0,r8
0003ba  9804              LDR      r0,[sp,#0x10]
0003bc  4281              CMP      r1,r0
0003be  d3ec              BCC      |L1.922|
                  |L1.960|
;;;539    //while ((bsp_GetTickCount()-timer2)<timeout);
;;;540       /* only do redundant functions when in redundant mode */
;;;541    	 if(DM9000_LINK_OK==1)
0003c0  7838              LDRB     r0,[r7,#0]  ; DM9000_LINK_OK
0003c2  2801              CMP      r0,#1
0003c4  d022              BEQ      |L1.1036|
0003c6  e0a1              B        |L1.1292|
                  |L1.968|
0003c8  2c00              CMP      r4,#0                 ;514
0003ca  daea              BGE      |L1.930|
0003cc  e9dd0102          LDRD     r0,r1,[sp,#8]         ;516
0003d0  2200              MOVS     r2,#0                 ;516
0003d2  f7fffffe          BL       ecx_inframe
0003d6  4604              MOV      r4,r0                 ;516
0003d8  e7e3              B        |L1.930|
                  |L1.986|
0003da  f8d60a84          LDR      r0,[r6,#0xa84]        ;526
0003de  2800              CMP      r0,#0                 ;526
0003e0  d0e3              BEQ      |L1.938|
0003e2  2d00              CMP      r5,#0                 ;529
0003e4  dae1              BGE      |L1.938|
0003e6  e9dd0102          LDRD     r0,r1,[sp,#8]         ;530
0003ea  2201              MOVS     r2,#1                 ;530
0003ec  f7fffffe          BL       ecx_inframe
0003f0  4605              MOV      r5,r0                 ;530
0003f2  e7da              B        |L1.938|
                  |L1.1012|
                          DCD      DMATxDescToSet
                  |L1.1016|
                          DCD      ||.data||
                  |L1.1020|
                          DCD      receiveLen_DM9000
                  |L1.1024|
                          DCD      receiveBuffer_DM9000
                  |L1.1028|
                          DCD      receiveLen
                  |L1.1032|
                          DCD      receiveBuffer
                  |L1.1036|
;;;542    	 {
;;;543    		if(DM9161_LINK_OK==1)
;;;544    		{
;;;545    	 if (port->redstate != ECT_RED_NONE)
;;;546       {
;;;547          /* primrx if the reveived MAC source on primary socket */
;;;548          primrx = 0xffff;
;;;549          if (wkc > EC_NOFRAME) 
;;;550          {  
;;;551             primrx = port->rxsa[idx];
;;;552          }
;;;553          /* secrx if the reveived MAC source on psecondary socket */
;;;554          secrx = 0xffff;
;;;555          if (wkc2 > EC_NOFRAME) 
;;;556          {
;;;557             secrx = port->redport->rxsa[idx];
;;;558          }
;;;559          /* primary socket got secondary frame and secondary socket got primary frame */
;;;560          /* normal situation in redundant mode */
;;;561          if ( ((primrx == RX_SEC) && (secrx == RX_PRIM)) )
;;;562          {
;;;563             /* copy secondary buffer to primary */
;;;564             memcpy(&(port->rxbuf[idx]), &(port->redport->rxbuf[idx]), port->txbuflength[idx] - ETH_HEADERSIZE);
00040c  9903              LDR      r1,[sp,#0xc]
00040e  f24022f7          MOV      r2,#0x2f7
000412  2018              MOVS     r0,#0x18
000414  4351              MULS     r1,r2,r1
000416  eb000b41          ADD      r11,r0,r1,LSL #1
00041a  e9dd2002          LDRD     r2,r0,[sp,#8]
00041e  eb020080          ADD      r0,r2,r0,LSL #2       ;551
000422  9a02              LDR      r2,[sp,#8]
000424  787b              LDRB     r3,[r7,#1]            ;543  ; DM9161_LINK_OK
000426  eb020141          ADD      r1,r2,r1,LSL #1
00042a  f5004a40          ADD      r10,r0,#0xc000
00042e  f1010818          ADD      r8,r1,#0x18
000432  9100              STR      r1,[sp,#0]            ;543
000434  2b01              CMP      r3,#1                 ;543
000436  d15f              BNE      |L1.1272|
000438  f8d61a84          LDR      r1,[r6,#0xa84]        ;545
00043c  b3f1              CBZ      r1,|L1.1212|
00043e  f64f77ff          MOV      r7,#0xffff            ;548
000442  2c00              CMP      r4,#0                 ;549
000444  db03              BLT      |L1.1102|
000446  f50040a0          ADD      r0,r0,#0x5000         ;549
00044a  f8d07f38          LDR      r7,[r0,#0xf38]        ;551
                  |L1.1102|
00044e  f64f79ff          MOV      r9,#0xffff            ;554
000452  2d00              CMP      r5,#0                 ;555
000454  db08              BLT      |L1.1128|
000456  9803              LDR      r0,[sp,#0xc]          ;557
000458  f8d61a88          LDR      r1,[r6,#0xa88]        ;557
00045c  f6457238          MOV      r2,#0x5f38            ;557
000460  eb020080          ADD      r0,r2,r0,LSL #2       ;557
000464  f8519000          LDR      r9,[r1,r0]            ;557
                  |L1.1128|
000468  f5a76080          SUB      r0,r7,#0x400          ;561
00046c  3804              SUBS     r0,#4                 ;561
00046e  d10d              BNE      |L1.1164|
000470  f5a97180          SUB      r1,r9,#0x100          ;561
000474  3901              SUBS     r1,#1                 ;561
000476  d109              BNE      |L1.1164|
000478  f8d61a88          LDR      r1,[r6,#0xa88]
00047c  f8da244c          LDR      r2,[r10,#0x44c]
000480  4459              ADD      r1,r1,r11
000482  4640              MOV      r0,r8
000484  3a0e              SUBS     r2,r2,#0xe
000486  f7fffffe          BL       __aeabi_memcpy
;;;565             wkc = wkc2;
00048a  462c              MOV      r4,r5
                  |L1.1164|
;;;566          }    
;;;567          /* primary socket got nothing or primary frame, and secondary socket got secondary frame */
;;;568          /* we need to resend TX packet */ 
;;;569    
;;;570          if ( ((primrx == 0xffff) && (secrx == RX_SEC)) ||
00048c  f5a7407f          SUB      r0,r7,#0xff00
000490  38ff              SUBS     r0,r0,#0xff
000492  d103              BNE      |L1.1180|
000494  f5a96080          SUB      r0,r9,#0x400
000498  3804              SUBS     r0,#4
00049a  d007              BEQ      |L1.1196|
                  |L1.1180|
;;;571               ((primrx == RX_PRIM) && (secrx == RX_SEC)) )
00049c  f5a77080          SUB      r0,r7,#0x100
0004a0  3801              SUBS     r0,#1
0004a2  d133              BNE      |L1.1292|
0004a4  f5a96180          SUB      r1,r9,#0x400
0004a8  3904              SUBS     r1,#4
0004aa  d12f              BNE      |L1.1292|
                  |L1.1196|
;;;572          {
;;;573             /* If both primary and secondary have partial connection retransmit the primary received
;;;574              * frame over the secondary socket. The result from the secondary received frame is a combined
;;;575              * frame that traversed all slaves in standard order. */
;;;576             if ( (primrx == RX_PRIM) && (secrx == RX_SEC) )
0004ac  f5a77080          SUB      r0,r7,#0x100
0004b0  3801              SUBS     r0,#1
0004b2  d10b              BNE      |L1.1228|
;;;577             {   
;;;578                /* copy primary rx to tx buffer */
;;;579                memcpy(&(port->txbuf[idx][ETH_HEADERSIZE]), &(port->rxbuf[idx]), port->txbuflength[idx] - ETH_HEADERSIZE);
0004b4  4641              MOV      r1,r8
0004b6  f8da244c          LDR      r2,[r10,#0x44c]
0004ba  e000              B        |L1.1214|
                  |L1.1212|
0004bc  e026              B        |L1.1292|
                  |L1.1214|
0004be  9800              LDR      r0,[sp,#0]
0004c0  f246537a          MOV      r3,#0x657a
0004c4  4418              ADD      r0,r0,r3
0004c6  3a0e              SUBS     r2,r2,#0xe
0004c8  f7fffffe          BL       __aeabi_memcpy
                  |L1.1228|
;;;580             }      
;;;581             /* resend secondary tx */
;;;582             ecx_outframe(port, idx, 1);
0004cc  e9dd0102          LDRD     r0,r1,[sp,#8]
0004d0  2201              MOVS     r2,#1
0004d2  f7fffffe          BL       ecx_outframe
;;;583    				 timer2=bsp_GetTickCount();
0004d6  f7fffffe          BL       bsp_GetTickCount
0004da  4607              MOV      r7,r0
                  |L1.1244|
;;;584             do 
;;;585             {
;;;586                /* retrieve frame */
;;;587                wkc2 = ecx_inframe(port, idx, 1);
0004dc  e9dd0102          LDRD     r0,r1,[sp,#8]
0004e0  2201              MOVS     r2,#1
0004e2  f7fffffe          BL       ecx_inframe
0004e6  0005              MOVS     r5,r0
;;;588             } while ((wkc2 <= EC_NOFRAME) && ((bsp_GetTickCount()-timer2)<timeout));
0004e8  d506              BPL      |L1.1272|
0004ea  f7fffffe          BL       bsp_GetTickCount
0004ee  1bc1              SUBS     r1,r0,r7
0004f0  9804              LDR      r0,[sp,#0x10]
0004f2  4281              CMP      r1,r0
0004f4  d3f2              BCC      |L1.1244|
0004f6  e009              B        |L1.1292|
                  |L1.1272|
;;;589             if (wkc2 > EC_NOFRAME)
;;;590             {   
;;;591                /* copy secondary result to primary rx buffer */
;;;592                memcpy(&(port->rxbuf[idx]), &(port->redport->rxbuf[idx]), port->txbuflength[idx] - ETH_HEADERSIZE);
;;;593                wkc = wkc2;
;;;594             }   
;;;595    					}      
;;;596    				}
;;;597    			}
;;;598    		else
;;;599    		 {
;;;600    		 	memcpy(&(port->rxbuf[idx]), &(port->redport->rxbuf[idx]), port->txbuflength[idx] - ETH_HEADERSIZE);
0004f8  f8d61a88          LDR      r1,[r6,#0xa88]
0004fc  f8da244c          LDR      r2,[r10,#0x44c]
000500  4459              ADD      r1,r1,r11
000502  4640              MOV      r0,r8
000504  3a0e              SUBS     r2,r2,#0xe
000506  f7fffffe          BL       __aeabi_memcpy
;;;601    			wkc = wkc2;
00050a  462c              MOV      r4,r5
                  |L1.1292|
;;;602          }      
;;;603       }
;;;604       /* return WKC or EC_NOFRAME */
;;;605       return wkc;
;;;606    }   
00050c  b005              ADD      sp,sp,#0x14
00050e  4620              MOV      r0,r4                 ;605
000510  e8bd8ff0          POP      {r4-r11,pc}
;;;607    
                          ENDP

                  ecx_waitinframe PROC
;;;468     */
;;;469    int ecx_waitinframe(ecx_portt *port, int idx, int timeout)
000514  b570              PUSH     {r4-r6,lr}
;;;470    {
000516  460d              MOV      r5,r1
000518  4606              MOV      r6,r0
;;;471       int wkc;
;;;472    //   osal_timert timer;
;;;473       
;;;474    //   osal_timer_start (&timer, timeout);
;;;475       wkc = ecx_waitinframe_red(port, idx, timeout);
00051a  f7fffffe          BL       ecx_waitinframe_red
00051e  0004              MOVS     r4,r0
;;;476       /* if nothing received, clear buffer index status so it can be used again */
;;;477       if (wkc <= EC_NOFRAME) 
000520  d504              BPL      |L1.1324|
;;;478       {
;;;479          ecx_setbufstat(port, idx, EC_BUF_EMPTY);
000522  2200              MOVS     r2,#0
000524  4629              MOV      r1,r5
000526  4630              MOV      r0,r6
000528  f7fffffe          BL       ecx_setbufstat
                  |L1.1324|
;;;480       }
;;;481       
;;;482       return wkc;
00052c  4620              MOV      r0,r4
;;;483    }
00052e  bd70              POP      {r4-r6,pc}
;;;484    /** Blocking redundant receive frame function. If redundant mode is not active then
                          ENDP

                  ec_setbufstat PROC
;;;656    
;;;657    void ec_setbufstat(int idx, int bufstat)
000530  460a              MOV      r2,r1
;;;658    {
;;;659       ecx_setbufstat(&ecx_port, idx, bufstat);
000532  4601              MOV      r1,r0
000534  482a              LDR      r0,|L1.1504|
000536  e7fe              B        ecx_setbufstat
;;;660    }
;;;661    
                          ENDP

                  ecx_srconfirm PROC
;;;619     */
;;;620    int ecx_srconfirm(ecx_portt *port, int idx, int timeout)
000538  e92d47f0          PUSH     {r4-r10,lr}
;;;621    {
00053c  4617              MOV      r7,r2
00053e  468a              MOV      r10,r1
000540  4680              MOV      r8,r0
;;;622       int wkc = EC_NOFRAME;
;;;623       uint32_t timer2;  
;;;624       timer2=bsp_GetTickCount();	 
000542  f7fffffe          BL       bsp_GetTickCount
;;;625    	 DM9000_LINK_OK=0;
000546  4c27              LDR      r4,|L1.1508|
000548  4606              MOV      r6,r0                 ;624
00054a  2000              MOVS     r0,#0
00054c  7020              STRB     r0,[r4,#0]
;;;626    	 DM9161_LINK_OK=0;
00054e  7060              STRB     r0,[r4,#1]
;;;627    	 if(ETH_ReadPHYRegister(DM9162_PHY_ADDRESS, PHY_BSR) & 0x0004)
000550  2101              MOVS     r1,#1
000552  4608              MOV      r0,r1
000554  f7fffffe          BL       ETH_ReadPHYRegister
000558  0740              LSLS     r0,r0,#29
00055a  f04f0501          MOV      r5,#1
00055e  d500              BPL      |L1.1378|
;;;628    		  DM9161_LINK_OK=1;
000560  7065              STRB     r5,[r4,#1]
                  |L1.1378|
;;;629    	 if(dm9k_ReadReg(DM9000_REG_NSR) & DM9000_PHY)
000562  2001              MOVS     r0,#1
000564  f7fffffe          BL       dm9k_ReadReg
000568  0640              LSLS     r0,r0,#25
00056a  d500              BPL      |L1.1390|
;;;630    		  DM9000_LINK_OK=1;
00056c  7025              STRB     r5,[r4,#0]
                  |L1.1390|
;;;631       do 
;;;632       {
;;;633          /* tx frame on primary and if in redundant mode a dummy on secondary */
;;;634    		 ecx_outframe_red(port, idx);
;;;635    		 if (port->redstate != ECT_RED_NONE)
00056e  f5084540          ADD      r5,r8,#0xc000
;;;636        		 Delay_us(500);
000572  f44f79fa          MOV      r9,#0x1f4
                  |L1.1398|
000576  4651              MOV      r1,r10                ;634
000578  4640              MOV      r0,r8                 ;634
00057a  f7fffffe          BL       ecx_outframe_red
00057e  f8d50a84          LDR      r0,[r5,#0xa84]        ;635
000582  b110              CBZ      r0,|L1.1418|
000584  4648              MOV      r0,r9
000586  f7fffffe          BL       Delay_us
                  |L1.1418|
;;;637    		 wkc = ecx_waitinframe_red(port, idx, timeout); 
00058a  463a              MOV      r2,r7
00058c  4651              MOV      r1,r10
00058e  4640              MOV      r0,r8
000590  f7fffffe          BL       ecx_waitinframe_red
000594  0004              MOVS     r4,r0
;;;638       /* wait for answer with WKC>=0 or otherwise retry until timeout */   
;;;639       } while ((wkc <= EC_NOFRAME) && ((bsp_GetTickCount()-timer2)<timeout));
000596  d508              BPL      |L1.1450|
000598  f7fffffe          BL       bsp_GetTickCount
00059c  1b80              SUBS     r0,r0,r6
00059e  42b8              CMP      r0,r7
0005a0  d3e9              BCC      |L1.1398|
;;;640       /* if nothing received, clear buffer index status so it can be used again */
;;;641    	 if (wkc <= EC_NOFRAME) 
;;;642    			 {
;;;643    				ec_setbufstat(idx, EC_BUF_EMPTY);
0005a2  2100              MOVS     r1,#0
0005a4  4650              MOV      r0,r10
0005a6  f7fffffe          BL       ec_setbufstat
                  |L1.1450|
;;;644    			 } 
;;;645       return wkc;
0005aa  4620              MOV      r0,r4
;;;646    }
0005ac  e593              B        |L1.214|
;;;647    
                          ENDP

                  ec_getindex PROC
;;;651    
;;;652    int ec_getindex(void)
0005ae  480c              LDR      r0,|L1.1504|
;;;653    {
;;;654       return ecx_getindex(&ecx_port);
0005b0  e7fe              B        ecx_getindex
;;;655    }
;;;656    
                          ENDP

                  ec_outframe PROC
;;;661    
;;;662    int ec_outframe(int idx, int stacknumber)
0005b2  460a              MOV      r2,r1
;;;663    {
;;;664       return ecx_outframe(&ecx_port, idx, stacknumber);
0005b4  4601              MOV      r1,r0
0005b6  480a              LDR      r0,|L1.1504|
0005b8  e7fe              B        ecx_outframe
;;;665    }
;;;666    
                          ENDP

                  ec_outframe_red PROC
;;;667    int ec_outframe_red(int idx)
0005ba  4601              MOV      r1,r0
;;;668    {
;;;669       return ecx_outframe_red(&ecx_port, idx);
0005bc  4808              LDR      r0,|L1.1504|
0005be  e7fe              B        ecx_outframe_red
;;;670    }
;;;671    
                          ENDP

                  ec_inframe PROC
;;;672    int ec_inframe(int idx, int stacknumber)
0005c0  460a              MOV      r2,r1
;;;673    {
;;;674       return ecx_inframe(&ecx_port, idx, stacknumber);
0005c2  4601              MOV      r1,r0
0005c4  4806              LDR      r0,|L1.1504|
0005c6  e7fe              B        ecx_inframe
;;;675    }
;;;676    
                          ENDP

                  ec_srconfirm PROC
;;;677    int ec_srconfirm(int idx, int timeout)
0005c8  460a              MOV      r2,r1
;;;678    {
;;;679       return ecx_srconfirm(&ecx_port, idx, timeout);
0005ca  4601              MOV      r1,r0
0005cc  4804              LDR      r0,|L1.1504|
0005ce  e7fe              B        ecx_srconfirm
;;;680    }
;;;681    
                          ENDP

                  ecx_clear_rxbufstat PROC
;;;120    
;;;121    static void ecx_clear_rxbufstat(int *rxbufstat)
0005d0  2100              MOVS     r1,#0
;;;122    {
;;;123       int i;
;;;124       for(i = 0; i < EC_MAXBUF; i++)
0005d2  460a              MOV      r2,r1
                  |L1.1492|
;;;125       {
;;;126          rxbufstat[i] = EC_BUF_EMPTY;
0005d4  f8402021          STR      r2,[r0,r1,LSL #2]
0005d8  1c49              ADDS     r1,r1,#1
0005da  2910              CMP      r1,#0x10              ;124
0005dc  dbfa              BLT      |L1.1492|
;;;127       }
;;;128    }
0005de  4770              BX       lr
;;;129    
                          ENDP

                  |L1.1504|
                          DCD      ecx_port
                  |L1.1508|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  priMAC
000000  01010101          DCW      0x0101,0x0101
000004  0101              DCW      0x0101

                          AREA ||area_number.5||, DATA, READONLY, ALIGN=1

                          EXPORTAS ||area_number.5||, ||.constdata||
                  secMAC
000000  04040404          DCW      0x0404,0x0404
000004  0404              DCW      0x0404

                          AREA ||.data||, DATA, ALIGN=0

                  DM9000_LINK_OK
000000  00                DCB      0x00
                  DM9161_LINK_OK
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\ETHERCAT\\nicdrv.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_nicdrv_c_priMAC____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___8_nicdrv_c_priMAC____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_nicdrv_c_priMAC____REVSH|
#line 144
|__asm___8_nicdrv_c_priMAC____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
