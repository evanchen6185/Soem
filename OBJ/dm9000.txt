; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\dm9000.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\dm9000.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\CORE -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\FWLIB\STM32F4xx_StdPeriph_Driver\inc -I..\USER -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\ETHERNET -I..\HARDWARE\TIMER -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\RTC -I..\HARDWARE\ADC -I..\HARDWARE\SRAM -I..\HARDWARE\InterTemperate -I..\FWLIB\STM32F4x7_ETH_Driver\inc -I..\MALLOC -I..\USMART -I..\HARDWARE -I..\ETHERCAT -I.\RTE\_LWIP -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS --omf_browse=..\obj\dm9000.crf ..\HARDWARE\ETHERNET\DM9000.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  dm9k_WriteReg PROC
;;;305    */
;;;306    void dm9k_WriteReg(uint8_t reg, uint8_t writedata)
000000  4af7              LDR      r2,|L1.992|
;;;307    {
;;;308    	NET_REG_ADDR = reg;
000002  8010              STRH     r0,[r2,#0]
;;;309    	NET_REG_DATA = writedata;
000004  48f7              LDR      r0,|L1.996|
000006  8001              STRH     r1,[r0,#0]
;;;310    }
000008  4770              BX       lr
;;;311    
                          ENDP

                  dm9k_hash_table PROC
;;;319    */
;;;320    void dm9k_hash_table(void)
00000a  b510              PUSH     {r4,lr}
;;;321    {
;;;322    	uint8_t i;
;;;323    
;;;324    //	/* 将MAC地址告诉uip */
;;;325    //	for (i = 0; i < 6; i++)
;;;326    //	{
;;;327    //		uip_ethaddr.addr[i] = DEF_MAC_ADDR[i];
;;;328    //	}
;;;329    
;;;330    	/* 设置 网卡 MAC 位置，来自於 MyHardware */
;;;331    	for(i = 0; i < 6; i++)
;;;332    	{
;;;333    		dm9k_WriteReg(DM9000_REG_PAR + i, DEF_MAC_ADDR[i]);
00000c  4cf6              LDR      r4,|L1.1000|
00000e  2300              MOVS     r3,#0                 ;331
                  |L1.16|
000010  f1030010          ADD      r0,r3,#0x10
000014  5ce1              LDRB     r1,[r4,r3]
000016  b2c0              UXTB     r0,r0
000018  f7fffffe          BL       dm9k_WriteReg
00001c  1c5b              ADDS     r3,r3,#1
00001e  b2db              UXTB     r3,r3                 ;331
000020  2b06              CMP      r3,#6                 ;331
000022  d3f5              BCC      |L1.16|
;;;334    	}
;;;335    
;;;336    	/* 清除 网卡多播设置 */
;;;337    	for(i = 0; i < 8; i++)
000024  2300              MOVS     r3,#0
                  |L1.38|
;;;338    	{
;;;339    		dm9k_WriteReg(DM9000_REG_MAR + i, 0xFF);
000026  f1030016          ADD      r0,r3,#0x16
00002a  b2c0              UXTB     r0,r0
00002c  21ff              MOVS     r1,#0xff
00002e  f7fffffe          BL       dm9k_WriteReg
000032  1c5b              ADDS     r3,r3,#1
000034  b2db              UXTB     r3,r3                 ;337
000036  2b08              CMP      r3,#8                 ;337
000038  d3f5              BCC      |L1.38|
;;;340    	}
;;;341    
;;;342    //	/* 设置 广播包 设置 */
;;;343    //	dm9k_WriteReg(DM9000_REG_MAR + 7, 0x80);
;;;344    }
00003a  bd10              POP      {r4,pc}
;;;345    /*
                          ENDP

                  dm9k_ReadReg PROC
;;;290    */
;;;291    uint8_t dm9k_ReadReg(uint8_t reg)
00003c  49e8              LDR      r1,|L1.992|
;;;292    {
;;;293    	NET_REG_ADDR = reg;
00003e  8008              STRH     r0,[r1,#0]
;;;294    	return (NET_REG_DATA);
000040  48e8              LDR      r0,|L1.996|
000042  8800              LDRH     r0,[r0,#0]
000044  b2c0              UXTB     r0,r0
;;;295    }
000046  4770              BX       lr
;;;296    
                          ENDP

                  dm9k_phy_write PROC
;;;423    */
;;;424    void dm9k_phy_write(uint8_t phy_reg, uint16_t writedata)
000048  460b              MOV      r3,r1
;;;425    {
00004a  b510              PUSH     {r4,lr}
;;;426    	/* 设置写入 PHY 寄存器的位置 */
;;;427    	dm9k_WriteReg(DM9000_REG_EPAR, phy_reg | DM9000_PHY);
00004c  f0400140          ORR      r1,r0,#0x40
000050  200c              MOVS     r0,#0xc
000052  f7fffffe          BL       dm9k_WriteReg
;;;428    
;;;429    	/* 设置写入 PHY 寄存器的值 */
;;;430    	dm9k_WriteReg(DM9000_REG_EPDRH, ( writedata >> 8 ) & 0xff);
000056  0a19              LSRS     r1,r3,#8
000058  200e              MOVS     r0,#0xe
00005a  f7fffffe          BL       dm9k_WriteReg
;;;431    	dm9k_WriteReg(DM9000_REG_EPDRL, writedata & 0xff);
00005e  b2d9              UXTB     r1,r3
000060  200d              MOVS     r0,#0xd
000062  f7fffffe          BL       dm9k_WriteReg
;;;432    
;;;433    	dm9k_WriteReg(DM9000_REG_EPCR, 0x0a); 						/* 将资料写入 PHY 寄存器 */
000066  210a              MOVS     r1,#0xa
000068  200b              MOVS     r0,#0xb
00006a  f7fffffe          BL       dm9k_WriteReg
                  |L1.110|
;;;434    	while(dm9k_ReadReg(DM9000_REG_EPCR) & 0x01);					/* 查寻是否执行结束 */
00006e  200b              MOVS     r0,#0xb
000070  f7fffffe          BL       dm9k_ReadReg
000074  07c0              LSLS     r0,r0,#31
000076  d1fa              BNE      |L1.110|
;;;435    	Delay_ms(50);
000078  2032              MOVS     r0,#0x32
00007a  f7fffffe          BL       Delay_ms
;;;436    //	dm9k_WriteReg(DM9000_REG_EPCR, 0x08); 						/* 清除写入命令 */
;;;437    	 dm9k_WriteReg(DM9000_REG_EPCR, 0x00); 	
00007e  2100              MOVS     r1,#0
000080  e8bd4010          POP      {r4,lr}
000084  200b              MOVS     r0,#0xb
000086  e7fe              B        dm9k_WriteReg
;;;438    }
;;;439    
                          ENDP

                  dm9k_reset PROC
;;;379    */
;;;380    void dm9k_reset(void)
000088  b570              PUSH     {r4-r6,lr}
;;;381    {
;;;382    	
;;;383    //复位DM9000,复位步骤参考<DM9000 Application Notes V1.22>手册29页
;;;384    	DM9000_RST;								//DM9000硬件复位
00008a  4dd8              LDR      r5,|L1.1004|
00008c  f44f7400          MOV      r4,#0x200
000090  4621              MOV      r1,r4
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       GPIO_ResetBits
;;;385    	Delay_ms(20);
000098  2014              MOVS     r0,#0x14
00009a  f7fffffe          BL       Delay_ms
;;;386    	DM9000_SET; 							//DM9000硬件复位结束
00009e  4621              MOV      r1,r4
0000a0  4628              MOV      r0,r5
0000a2  f7fffffe          BL       GPIO_SetBits
;;;387    	Delay_ms(100);								//一定要有这个延时，让DM9000准备就绪！
0000a6  2064              MOVS     r0,#0x64
0000a8  f7fffffe          BL       Delay_ms
;;;388     	dm9k_WriteReg(DM9000_REG_GPCR,0x01);			//第一步:设置GPCR寄存器(0X1E)的bit0为1 
0000ac  2101              MOVS     r1,#1
0000ae  201e              MOVS     r0,#0x1e
0000b0  f7fffffe          BL       dm9k_WriteReg
;;;389    	dm9k_WriteReg(DM9000_REG_GPR,0);				//第二步:设置GPR寄存器(0X1F)的bit1为0，DM9000内部的PHY上电
0000b4  2100              MOVS     r1,#0
0000b6  201f              MOVS     r0,#0x1f
0000b8  f7fffffe          BL       dm9k_WriteReg
;;;390    	Delay_ms(20);                          //延时2ms以上等待PHY上电
0000bc  2014              MOVS     r0,#0x14
0000be  f7fffffe          BL       Delay_ms
;;;391     	dm9k_WriteReg(DM9000_REG_NCR,0x03);	   //第三步:软件复位DM9000 
0000c2  2103              MOVS     r1,#3
0000c4  2000              MOVS     r0,#0
0000c6  f7fffffe          BL       dm9k_WriteReg
                  |L1.202|
;;;392      do 
;;;393    	{ 
;;;394    		Delay_ms(1); 
0000ca  2001              MOVS     r0,#1
0000cc  f7fffffe          BL       Delay_ms
;;;395    	}while(dm9k_ReadReg(DM9000_REG_NCR)&1);		//等待DM9000软复位完成
0000d0  2000              MOVS     r0,#0
0000d2  f7fffffe          BL       dm9k_ReadReg
0000d6  07c0              LSLS     r0,r0,#31
0000d8  d1f7              BNE      |L1.202|
;;;396    	dm9k_WriteReg(DM9000_REG_NCR,0x00);	   //第四步:软件复位完成，进入正常工作模式 
0000da  2100              MOVS     r1,#0
0000dc  4608              MOV      r0,r1
0000de  f7fffffe          BL       dm9k_WriteReg
;;;397    	dm9k_WriteReg(DM9000_REG_NCR,0x03);	   //第五步:第二次软件复位DM9000 
0000e2  2103              MOVS     r1,#3
0000e4  2000              MOVS     r0,#0
0000e6  f7fffffe          BL       dm9k_WriteReg
                  |L1.234|
;;;398    	do 
;;;399    	{
;;;400    		Delay_ms(1);
0000ea  2001              MOVS     r0,#1
0000ec  f7fffffe          BL       Delay_ms
;;;401    	}while(dm9k_ReadReg(DM9000_REG_NCR)&1);		//等待DM9000软复位完成
0000f0  2000              MOVS     r0,#0
0000f2  f7fffffe          BL       dm9k_ReadReg
0000f6  07c0              LSLS     r0,r0,#31
0000f8  d1f7              BNE      |L1.234|
;;;402    	dm9k_WriteReg(DM9000_REG_NCR,0x00);	   //第六步:软件复位完成，进入正常工作模式 	
0000fa  2100              MOVS     r1,#0
0000fc  4608              MOV      r0,r1
0000fe  f7fffffe          BL       dm9k_WriteReg
;;;403    		/* 基本记存器相关设置 */
;;;404    	dm9k_WriteReg(DM9000_REG_IMR, DM9000_IMR_OFF); 			/* 开启内存自环模式 */
000102  2180              MOVS     r1,#0x80
000104  20ff              MOVS     r0,#0xff
000106  f7fffffe          BL       dm9k_WriteReg
;;;405    	dm9k_WriteReg(DM9000_REG_TCR2, DM9000_TCR2_SET);			/* 设置 LED 显示模式1:全双工亮，半双工灭 */
00010a  2180              MOVS     r1,#0x80
00010c  202d              MOVS     r0,#0x2d
00010e  f7fffffe          BL       dm9k_WriteReg
;;;406    	/* 清除多余资讯 */
;;;407    	dm9k_WriteReg(DM9000_REG_NSR, 0x2c);
000112  212c              MOVS     r1,#0x2c
000114  2001              MOVS     r0,#1
000116  f7fffffe          BL       dm9k_WriteReg
;;;408    	dm9k_WriteReg(DM9000_REG_TCR, 0x00);
00011a  2100              MOVS     r1,#0
00011c  2002              MOVS     r0,#2
00011e  f7fffffe          BL       dm9k_WriteReg
;;;409    	dm9k_WriteReg(DM9000_REG_ISR, 0x0f);
000122  210f              MOVS     r1,#0xf
000124  20fe              MOVS     r0,#0xfe
000126  f7fffffe          BL       dm9k_WriteReg
;;;410    	dm9k_WriteReg(DM9000_REG_RCR, DM9000_RCR_SET);			/* 开启 接收工能 */
00012a  2133              MOVS     r1,#0x33
00012c  2005              MOVS     r0,#5
00012e  f7fffffe          BL       dm9k_WriteReg
;;;411    	dm9k_WriteReg(DM9000_REG_IMR, DM9000_IMR_OFF);			/* 关闭 中断模式 */
000132  2180              MOVS     r1,#0x80
000134  20ff              MOVS     r0,#0xff
000136  f7fffffe          BL       dm9k_WriteReg
;;;412    	SendPackOk = 0;
00013a  49ab              LDR      r1,|L1.1000|
00013c  2000              MOVS     r0,#0
00013e  1f09              SUBS     r1,r1,#4
000140  7008              STRB     r0,[r1,#0]
;;;413    }
000142  bd70              POP      {r4-r6,pc}
;;;414    
                          ENDP

                  DM9000_Initnic PROC
;;;447    */
;;;448    void DM9000_Initnic(void)
000144  b510              PUSH     {r4,lr}
;;;449    {
;;;450    	
;;;451    	dm9k_reset();									//复位DM9000
000146  f7fffffe          BL       dm9k_reset
;;;452    	
;;;453    	dm9k_WriteReg(DM9000_REG_GPR, DM9000_PHY_OFF);			/* 关闭 PHY ，进行 PHY 设置*/
00014a  2101              MOVS     r1,#1
00014c  201f              MOVS     r0,#0x1f
00014e  f7fffffe          BL       dm9k_WriteReg
;;;454    	dm9k_phy_write(0x00, 0x8000);					/* 重置 PHY 的寄存器 */
000152  f44f4100          MOV      r1,#0x8000
000156  2000              MOVS     r0,#0
000158  f7fffffe          BL       dm9k_phy_write
;;;455    	dm9k_phy_write(0x04, 0x01e1);					/* 设置 自适应模式相容表 */
00015c  f24011e1          MOV      r1,#0x1e1
000160  2004              MOVS     r0,#4
000162  f7fffffe          BL       dm9k_phy_write
;;;456    	//dm9k_phy_write(0x00, 0x1000);					/* 设置 基本连接模式 */
;;;457    	/* 连接模式设置
;;;458    	  0x0000 : 固定10M半双工
;;;459    	  0x0100 : 固定10M全双工
;;;460    	  0x2000 : 固定100M半双工
;;;461    	  0x2100 : 固定100M全双工
;;;462    	  0x1000 : 自适应模式
;;;463    	*/
;;;464    	dm9k_phy_write(0x00, 0x1000);				/* 设置 基本连接模式 */
000166  f44f5180          MOV      r1,#0x1000
00016a  2000              MOVS     r0,#0
00016c  f7fffffe          BL       dm9k_phy_write
;;;465    	Delay_ms(2000);
000170  f44f64fa          MOV      r4,#0x7d0
000174  4620              MOV      r0,r4
000176  f7fffffe          BL       Delay_ms
;;;466    	dm9k_WriteReg(DM9000_REG_GPR, DM9000_PHY_ON);				/* 结束 PHY 设置, 开启 PHY */
00017a  2100              MOVS     r1,#0
00017c  201f              MOVS     r0,#0x1f
00017e  f7fffffe          BL       dm9k_WriteReg
;;;467    	Delay_ms(2000);
000182  4620              MOV      r0,r4
000184  f7fffffe          BL       Delay_ms
;;;468    	dm9k_hash_table();								/* 设置 DM9000A MAC 及 多播*/
000188  e8bd4010          POP      {r4,lr}
00018c  e7fe              B        dm9k_hash_table
;;;469    	
;;;470    }
;;;471    
                          ENDP

                  DM9K_FSMCConfig PROC
;;;193    */
;;;194    static void DM9K_FSMCConfig(void)
00018e  b500              PUSH     {lr}
;;;195    {
000190  b097              SUB      sp,sp,#0x5c
;;;196    	FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;197    	FSMC_NORSRAMTimingInitTypeDef  p;
;;;198    
;;;199    	/*-- FSMC Configuration ------------------------------------------------------*/
;;;200    	/*----------------------- SRAM Bank 3 ----------------------------------------*/
;;;201    	/*-- FSMC Configuration ------------------------------------------------------*/
;;;202    	p.FSMC_AddressSetupTime = 8;		/* 设置为2会出错; 3正常 */
000192  2008              MOVS     r0,#8
;;;203    	p.FSMC_AddressHoldTime = 0;
000194  900f              STR      r0,[sp,#0x3c]
000196  2000              MOVS     r0,#0
;;;204    	p.FSMC_DataSetupTime = 10;			/* 设置为1出错，2正常 */
000198  210a              MOVS     r1,#0xa
00019a  e9cd0110          STRD     r0,r1,[sp,#0x40]
;;;205    	p.FSMC_BusTurnAroundDuration = 0;
;;;206    	p.FSMC_CLKDivision = 0;
;;;207    	p.FSMC_DataLatency = 0;
;;;208    	p.FSMC_AccessMode = FSMC_AccessMode_A;
00019e  9014              STR      r0,[sp,#0x50]
;;;209     
;;;210    //	p.FSMC_AddressSetupTime = 0;		/* 设置为2会出错; 3正常 */
;;;211    //	p.FSMC_AddressHoldTime = 0;
;;;212    //	p.FSMC_DataSetupTime = 3;			/* 设置为1出错，2正常 */
;;;213    //	p.FSMC_BusTurnAroundDuration = 0x00;
;;;214    //	p.FSMC_CLKDivision = 0x00;
;;;215    //	p.FSMC_DataLatency = 0x00;
;;;216    //	p.FSMC_AccessMode = FSMC_AccessMode_A;
;;;217    //	
;;;218    	
;;;219    	
;;;220    	FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM3;
0001a0  2104              MOVS     r1,#4
0001a2  9015              STR      r0,[sp,#0x54]
0001a4  e9cd1000          STRD     r1,r0,[sp,#0]
0001a8  9012              STR      r0,[sp,#0x48]         ;206
;;;221    	FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
;;;222    	FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM;	// FSMC_MemoryType_PSRAM;
;;;223    	FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
0001aa  2110              MOVS     r1,#0x10
0001ac  e9cd0102          STRD     r0,r1,[sp,#8]
0001b0  9013              STR      r0,[sp,#0x4c]         ;207
;;;224    	FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
;;;225    	FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
0001b2  9004              STR      r0,[sp,#0x10]
;;;226    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
0001b4  9005              STR      r0,[sp,#0x14]
;;;227    	FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
0001b6  9006              STR      r0,[sp,#0x18]
;;;228    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;229    	FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
0001b8  0209              LSLS     r1,r1,#8
0001ba  9007              STR      r0,[sp,#0x1c]
0001bc  e9cd0108          STRD     r0,r1,[sp,#0x20]
;;;230    	FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
;;;231    	FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
0001c0  900a              STR      r0,[sp,#0x28]
;;;232    	FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
0001c2  900b              STR      r0,[sp,#0x2c]
;;;233    	FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &p;
0001c4  900c              STR      r0,[sp,#0x30]
0001c6  a80f              ADD      r0,sp,#0x3c
;;;234    	FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &p;
0001c8  900d              STR      r0,[sp,#0x34]
;;;235    
;;;236    	FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);
0001ca  900e              STR      r0,[sp,#0x38]
0001cc  4668              MOV      r0,sp
0001ce  f7fffffe          BL       FSMC_NORSRAMInit
;;;237    
;;;238    	/*!< Enable FSMC Bank1_SRAM3 Bank */
;;;239    	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM3, ENABLE);
0001d2  2101              MOVS     r1,#1
0001d4  2004              MOVS     r0,#4
0001d6  f7fffffe          BL       FSMC_NORSRAMCmd
;;;240    	
;;;241    	
;;;242    	
;;;243    //	    FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;244    //    FSMC_NORSRAMTimingInitTypeDef  FSMC_NORSRAMTimingInitStructure;
;;;245    //    FSMC_NORSRAMTimingInitStructure.FSMC_AddressSetupTime = 10;             /* ??????*/
;;;246    //    FSMC_NORSRAMTimingInitStructure.FSMC_AddressHoldTime = 0;      
;;;247    //    FSMC_NORSRAMTimingInitStructure.FSMC_DataSetupTime = 10;                /* ??????*/
;;;248    //    FSMC_NORSRAMTimingInitStructure.FSMC_BusTurnAroundDuration = 0x00;
;;;249    //    FSMC_NORSRAMTimingInitStructure.FSMC_CLKDivision = 0x00;
;;;250    //    FSMC_NORSRAMTimingInitStructure.FSMC_DataLatency = 0x00;
;;;251    //    FSMC_NORSRAMTimingInitStructure.FSMC_AccessMode = FSMC_AccessMode_A;    /* FSMC ????*/
;;;252    
;;;253    //    FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM3;
;;;254    //    FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
;;;255    //    FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;256    //    FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
;;;257    //    FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
;;;258    //    FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
;;;259    //    FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
;;;260    //    FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;261    //    FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
;;;262    //    FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
;;;263    //    FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
;;;264    //    FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
;;;265    //    FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
;;;266    //    FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &FSMC_NORSRAMTimingInitStructure;
;;;267    //    FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure); 
;;;268    //    /* ??FSMC???*/
;;;269    //    FSMC_NORSRAMTimingInitStructure.FSMC_AddressSetupTime = 5;              /* ??????*/
;;;270    //    FSMC_NORSRAMTimingInitStructure.FSMC_AddressHoldTime = 0;      
;;;271    //    FSMC_NORSRAMTimingInitStructure.FSMC_DataSetupTime = 5;                 /* ??????*/
;;;272    //    FSMC_NORSRAMTimingInitStructure.FSMC_BusTurnAroundDuration = 0x00;
;;;273    //    FSMC_NORSRAMTimingInitStructure.FSMC_CLKDivision = 0x00;
;;;274    //    FSMC_NORSRAMTimingInitStructure.FSMC_DataLatency = 0x00;
;;;275    //    FSMC_NORSRAMTimingInitStructure.FSMC_AccessMode = FSMC_AccessMode_A;    /* FSMC????*/
;;;276    //    FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &FSMC_NORSRAMTimingInitStructure; 
;;;277    //	  FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);
;;;278    
;;;279    //	  /*!< Enable FSMC Bank1_SRAM3 Bank */
;;;280    //	  FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM3, ENABLE);		
;;;281    }
0001da  b017              ADD      sp,sp,#0x5c
0001dc  bd00              POP      {pc}
;;;282    
                          ENDP

                  DM9K_CtrlLinesConfig PROC
;;;88     */
;;;89     static void DM9K_CtrlLinesConfig(void)
0001de  e92d41fc          PUSH     {r2-r8,lr}
;;;90     {
;;;91     	GPIO_InitTypeDef GPIO_InitStructure;
;;;92       EXTI_InitTypeDef EXTI_InitStructure;
;;;93       NVIC_InitTypeDef NVIC_InitStructure;
;;;94     	
;;;95     	/* 使能FSMC时钟 */
;;;96     	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
0001e2  2101              MOVS     r1,#1
0001e4  4608              MOV      r0,r1
0001e6  f7fffffe          BL       RCC_AHB3PeriphClockCmd
;;;97     
;;;98     	/* 使能 GPIO时钟 */
;;;99     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA|RCC_AHB1Periph_GPIOC|RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOE | RCC_AHB1Periph_GPIOG, ENABLE);
0001ea  2101              MOVS     r1,#1
0001ec  205d              MOVS     r0,#0x5d
0001ee  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;100      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
0001f2  2101              MOVS     r1,#1
0001f4  0388              LSLS     r0,r1,#14
0001f6  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;101    	/* 设置 PD.00(D2), PD.01(D3), PD.04(NOE), PD.05(NWE), PD.08(D13), PD.09(D14),
;;;102    	 PD.10(D15), PD.14(D0), PD.15(D1) 为复用推挽输出 */
;;;103    
;;;104    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);
0001fa  4e7d              LDR      r6,|L1.1008|
0001fc  220c              MOVS     r2,#0xc
0001fe  2100              MOVS     r1,#0
000200  4630              MOV      r0,r6
000202  f7fffffe          BL       GPIO_PinAFConfig
;;;105    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);
000206  220c              MOVS     r2,#0xc
000208  2101              MOVS     r1,#1
00020a  4630              MOV      r0,r6
00020c  f7fffffe          BL       GPIO_PinAFConfig
;;;106    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FSMC);
000210  220c              MOVS     r2,#0xc
000212  2104              MOVS     r1,#4
000214  4630              MOV      r0,r6
000216  f7fffffe          BL       GPIO_PinAFConfig
;;;107    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FSMC);
00021a  220c              MOVS     r2,#0xc
00021c  2105              MOVS     r1,#5
00021e  4630              MOV      r0,r6
000220  f7fffffe          BL       GPIO_PinAFConfig
;;;108    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FSMC);
000224  220c              MOVS     r2,#0xc
000226  2108              MOVS     r1,#8
000228  4630              MOV      r0,r6
00022a  f7fffffe          BL       GPIO_PinAFConfig
;;;109    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FSMC);
00022e  220c              MOVS     r2,#0xc
000230  2109              MOVS     r1,#9
000232  4630              MOV      r0,r6
000234  f7fffffe          BL       GPIO_PinAFConfig
;;;110    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
000238  220c              MOVS     r2,#0xc
00023a  210a              MOVS     r1,#0xa
00023c  4630              MOV      r0,r6
00023e  f7fffffe          BL       GPIO_PinAFConfig
;;;111    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
000242  220c              MOVS     r2,#0xc
000244  210e              MOVS     r1,#0xe
000246  4630              MOV      r0,r6
000248  f7fffffe          BL       GPIO_PinAFConfig
;;;112    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
00024c  220c              MOVS     r2,#0xc
00024e  210f              MOVS     r1,#0xf
000250  4630              MOV      r0,r6
000252  f7fffffe          BL       GPIO_PinAFConfig
;;;113    
;;;114    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 |
000256  f24c7033          MOV      r0,#0xc733
;;;115    	                            GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 |
;;;116    	                            GPIO_Pin_15;
;;;117    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00025a  9000              STR      r0,[sp,#0]
00025c  2002              MOVS     r0,#2
00025e  f88d0004          STRB     r0,[sp,#4]
;;;118    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000262  2503              MOVS     r5,#3
000264  f88d5005          STRB     r5,[sp,#5]
;;;119    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000268  2400              MOVS     r4,#0
00026a  f88d4006          STRB     r4,[sp,#6]
;;;120    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
00026e  f88d4007          STRB     r4,[sp,#7]
;;;121    	GPIO_Init(GPIOD, &GPIO_InitStructure);
000272  4669              MOV      r1,sp
000274  4630              MOV      r0,r6
000276  f7fffffe          BL       GPIO_Init
;;;122    
;;;123    	/* 设置 PE.07(D4), PE.08(D5), PE.09(D6), PE.10(D7), PE.11(D8), PE.12(D9), PE.13(D10),
;;;124    	 PE.14(D11), PE.15(D12) 为复用推挽输出 */
;;;125    
;;;126    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource4 , GPIO_AF_FSMC);
00027a  4f5e              LDR      r7,|L1.1012|
00027c  220c              MOVS     r2,#0xc
00027e  2104              MOVS     r1,#4
000280  4638              MOV      r0,r7
000282  f7fffffe          BL       GPIO_PinAFConfig
;;;127    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource5 , GPIO_AF_FSMC);
000286  220c              MOVS     r2,#0xc
000288  2105              MOVS     r1,#5
00028a  4638              MOV      r0,r7
00028c  f7fffffe          BL       GPIO_PinAFConfig
;;;128    
;;;129    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FSMC);
000290  220c              MOVS     r2,#0xc
000292  2107              MOVS     r1,#7
000294  4638              MOV      r0,r7
000296  f7fffffe          BL       GPIO_PinAFConfig
;;;130    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FSMC);
00029a  220c              MOVS     r2,#0xc
00029c  2108              MOVS     r1,#8
00029e  4638              MOV      r0,r7
0002a0  f7fffffe          BL       GPIO_PinAFConfig
;;;131    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FSMC);
0002a4  220c              MOVS     r2,#0xc
0002a6  2109              MOVS     r1,#9
0002a8  4638              MOV      r0,r7
0002aa  f7fffffe          BL       GPIO_PinAFConfig
;;;132    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource10 , GPIO_AF_FSMC);
0002ae  220c              MOVS     r2,#0xc
0002b0  210a              MOVS     r1,#0xa
0002b2  4638              MOV      r0,r7
0002b4  f7fffffe          BL       GPIO_PinAFConfig
;;;133    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource11 , GPIO_AF_FSMC);
0002b8  220c              MOVS     r2,#0xc
0002ba  210b              MOVS     r1,#0xb
0002bc  4638              MOV      r0,r7
0002be  f7fffffe          BL       GPIO_PinAFConfig
;;;134    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource12 , GPIO_AF_FSMC);
0002c2  220c              MOVS     r2,#0xc
0002c4  4611              MOV      r1,r2
0002c6  4638              MOV      r0,r7
0002c8  f7fffffe          BL       GPIO_PinAFConfig
;;;135    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource13 , GPIO_AF_FSMC);
0002cc  220c              MOVS     r2,#0xc
0002ce  210d              MOVS     r1,#0xd
0002d0  4638              MOV      r0,r7
0002d2  f7fffffe          BL       GPIO_PinAFConfig
;;;136    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource14 , GPIO_AF_FSMC);
0002d6  220c              MOVS     r2,#0xc
0002d8  210e              MOVS     r1,#0xe
0002da  4638              MOV      r0,r7
0002dc  f7fffffe          BL       GPIO_PinAFConfig
;;;137    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource15 , GPIO_AF_FSMC);
0002e0  220c              MOVS     r2,#0xc
0002e2  210f              MOVS     r1,#0xf
0002e4  4638              MOV      r0,r7
0002e6  f7fffffe          BL       GPIO_PinAFConfig
;;;138    
;;;139    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
0002ea  f64f70b0          MOV      r0,#0xffb0
;;;140    	                            GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 |
;;;141    	                            GPIO_Pin_15;
;;;142    	GPIO_Init(GPIOE, &GPIO_InitStructure);
0002ee  9000              STR      r0,[sp,#0]
0002f0  4669              MOV      r1,sp
0002f2  4638              MOV      r0,r7
0002f4  f7fffffe          BL       GPIO_Init
;;;143    
;;;144    	/* 设置 PD.13(A18 (RS))  为复用推挽输出 */
;;;145    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_FSMC);
0002f8  220c              MOVS     r2,#0xc
0002fa  210d              MOVS     r1,#0xd
0002fc  4630              MOV      r0,r6
0002fe  f7fffffe          BL       GPIO_PinAFConfig
;;;146    
;;;147    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
000302  f44f5000          MOV      r0,#0x2000
;;;148    	GPIO_Init(GPIOD, &GPIO_InitStructure);
000306  9000              STR      r0,[sp,#0]
000308  4669              MOV      r1,sp
00030a  4630              MOV      r0,r6
00030c  f7fffffe          BL       GPIO_Init
;;;149    
;;;150    	/* 设置 PG10 (CS)) 为复用推挽输出 */
;;;151    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource10, GPIO_AF_FSMC);
000310  4e39              LDR      r6,|L1.1016|
000312  220c              MOVS     r2,#0xc
000314  210a              MOVS     r1,#0xa
000316  4630              MOV      r0,r6
000318  f7fffffe          BL       GPIO_PinAFConfig
;;;152    
;;;153    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00031c  1531              ASRS     r1,r6,#20
;;;154    	GPIO_Init(GPIOG, &GPIO_InitStructure);
00031e  9100              STR      r1,[sp,#0]
000320  4669              MOV      r1,sp
000322  4630              MOV      r0,r6
000324  f7fffffe          BL       GPIO_Init
;;;155    
;;;156    //	/* PA15 是DM9000_INT中断输入口(本程序未使用) */
;;;157    //  /* Connect EXTI Line to INT Pin */
;;;158    //  SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource15);
;;;159    	/*dm9000复位硬引脚*/
;;;160    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; 		//PC9 推挽输出 
;;;161    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;//推挽输出
000328  2001              MOVS     r0,#1
00032a  f88d0004          STRB     r0,[sp,#4]
;;;162    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
00032e  f88d5005          STRB     r5,[sp,#5]
;;;163    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000332  f88d4006          STRB     r4,[sp,#6]
;;;164    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000336  f88d4007          STRB     r4,[sp,#7]
;;;165    	GPIO_Init(GPIOC,&GPIO_InitStructure);
00033a  4c2c              LDR      r4,|L1.1004|
00033c  1576              ASRS     r6,r6,#21             ;160
00033e  9600              STR      r6,[sp,#0]            ;161
000340  4669              MOV      r1,sp
000342  4620              MOV      r0,r4
000344  f7fffffe          BL       GPIO_Init
;;;166    
;;;167    	DM9000_RST;								//DM9000硬件复位
000348  4631              MOV      r1,r6
00034a  4620              MOV      r0,r4
00034c  f7fffffe          BL       GPIO_ResetBits
;;;168    	Delay_ms(1);
000350  2001              MOVS     r0,#1
000352  f7fffffe          BL       Delay_ms
;;;169    	DM9000_SET; 							//DM9000硬件复位结束
000356  4631              MOV      r1,r6
000358  4620              MOV      r0,r4
00035a  f7fffffe          BL       GPIO_SetBits
;;;170    	Delay_ms(200);								//一定要有这个延时，让DM9000准备就绪！
00035e  20c8              MOVS     r0,#0xc8
000360  f7fffffe          BL       Delay_ms
;;;171    	
;;;172    //  /* Configure EXTI line */
;;;173    //  EXTI_InitStructure.EXTI_Line = EXTI_Line15;
;;;174    //  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
;;;175    //  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
;;;176    //  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
;;;177    //  EXTI_Init(&EXTI_InitStructure);
;;;178    
;;;179    //  /* Enable and set the EXTI interrupt to priority 1*/
;;;180    //  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
;;;181    //  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;182    //  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;183    //  NVIC_Init(&NVIC_InitStructure);
;;;184    }
000364  e8bd81fc          POP      {r2-r8,pc}
;;;185    
                          ENDP

                  DM9000_Init PROC
;;;70     */
;;;71     void DM9000_Init(void)
000368  b510              PUSH     {r4,lr}
;;;72     {
;;;73     
;;;74     			DM9K_CtrlLinesConfig();
00036a  f7fffffe          BL       DM9K_CtrlLinesConfig
;;;75     			DM9K_FSMCConfig();
00036e  f7fffffe          BL       DM9K_FSMCConfig
;;;76     	    s_FSMC_Init_Ok = 1;
000372  491d              LDR      r1,|L1.1000|
000374  2001              MOVS     r0,#1
000376  1f09              SUBS     r1,r1,#4
000378  7048              STRB     r0,[r1,#1]
;;;77     
;;;78     	DM9000_Initnic();			/* 配置DM9000 */
00037a  e8bd4010          POP      {r4,lr}
00037e  e7fe              B        DM9000_Initnic
;;;79     }
;;;80     
                          ENDP

                  dm9k_err_reset PROC
;;;352    */
;;;353    void dm9k_err_reset(void)
000380  b510              PUSH     {r4,lr}
;;;354    {
;;;355     	dm9k_WriteReg(DM9000_REG_NCR,0x03);	   //第三步:软件复位DM9000 
000382  2103              MOVS     r1,#3
000384  2000              MOVS     r0,#0
000386  f7fffffe          BL       dm9k_WriteReg
;;;356    	Delay_us(10); 	
00038a  200a              MOVS     r0,#0xa
00038c  f7fffffe          BL       Delay_us
;;;357    	dm9k_WriteReg(DM9000_REG_NCR,0x03);	   //第五步:第二次软件复位DM9000 
000390  2103              MOVS     r1,#3
000392  2000              MOVS     r0,#0
000394  f7fffffe          BL       dm9k_WriteReg
;;;358    	Delay_us(10); 	
000398  200a              MOVS     r0,#0xa
00039a  f7fffffe          BL       Delay_us
;;;359    
;;;360    		/* 基本记存器相关设置 */
;;;361    	dm9k_WriteReg(DM9000_REG_IMR, DM9000_IMR_OFF); 			/* 开启内存自环模式 */
00039e  2180              MOVS     r1,#0x80
0003a0  20ff              MOVS     r0,#0xff
0003a2  f7fffffe          BL       dm9k_WriteReg
;;;362    	dm9k_WriteReg(DM9000_REG_TCR2, DM9000_TCR2_SET);			/* 设置 LED 显示模式1:全双工亮，半双工灭 */
0003a6  2180              MOVS     r1,#0x80
0003a8  202d              MOVS     r0,#0x2d
0003aa  f7fffffe          BL       dm9k_WriteReg
;;;363    	/* 清除多余资讯 */
;;;364    	dm9k_WriteReg(DM9000_REG_NSR, 0x2c);
0003ae  212c              MOVS     r1,#0x2c
0003b0  2001              MOVS     r0,#1
0003b2  f7fffffe          BL       dm9k_WriteReg
;;;365    	dm9k_WriteReg(DM9000_REG_TCR, 0x00);
0003b6  2100              MOVS     r1,#0
0003b8  2002              MOVS     r0,#2
0003ba  f7fffffe          BL       dm9k_WriteReg
;;;366    	dm9k_WriteReg(DM9000_REG_ISR, 0x0f);
0003be  210f              MOVS     r1,#0xf
0003c0  20fe              MOVS     r0,#0xfe
0003c2  f7fffffe          BL       dm9k_WriteReg
;;;367    	dm9k_WriteReg(DM9000_REG_RCR, DM9000_RCR_SET);			/* 开启 接收工能 */
0003c6  2133              MOVS     r1,#0x33
0003c8  2005              MOVS     r0,#5
0003ca  f7fffffe          BL       dm9k_WriteReg
;;;368    	dm9k_WriteReg(DM9000_REG_IMR, DM9000_IMR_OFF);			/* 关闭 中断模式 */
0003ce  2180              MOVS     r1,#0x80
0003d0  20ff              MOVS     r0,#0xff
0003d2  f7fffffe          BL       dm9k_WriteReg
;;;369    	SendPackOk = 0;
0003d6  4904              LDR      r1,|L1.1000|
0003d8  2000              MOVS     r0,#0
0003da  1f09              SUBS     r1,r1,#4
0003dc  7008              STRB     r0,[r1,#0]
                  |L1.990|
;;;370    }
0003de  bd10              POP      {r4,pc}
                  |L1.992|
                          DCD      0x68400000
                  |L1.996|
                          DCD      0x68480000
                  |L1.1000|
                          DCD      ||.data||+0x4
                  |L1.1004|
                          DCD      0x40020800
                  |L1.1008|
                          DCD      0x40020c00
                  |L1.1012|
                          DCD      0x40021000
                  |L1.1016|
                          DCD      0x40021800
                          ENDP

                  dm9k_receive_packet PROC
;;;479    */
;;;480    uint16_t dm9k_receive_packet(void)
0003fc  b570              PUSH     {r4-r6,lr}
;;;481    {
;;;482    	uint16_t ReceiveData[1600];
;;;483    	uint8_t  rx_int_count = 0;
;;;484    	u32  rx_checkbyte;
;;;485    	uint16_t rx_status, rx_length;
;;;486    	uint8_t  jump_packet;
;;;487    	uint16_t i;
;;;488    	uint16_t calc_len;
;;;489    	uint16_t calc_MRR;
;;;490    	uint16_t temp;
;;;491    	do
;;;492    	{
;;;493    		jump_packet = 0;								/* 清除跳包动作 */
;;;494    		dm9k_ReadReg(DM9000_REG_MRCMDX);							/* 读取内存数据，地址不增加 */
;;;495    		/* 计算内存数据位置 */
;;;496    		calc_MRR = (dm9k_ReadReg(DM9000_REG_MRRH) << 8) + dm9k_ReadReg(DM9000_REG_MRRL);
;;;497    		rx_checkbyte = dm9k_ReadReg(DM9000_REG_MRCMDX);			/*  */
;;;498    		if(rx_checkbyte == DM9000_PKT_RDY)				/* 取 */
;;;499    		{
;;;500    			/* 读取封包相关资讯 及 长度 */
;;;501    			NET_REG_ADDR = DM9000_REG_MRCMD;
;;;502    			rx_status = NET_REG_DATA;
0003fe  4b73              LDR      r3,|L1.1484|
000400  f5ad6d48          SUB      sp,sp,#0xc80          ;481
000404  2500              MOVS     r5,#0                 ;483
                  |L1.1030|
000406  2200              MOVS     r2,#0                 ;493
000408  20f0              MOVS     r0,#0xf0              ;494
00040a  f7fffffe          BL       dm9k_ReadReg
00040e  20f4              MOVS     r0,#0xf4              ;496
000410  f7fffffe          BL       dm9k_ReadReg
000414  4604              MOV      r4,r0                 ;496
000416  20f5              MOVS     r0,#0xf5              ;496
000418  f7fffffe          BL       dm9k_ReadReg
00041c  eb042000          ADD      r0,r4,r0,LSL #8       ;496
000420  b284              UXTH     r4,r0                 ;496
000422  20f0              MOVS     r0,#0xf0              ;497
000424  f7fffffe          BL       dm9k_ReadReg
000428  2801              CMP      r0,#1                 ;498
00042a  d007              BEQ      |L1.1084|
;;;503    			rx_length = NET_REG_DATA;
;;;504    			/* 若收到超过系统可承受的封包，此包跳过 */
;;;505    			if(rx_length > Max_Ethernet_Lenth)
;;;506    				jump_packet = 1;
;;;507    
;;;508    #ifdef Broadcast_Jump
;;;509    			/* 若收到的广播或多播包超过特定长度，此包跳过 */
;;;510    			if(rx_status & 0x4000)
;;;511    			{
;;;512    				if(rx_length > Max_Broadcast_Lenth)
;;;513    					jump_packet = 1;
;;;514    			}
;;;515    #endif
;;;516    			/* 计算下一个包的指针位 , 若接收长度为奇数，需加一对齐偶字节。*/
;;;517    			/* 若是超过 0x3fff ，则需回归绕到 0x0c00 起始位置 */
;;;518    			calc_MRR += (rx_length + 4);
;;;519    			if(rx_length & 0x01) calc_MRR++;
;;;520    			if(calc_MRR > 0x3fff) calc_MRR -= 0x3400;
;;;521    
;;;522    			if(jump_packet == 0x01)
;;;523    			{
;;;524    				/* 将指针移到下一个包的包头位置 */
;;;525    				dm9k_WriteReg (DM9000_REG_MRRH, (calc_MRR >> 8) & 0xff);
;;;526    				dm9k_WriteReg (DM9000_REG_MRRL, calc_MRR & 0xff );
;;;527    				continue;
;;;528    			}
;;;529    
;;;530    			/* 开始将内存的资料搬到到系统中，每次移动一个 word */
;;;531    			calc_len = (rx_length + 1) >> 1;
;;;532    			for(i = 0 ; i < calc_len ; i++)
;;;533    				ReceiveData[i] = NET_REG_DATA;
;;;534    
;;;535    			/* 将包长回报给 TCP/IP 上层，并减去最後 4 BYTE 的 CRC-32 检核码 */
;;;536    			receiveLen_DM9000 = rx_length - 4;
;;;537          memcpy((unsigned char*)receiveBuffer_DM9000,(uint8_t *)ReceiveData,receiveLen_DM9000);
;;;538    			rx_int_count++;								/* 累计收包次数 */
;;;539    
;;;540    #ifdef FifoPointCheck
;;;541    			if(calc_MRR != ((dm9k_ReadReg(DM9000_REG_MRRH) << 8) + dm9k_ReadReg(DM9000_REG_MRRL)))
;;;542    			{
;;;543    #ifdef Point_Error_Reset
;;;544    				dm9k_reset();								/* 若是指针出错，重置 */
;;;545    				return ReceiveLength;
;;;546    #endif
;;;547    				/*若是指针出错，将指针移到下一个包的包头位置  */
;;;548    				dm9k_WriteReg(DM9000_REG_MRRH, (calc_MRR >> 8) & 0xff);
;;;549    				dm9k_WriteReg(DM9000_REG_MRRL, calc_MRR & 0xff);
;;;550    			}
;;;551    #endif
;;;552    			dm9k_WriteReg(DM9000_REG_MRRH, (calc_MRR >> 8) & 0xff);
;;;553    			dm9k_WriteReg(DM9000_REG_MRRL, calc_MRR & 0xff);
;;;554    			return receiveLen_DM9000;
;;;555    		}
;;;556    		else
;;;557    		{
;;;558    			if(rx_checkbyte == DM9000_PKT_NORDY)		/* 未收到包 */
00042c  2800              CMP      r0,#0
00042e  d05e              BEQ      |L1.1262|
;;;559    			{
;;;560    				dm9k_WriteReg(DM9000_REG_ISR, 0x3f);				/*  */
;;;561    			}
;;;562    			else
;;;563    			{
;;;564    				dm9k_err_reset();								/* 接收指针出错，重置 */
000430  f7fffffe          BL       dm9k_err_reset
                  |L1.1076|
;;;565    			}
;;;566    			return (0);
;;;567    		}
;;;568    	}while(rx_int_count < Max_Int_Count);				/* 是否超过最多接收封包计数 */
;;;569    	return 0;
000434  2000              MOVS     r0,#0
                  |L1.1078|
;;;570    }
000436  f50d6d48          ADD      sp,sp,#0xc80
00043a  bd70              POP      {r4-r6,pc}
                  |L1.1084|
00043c  4964              LDR      r1,|L1.1488|
00043e  20f2              MOVS     r0,#0xf2              ;501
000440  8008              STRH     r0,[r1,#0]            ;501
000442  8819              LDRH     r1,[r3,#0]            ;502
000444  8818              LDRH     r0,[r3,#0]            ;503
000446  f5b06fc0          CMP      r0,#0x600             ;505
00044a  d900              BLS      |L1.1102|
00044c  2201              MOVS     r2,#1                 ;506
                  |L1.1102|
00044e  0449              LSLS     r1,r1,#17             ;510
000450  d503              BPL      |L1.1114|
000452  f5b07ffa          CMP      r0,#0x1f4             ;512
000456  d900              BLS      |L1.1114|
000458  2201              MOVS     r2,#1                 ;513
                  |L1.1114|
00045a  1821              ADDS     r1,r4,r0              ;518
00045c  1d09              ADDS     r1,r1,#4              ;518
00045e  b28c              UXTH     r4,r1                 ;518
000460  07c1              LSLS     r1,r0,#31             ;519
000462  d001              BEQ      |L1.1128|
000464  1c64              ADDS     r4,r4,#1              ;519
000466  b2a4              UXTH     r4,r4                 ;519
                  |L1.1128|
000468  f5b44f80          CMP      r4,#0x4000            ;520
00046c  d302              BCC      |L1.1140|
00046e  f5a45450          SUB      r4,r4,#0x3400         ;520
000472  b2a4              UXTH     r4,r4                 ;520
                  |L1.1140|
000474  b152              CBZ      r2,|L1.1164|
000476  0a21              LSRS     r1,r4,#8              ;525
000478  20f5              MOVS     r0,#0xf5              ;525
00047a  f7fffffe          BL       dm9k_WriteReg
00047e  b2e1              UXTB     r1,r4                 ;526
000480  20f4              MOVS     r0,#0xf4              ;526
000482  f7fffffe          BL       dm9k_WriteReg
000486  2d00              CMP      r5,#0                 ;527
000488  d0bd              BEQ      |L1.1030|
00048a  e7d3              B        |L1.1076|
                  |L1.1164|
00048c  1c41              ADDS     r1,r0,#1              ;531
00048e  084d              LSRS     r5,r1,#1              ;531
000490  2100              MOVS     r1,#0                 ;532
000492  466a              MOV      r2,sp                 ;482
000494  e004              B        |L1.1184|
                  |L1.1174|
000496  881e              LDRH     r6,[r3,#0]            ;533
000498  f8226011          STRH     r6,[r2,r1,LSL #1]     ;533
00049c  1c49              ADDS     r1,r1,#1              ;533
00049e  b289              UXTH     r1,r1                 ;532
                  |L1.1184|
0004a0  42a9              CMP      r1,r5                 ;532
0004a2  d3f8              BCC      |L1.1174|
0004a4  1f00              SUBS     r0,r0,#4              ;532
0004a6  4d4b              LDR      r5,|L1.1492|
0004a8  b282              UXTH     r2,r0                 ;536
0004aa  4669              MOV      r1,sp                 ;537
0004ac  806a              STRH     r2,[r5,#2]            ;536
0004ae  484a              LDR      r0,|L1.1496|
0004b0  f7fffffe          BL       __aeabi_memcpy
0004b4  20f4              MOVS     r0,#0xf4              ;541
0004b6  f7fffffe          BL       dm9k_ReadReg
0004ba  4602              MOV      r2,r0                 ;541
0004bc  20f5              MOVS     r0,#0xf5              ;541
0004be  f7fffffe          BL       dm9k_ReadReg
0004c2  eb022000          ADD      r0,r2,r0,LSL #8       ;541
0004c6  42a0              CMP      r0,r4                 ;541
0004c8  d007              BEQ      |L1.1242|
0004ca  0a21              LSRS     r1,r4,#8              ;548
0004cc  20f5              MOVS     r0,#0xf5              ;548
0004ce  f7fffffe          BL       dm9k_WriteReg
0004d2  b2e1              UXTB     r1,r4                 ;549
0004d4  20f4              MOVS     r0,#0xf4              ;549
0004d6  f7fffffe          BL       dm9k_WriteReg
                  |L1.1242|
0004da  0a21              LSRS     r1,r4,#8              ;552
0004dc  20f5              MOVS     r0,#0xf5              ;552
0004de  f7fffffe          BL       dm9k_WriteReg
0004e2  b2e1              UXTB     r1,r4                 ;553
0004e4  20f4              MOVS     r0,#0xf4              ;553
0004e6  f7fffffe          BL       dm9k_WriteReg
0004ea  8868              LDRH     r0,[r5,#2]            ;554  ; receiveLen_DM9000
0004ec  e7a3              B        |L1.1078|
                  |L1.1262|
0004ee  213f              MOVS     r1,#0x3f              ;560
0004f0  20fe              MOVS     r0,#0xfe              ;560
0004f2  f7fffffe          BL       dm9k_WriteReg
0004f6  e79d              B        |L1.1076|
;;;571    
                          ENDP

                  dm9k_send_packet PROC
;;;579    */
;;;580    void dm9k_send_packet(uint8_t *p_char, uint16_t length)
0004f8  b570              PUSH     {r4-r6,lr}
;;;581    {
0004fa  460b              MOV      r3,r1
0004fc  4604              MOV      r4,r0
;;;582    	uint16_t SendLength = length;
;;;583    	uint16_t *SendData = (uint16_t *) p_char;
;;;584    	uint16_t i;
;;;585    	uint16_t calc_len;
;;;586    	__IO uint16_t calc_MWR;
;;;587      uint32_t timer2;
;;;588      
;;;589    	/* 检查 DM9000A 是否还在传送中！若是等待直到传送结束 */
;;;590    	dm9k_WriteReg(DM9000_REG_IMR,DM9000_IMR_OFF);		//关闭网卡中断 
0004fe  2180              MOVS     r1,#0x80
000500  20ff              MOVS     r0,#0xff
000502  f7fffffe          BL       dm9k_WriteReg
;;;591    //	if(SendPackOk == Max_Send_Pack)
;;;592    //	{
;;;593    //		timer2=bsp_GetTickCount();
;;;594    //		while(dm9k_ReadReg(DM9000_REG_TCR) & DM9000_TCR_SET)
;;;595    //		{
;;;596    //			Delay_us (5);
;;;597    //			if(bsp_GetTickCount()-timer2>=1000)
;;;598    //				 break;
;;;599    //		}
;;;600    //		SendPackOk = 0;
;;;601    //	}
;;;602    
;;;603    //	SendPackOk++;										/* 设置传送计数 */
;;;604    	NET_REG_ADDR = DM9000_REG_MWCMD;
000506  4932              LDR      r1,|L1.1488|
000508  20f8              MOVS     r0,#0xf8
00050a  8008              STRH     r0,[r1,#0]
;;;605    	/* 开始将系统的资料搬到到内存中，每次移动一个 word */
;;;606    	calc_len = (SendLength + 1) >> 1;
00050c  1c58              ADDS     r0,r3,#1
00050e  0840              LSRS     r0,r0,#1
;;;607    	for(i = 0; i < calc_len; i++)
000510  2200              MOVS     r2,#0
;;;608    		NET_REG_DATA = SendData[i];
000512  492e              LDR      r1,|L1.1484|
000514  e004              B        |L1.1312|
                  |L1.1302|
000516  f8345012          LDRH     r5,[r4,r2,LSL #1]
00051a  800d              STRH     r5,[r1,#0]
00051c  1c52              ADDS     r2,r2,#1
00051e  b292              UXTH     r2,r2                 ;607
                  |L1.1312|
000520  4282              CMP      r2,r0                 ;607
000522  d3f8              BCC      |L1.1302|
;;;609    		
;;;610    	dm9k_WriteReg(DM9000_REG_TXPLH, (SendLength >> 8) & 0xff);	/* 设置传送封包的长度 */
000524  0a19              LSRS     r1,r3,#8
000526  20fd              MOVS     r0,#0xfd
000528  f7fffffe          BL       dm9k_WriteReg
;;;611    	dm9k_WriteReg(DM9000_REG_TXPLL, SendLength & 0xff);
00052c  b2d9              UXTB     r1,r3
00052e  20fc              MOVS     r0,#0xfc
000530  f7fffffe          BL       dm9k_WriteReg
;;;612    	dm9k_WriteReg(DM9000_REG_TCR, DM9000_TCR_SET);				/* 进行传送 */
000534  2101              MOVS     r1,#1
000536  2002              MOVS     r0,#2
000538  f7fffffe          BL       dm9k_WriteReg
;;;613    	timer2=bsp_GetTickCount();
00053c  f7fffffe          BL       bsp_GetTickCount
000540  4604              MOV      r4,r0
;;;614    	while(dm9k_ReadReg(DM9000_REG_TCR)&0x01)
000542  e004              B        |L1.1358|
                  |L1.1348|
;;;615    	   {  
;;;616    			if(bsp_GetTickCount()-timer2>=100)
000544  f7fffffe          BL       bsp_GetTickCount
000548  1b00              SUBS     r0,r0,r4
00054a  2864              CMP      r0,#0x64
00054c  d204              BCS      |L1.1368|
                  |L1.1358|
00054e  2002              MOVS     r0,#2                 ;614
000550  f7fffffe          BL       dm9k_ReadReg
000554  07c0              LSLS     r0,r0,#31             ;614
000556  d1f5              BNE      |L1.1348|
                  |L1.1368|
;;;617    				 break;
;;;618    		 }
;;;619    	dm9k_WriteReg(DM9000_REG_NSR, 0x2c);
000558  212c              MOVS     r1,#0x2c
00055a  2001              MOVS     r0,#1
00055c  f7fffffe          BL       dm9k_WriteReg
;;;620    	dm9k_WriteReg(DM9000_REG_IMR , DM9000_IMR_OFF);
000560  e8bd4070          POP      {r4-r6,lr}
000564  2180              MOVS     r1,#0x80
000566  20ff              MOVS     r0,#0xff
000568  e7fe              B        dm9k_WriteReg
;;;621    //	dm9k_err_reset();
;;;622    	return;
;;;623    }
;;;624    /*
                          ENDP

                  dm9k_interrupt PROC
;;;631    */
;;;632    void  dm9k_interrupt(void)
00056a  b510              PUSH     {r4,lr}
;;;633    {
;;;634    	uint8_t  save_reg;
;;;635    	uint16_t isr_status;
;;;636    
;;;637    	save_reg = NET_REG_ADDR;							/* 暂存所使用的位置 */
00056c  4c18              LDR      r4,|L1.1488|
00056e  8820              LDRH     r0,[r4,#0]
;;;638    	dm9k_WriteReg(DM9000_REG_IMR , DM9000_IMR_OFF);				/* 关闭 DM9000A 中断 */
000570  2180              MOVS     r1,#0x80
000572  b2c3              UXTB     r3,r0                 ;637
000574  20ff              MOVS     r0,#0xff
000576  f7fffffe          BL       dm9k_WriteReg
;;;639    	isr_status = dm9k_ReadReg(DM9000_REG_ISR);					/* 取得中断产生值 */
00057a  20fe              MOVS     r0,#0xfe
00057c  f7fffffe          BL       dm9k_ReadReg
;;;640    
;;;641    	if (isr_status & DM9000_RX_INTR)
;;;642    	{ 					/* 检查是否为接收中断 */
;;;643    		//dm9k_receive_packet();							/* 执行接收处理程序 */
;;;644    	}
;;;645    	dm9k_WriteReg(DM9000_REG_IMR , DM9000_IMR_SET);				/* 开启 DM9000A 中断 */
000580  2181              MOVS     r1,#0x81
000582  20ff              MOVS     r0,#0xff
000584  f7fffffe          BL       dm9k_WriteReg
;;;646    	NET_REG_ADDR = save_reg;							/* 回复所使用的位置 */
000588  8023              STRH     r3,[r4,#0]
;;;647    
;;;648    }
00058a  e728              B        |L1.990|
;;;649    /**
                          ENDP

                  dm9k_ReadID PROC
;;;669    */
;;;670    uint32_t dm9k_ReadID(void)
00058c  b510              PUSH     {r4,lr}
;;;671    {
;;;672    	uint8_t vid1,vid2,pid1,pid2;
;;;673    
;;;674    	if (s_FSMC_Init_Ok == 0)
00058e  4c11              LDR      r4,|L1.1492|
000590  7860              LDRB     r0,[r4,#1]  ; s_FSMC_Init_Ok
000592  b928              CBNZ     r0,|L1.1440|
;;;675    	{
;;;676    		DM9K_CtrlLinesConfig();/* FSMC IO口配置 */
000594  f7fffffe          BL       DM9K_CtrlLinesConfig
;;;677    		DM9K_FSMCConfig();/* FSMC 参数配置 */
000598  f7fffffe          BL       DM9K_FSMCConfig
;;;678    
;;;679    		s_FSMC_Init_Ok = 1;
00059c  2001              MOVS     r0,#1
00059e  7060              STRB     r0,[r4,#1]
                  |L1.1440|
;;;680    	}
;;;681    	vid1 = dm9k_ReadReg(DM9000_REG_VID_L) & 0xFF;/* DM9000 的vid值低位 */
0005a0  2028              MOVS     r0,#0x28
0005a2  f7fffffe          BL       dm9k_ReadReg
0005a6  4602              MOV      r2,r0
;;;682    	vid2 = dm9k_ReadReg(DM9000_REG_VID_H) & 0xFF;/* DM9000 的vid值高位 */
0005a8  2029              MOVS     r0,#0x29
0005aa  f7fffffe          BL       dm9k_ReadReg
0005ae  4603              MOV      r3,r0
;;;683    	pid1 = dm9k_ReadReg(DM9000_REG_PID_L) & 0xFF;/* DM9000 的pid值低位 */
0005b0  202a              MOVS     r0,#0x2a
0005b2  f7fffffe          BL       dm9k_ReadReg
0005b6  4604              MOV      r4,r0
;;;684    	pid2 = dm9k_ReadReg(DM9000_REG_PID_H) & 0xFF;/* DM9000 的pid值高位 */
0005b8  202b              MOVS     r0,#0x2b
0005ba  f7fffffe          BL       dm9k_ReadReg
;;;685    	return (vid2 << 24) | (vid1 << 16) | (pid2 << 8) | pid1;
0005be  0619              LSLS     r1,r3,#24
0005c0  ea414102          ORR      r1,r1,r2,LSL #16
0005c4  ea412000          ORR      r0,r1,r0,LSL #8
0005c8  4320              ORRS     r0,r0,r4
;;;686    }
0005ca  e708              B        |L1.990|
;;;687    
                          ENDP

                  |L1.1484|
                          DCD      0x68480000
                  |L1.1488|
                          DCD      0x68400000
                  |L1.1492|
                          DCD      ||.data||
                  |L1.1496|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  receiveBuffer_DM9000
                          %        200

                          AREA ||area_number.4||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.4||, ||.bss||
                  receiveBuffer
                          %        200

                          AREA ||.data||, DATA, ALIGN=1

                  SendPackOk
000000  00                DCB      0x00
                  s_FSMC_Init_Ok
000001  00                DCB      0x00
                  receiveLen_DM9000
000002  0000              DCB      0x00,0x00
                  DEF_MAC_ADDR
000004  01020102          DCB      0x01,0x02,0x01,0x02
000008  0102              DCB      0x01,0x02

                          AREA ||area_number.7||, DATA, ALIGN=1

                          EXPORTAS ||area_number.7||, ||.data||
                  receiveLen
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\HARDWARE\\ETHERNET\\DM9000.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_DM9000_c_75898a95____REV16|
#line 129 "..\\CORE\\core_cmInstr.h"
|__asm___8_DM9000_c_75898a95____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_DM9000_c_75898a95____REVSH|
#line 144
|__asm___8_DM9000_c_75898a95____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
